# <gh>
name: Probe chat Github Action

on:
  workflow_call:
    inputs:
      command_prefix:
        description: "The prefix required on comments to trigger the AI (e.g., /probe, /ai, etc)"
        default: "/probe"
        required: true
        type: string
      default_probe_chat_command:
        description: "The default probe-chat command if PROBE_CHAT_COMMAND secret is not set"
        required: false
        default: "npx -y @buger/probe-chat@latest"
        type: string
      # Note: The actual probe-chat command to run will prioritize the PROBE_CHAT_COMMAND secret
      # passed by the caller via "secrets: inherit", then fall back to inputs.default_probe_chat_command.

# Permissions required by the jobs within THIS reusable workflow
permissions:
  pull-requests: write # Needed for reading PR data/comments/reviews, posting comments, adding reactions
  issues: write        # Needed for reading issue data/comments, posting comments, adding reactions
  contents: read
  reactions: write     # Explicitly required for gh api reaction POST

jobs:
  process_comment:
    if: startsWith(github.event.comment.body, inputs.command_prefix)
    runs-on: ubuntu-latest
    outputs:
      response_body: ${{ steps.read_response.outputs.response }}
      # --- FIX: Point to the correct step for issue_number output ---
      issue_number: ${{ steps.set_context_ids.outputs.issue_number }}
      probe_succeeded: ${{ steps.probe.outcome == 'success' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install jq (if needed) and Verify gh
        run: |
          sudo apt-get update && sudo apt-get install -y jq --no-install-recommends
          gh --version

      - name: Set Issue Number and Comment ID Output
        id: set_context_ids
        run: |
          echo "issue_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          echo "comment_id=${{ github.event.comment.id }}" >> $GITHUB_OUTPUT

      - name: Add 'eyes' reaction to comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          COMMENT_ID: ${{ steps.set_context_ids.outputs.comment_id }}
        run: |
          echo "Adding ðŸ‘€ reaction to comment ID ${COMMENT_ID} in repo ${REPO}"
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            "/repos/${REPO}/issues/comments/${COMMENT_ID}/reactions" \
            -f content='eyes' \
            --silent || echo "::warning::Failed to add reaction to comment ${COMMENT_ID}. Continuing..."

      # --- MODIFIED: Determine Context, Fetch ALL Comments, Format Input ---
      - name: Determine Context, Fetch Comments, Format Input
        id: format
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
          REPO: ${{ github.repository }}
        run: |
          shopt -s extglob
          set -e
          # set -x

          ISSUE_OR_PR_NUMBER=${{ steps.set_context_ids.outputs.issue_number }}
          RAW_COMMENT_BODY="${{ github.event.comment.body }}"
          GITHUB_API_ARGS=(-H "Accept: application/vnd.github+json" --silent) # Common args for gh api

          # Basic XML escaping function
          escape_xml() {
            sed -e 's/&/\&/g' -e 's/</\</g' -e 's/>/\>/g' -e 's/"/\"/g' -e "s/'/\'/g"
          }

          # Extract user request
          USER_REQUEST_BODY_RAW="${RAW_COMMENT_BODY#${COMMAND_PREFIX}}"
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW##*( )}"
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW%%*( )}"
          USER_REQUEST_BODY=$(echo "$USER_REQUEST_BODY_RAW" | escape_xml)
          echo "User request extracted and escaped: [${USER_REQUEST_BODY:0:100}...]"

          # Determine context type
          CONTEXT_TYPE="issue"
          if gh api "${GITHUB_API_ARGS[@]}" "/repos/${REPO}/issues/$ISSUE_OR_PR_NUMBER" --jq '.pull_request' 2>/dev/null | grep -q 'url'; then
             CONTEXT_TYPE="pr"
          fi
          echo "Context type: $CONTEXT_TYPE"

          # --- Fetch ALL Comments ---
          COMMENTS_XML=""

          # 1. Fetch regular issue/PR comments
          echo "Fetching standard comments for $CONTEXT_TYPE #$ISSUE_OR_PR_NUMBER..."
          STANDARD_COMMENTS_JSON=$(gh api "${GITHUB_API_ARGS[@]}" "/repos/${REPO}/issues/$ISSUE_OR_PR_NUMBER/comments" --jq '.' || echo "[]")
          if [[ -n "$STANDARD_COMMENTS_JSON" && "$STANDARD_COMMENTS_JSON" != "[]" ]]; then
              echo "$STANDARD_COMMENTS_JSON" | jq -c '.[] | {login: .user.login, created_at: .created_at, body: .body}' | while IFS= read -r comment_json; do
                  login=$(echo "$comment_json" | jq -r .login | escape_xml)
                  created_at=$(echo "$comment_json" | jq -r .created_at)
                  body=$(echo "$comment_json" | jq -r .body | escape_xml)
                  COMMENTS_XML="${COMMENTS_XML}<comment type=\"issue\"><author>$login</author><timestamp>$created_at</timestamp><content>$body</content></comment>"
                  echo "  Processed standard comment by $login" # Debug log
              done || { echo "::warning::Error processing standard comments JSON. Skipping."; COMMENTS_XML="${COMMENTS_XML}<!-- Error processing standard comments -->"; }
          else
              echo "  No standard comments found or fetch failed."
          fi

          # --- Fetch Context-Specific Data & Build XML ---
          CONTEXT_DETAILS_XML=""
          DIFF_XML=""
          PROMPT_INSTRUCTION=""

          if [[ "$CONTEXT_TYPE" == "pr" ]]; then
            echo "Fetching PR details and diff..."
            PR_DATA=$(gh pr view $ISSUE_OR_PR_NUMBER --json title,body --repo ${REPO} || echo '{"title": "Error fetching PR title", "body": "Error fetching PR body"}')
            PR_TITLE=$(echo "$PR_DATA" | jq -r .title | escape_xml)
            PR_BODY=$(echo "$PR_DATA" | jq -r .body | escape_xml)
            PR_DIFF=$(gh pr diff $ISSUE_OR_PR_NUMBER --repo ${REPO} 2>/dev/null || echo "<!-- Error fetching diff -->") # No escaping needed here as it goes in <diff> raw

            CONTEXT_DETAILS_XML="<details><title>$PR_TITLE</title><body>$PR_BODY</body></details>"
            DIFF_XML="<diff>$PR_DIFF</diff>"

            # 2. Fetch PR review comments (comments on the diff)
            echo "Fetching PR review comments (diff comments)..."
            REVIEW_COMMENTS_JSON=$(gh api "${GITHUB_API_ARGS[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER/comments" --jq '.' || echo "[]")
             if [[ -n "$REVIEW_COMMENTS_JSON" && "$REVIEW_COMMENTS_JSON" != "[]" ]]; then
                echo "$REVIEW_COMMENTS_JSON" | jq -c '.[] | {login: .user.login, created_at: .created_at, body: .body, path: .path, line: .line}' | while IFS= read -r comment_json; do
                    login=$(echo "$comment_json" | jq -r .login | escape_xml)
                    created_at=$(echo "$comment_json" | jq -r .created_at)
                    body=$(echo "$comment_json" | jq -r .body | escape_xml)
                    path=$(echo "$comment_json" | jq -r .path | escape_xml)
                    line=$(echo "$comment_json" | jq -r .line) # Line number usually doesn't need escaping
                    COMMENTS_XML="${COMMENTS_XML}<comment type=\"review_comment\" file=\"$path\" line=\"$line\"><author>$login</author><timestamp>$created_at</timestamp><content>$body</content></comment>"
                    echo "  Processed review comment by $login on $path:$line" # Debug log
                done || { echo "::warning::Error processing review comments JSON. Skipping."; COMMENTS_XML="${COMMENTS_XML}<!-- Error processing review comments -->"; }
            else
                echo "  No PR review comments found or fetch failed."
            fi

            # 3. Fetch PR reviews (overall review comments/states)
            echo "Fetching PR reviews..."
            REVIEWS_JSON=$(gh api "${GITHUB_API_ARGS[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER/reviews" --jq '.[] | select(.body != null and .body != "")' || echo "[]") # Filter out reviews without bodies
             if [[ -n "$REVIEWS_JSON" && "$REVIEWS_JSON" != "[]" ]]; then
                echo "$REVIEWS_JSON" | jq -c '. | {login: .user.login, submitted_at: .submitted_at, body: .body, state: .state}' | while IFS= read -r review_json; do
                    login=$(echo "$review_json" | jq -r .login | escape_xml)
                    submitted_at=$(echo "$review_json" | jq -r .submitted_at)
                    body=$(echo "$review_json" | jq -r .body | escape_xml)
                    state=$(echo "$review_json" | jq -r .state | escape_xml)
                    COMMENTS_XML="${COMMENTS_XML}<comment type=\"review_body\" state=\"$state\"><author>$login</author><timestamp>$submitted_at</timestamp><content>$body</content></comment>"
                    echo "  Processed review body by $login (State: $state)" # Debug log
                done || { echo "::warning::Error processing reviews JSON. Skipping."; COMMENTS_XML="${COMMENTS_XML}<!-- Error processing reviews -->"; }
            else
                echo "  No PR reviews with bodies found or fetch failed."
            fi


            # --- MODIFIED PR PROMPT (Less Restrictive) ---
            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Pull Request. Use the information provided within the <github_context> XML structure (including PR details, comments/reviews, and the code diff) as the primary source to understand the request. Provide a concise and helpful response to the <user_request>. You may leverage your general knowledge or other capabilities where appropriate to enhance the response, focusing on code review, understanding changes, or summarizing intent and impact."

            echo "PR details fetched. Title length: ${#PR_TITLE}, Body length: ${#PR_BODY}"
            echo "Diff fetched. Diff length: ${#PR_DIFF}"

          elif [[ "$CONTEXT_TYPE" == "issue" ]]; then
            echo "Fetching Issue details..."
            ISSUE_DATA=$(gh issue view $ISSUE_OR_PR_NUMBER --json title,body --repo ${REPO} || echo '{"title": "Error fetching Issue title", "body": "Error fetching Issue body"}')
            ISSUE_TITLE=$(echo "$ISSUE_DATA" | jq -r .title | escape_xml)
            ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r .body | escape_xml)

            CONTEXT_DETAILS_XML="<details><title>$ISSUE_TITLE</title><body>$ISSUE_BODY</body></details>"
            DIFF_XML="" # No diff for issues

            # No extra comment types needed for issues, standard comments already fetched above

            # --- MODIFIED ISSUE PROMPT (Less Restrictive) ---
            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Issue. Use the information provided within the <github_context> XML structure (including issue details and comments) as the primary source to understand the request. Provide a concise and helpful response to the <user_request>. You may leverage your general knowledge or other capabilities where appropriate to enhance the response, aiming to summarize the issue, clarify points, suggest potential next steps, or answer questions. If asked for solutions, propose actionable ideas informed by the issue's description and discussion."

            echo "Issue details fetched. Title length: ${#ISSUE_TITLE}, Body length: ${#ISSUE_BODY}"
          fi

          # --- Assemble Final Prompt ---
          echo "Final comments XML length: ${#COMMENTS_XML}" # Log final length
          echo "Assembling final prompt..."
          FORMATTED_PROMPT="<github_context type=\"$CONTEXT_TYPE\" number=\"$ISSUE_OR_PR_NUMBER\">
            ${CONTEXT_DETAILS_XML}
            ${DIFF_XML}
            <comments>
            ${COMMENTS_XML}
            </comments>
            <user_request>${USER_REQUEST_BODY}</user_request>
            </github_context>

            ${PROMPT_INSTRUCTION}"

          if [ -z "$FORMATTED_PROMPT" ]; then
             echo "::error::Formatted prompt became empty after assembly. Check variable contents."
             exit 1
          fi
          echo "Final prompt assembled successfully. Length: ${#FORMATTED_PROMPT}"

          # Output the potentially large prompt securely using delimiters
          echo "formatted_prompt<<EOF_PROMPT_MARKER" >> $GITHUB_OUTPUT
          echo "$FORMATTED_PROMPT" >> $GITHUB_OUTPUT
          echo "EOF_PROMPT_MARKER" >> $GITHUB_OUTPUT
          echo "Formatted prompt output set."

      - name: Determine probe-chat Command
        id: determine_command
        run: |
          CMD="${{ secrets.PROBE_CHAT_COMMAND }}"
          if [[ -z "$CMD" ]]; then
            CMD="${{ inputs.default_probe_chat_command }}"
            echo "Using default probe-chat command."
          else
            echo "Using probe-chat command from PROBE_CHAT_COMMAND secret."
          fi
          echo "Final command: $CMD"
          echo "command=$CMD" >> $GITHUB_OUTPUT

      - name: Run probe-chat
        id: probe
        shell: bash
        env:
          PROBE_PROMPT: ${{ steps.format.outputs.formatted_prompt }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          ANTHROPIC_API_URL: ${{ secrets.ANTHROPIC_API_URL }}
          OPENAI_API_URL: ${{ secrets.OPENAI_API_URL }}
          GOOGLE_API_URL: ${{ secrets.GOOGLE_API_URL }}
          LLM_BASE_URL: ${{ secrets.LLM_BASE_URL }}
          MODEL_NAME: ${{ secrets.MODEL_NAME }}
          FORCE_PROVIDER: ${{ secrets.FORCE_PROVIDER }}
        run: |
          set -e
          set -o pipefail
          PROMPT="$PROBE_PROMPT"
          COMMAND_TO_RUN='${{ steps.determine_command.outputs.command }}'
          RESPONSE_FILE="response.txt"
          ERROR_LOG="error.log"
          > "$RESPONSE_FILE"
          > "$ERROR_LOG"

          if [ -z "$PROMPT" ]; then
            echo "::error::Prompt environment variable (PROBE_PROMPT) is empty. Cannot run probe-chat."
            echo "ðŸ¤– **Error:** Failed to prepare the AI prompt content." > "$RESPONSE_FILE"
            exit 1
          fi

          echo "Running probe-chat..."
          echo "--- Start AI Prompt (first 500 chars) ---"
          printf "%.500s...\n" "$PROMPT"
          echo "--- End AI Prompt Snippet ---"
          echo "Command to run: $COMMAND_TO_RUN"
          EXIT_CODE=0

          echo "$PROMPT" | $COMMAND_TO_RUN > "$RESPONSE_FILE" 2> "$ERROR_LOG" || EXIT_CODE=$?

          if [ $EXIT_CODE -ne 0 ]; then
            echo "::error::probe-chat command failed with exit code $EXIT_CODE."
            echo "Stderr output from probe-chat:"
            cat "$ERROR_LOG"
            echo "ðŸ¤– **Error:** The AI command failed (exit code $EXIT_CODE)." > "$RESPONSE_FILE"
            echo "" >> "$RESPONSE_FILE"
            echo "**Details:**" >> "$RESPONSE_FILE"
            echo '```' >> "$RESPONSE_FILE"
            cat "$ERROR_LOG" 2>/dev/null || echo "(No stderr output captured)" >> "$RESPONSE_FILE"
            echo '```' >> "$RESPONSE_FILE"
            echo "" >> "$RESPONSE_FILE"
            echo "> Check the Action logs for the full prompt and details." >> "$RESPONSE_FILE"
          else
            echo "probe-chat command finished successfully."
          fi

      - name: Read Response or Error and Format Output
        if: always()
        id: read_response
        env:
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
        run: |
          RESPONSE_CONTENT=$(cat response.txt 2>/dev/null || echo "")
          FINAL_BODY=""

          # Define the footer
          FOOTER=$(printf "\n\n-----\n*Tip: Start your comment with \`%s <your request>\` to trigger the AI.*\n*Built by [probe](https://probeai.dev)*" "$COMMAND_PREFIX")

          # Check outcomes and determine main body
          if [[ "${{ steps.probe.outcome }}" == "success" ]] && [[ -n "${RESPONSE_CONTENT// }" ]]; then
             FINAL_BODY="${RESPONSE_CONTENT}${FOOTER}" # Successful response
          elif [[ -z "${RESPONSE_CONTENT// }" ]]; then
             # Response file empty
             if [[ "${{ steps.probe.outcome }}" == "failure" ]]; then
                FINAL_BODY="ðŸ¤– **Error:** Processing failed: AI command execution error. Check Action logs.${FOOTER}" # Generic error if probe failed and left no message
             elif [[ "${{ steps.format.outcome }}" == "failure" ]]; then
                FINAL_BODY="ðŸ¤– **Error:** Processing failed: Error during context preparation. Check Action logs.${FOOTER}"
             else
                FINAL_BODY="ðŸ¤– Processing finished, but no response was generated by the AI.${FOOTER}" # Probe succeeded but empty output
             fi
          else
             # Probe failed, but response.txt has content (likely the formatted error from probe step)
             FINAL_BODY="${RESPONSE_CONTENT}${FOOTER}"
          fi

          echo "Final response body prepared for output."
          # Use multi-line output handling
          echo "response<<EOF_RESPONSE_MARKER" >> $GITHUB_OUTPUT
          echo "$FINAL_BODY" >> $GITHUB_OUTPUT
          echo "EOF_RESPONSE_MARKER" >> $GITHUB_OUTPUT

  # Job 2: Post the response back to GitHub
  post_response:
    if: needs.process_comment.result != 'skipped'
    runs-on: ubuntu-latest
    needs: [process_comment]
    steps:
      - name: Post Response Comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          # --- FIX: Use the correctly defined output from the previous job ---
          issue-number: ${{ needs.process_comment.outputs.issue_number }}
          body: ${{ needs.process_comment.outputs.response_body }}
# </gh>
