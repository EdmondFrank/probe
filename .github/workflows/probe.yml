# <gh>
name: Probe chat Github Action

on:
  workflow_call:
    inputs:
      command_prefix:
        description: "The prefix required on comments to trigger the AI (e.g., /probe, /ai, etc)"
        default: "/probe"
        required: true
        type: string
      default_probe_chat_command:
        description: "The default probe-chat command if PROBE_CHAT_COMMAND secret is not set"
        required: false
        default: "npx -y @buger/probe-chat@latest"
        type: string

permissions:
  pull-requests: write
  issues: write
  contents: read

jobs:
  process_comment:
    if: >
      startsWith(github.event.comment.body, inputs.command_prefix) &&
      github.event.issue.number != null &&
      github.event.comment.id != null
    runs-on: ubuntu-latest
    outputs:
      response_body: ${{ steps.read_response.outputs.response }}
      issue_number: ${{ steps.set_context_ids.outputs.issue_number }}
      probe_succeeded: ${{ steps.probe.outcome == 'success' }}
      context_type: ${{ steps.format.outputs.context_type }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install jq, perl and Verify gh
        run: |
          sudo apt-get update && sudo apt-get install -y jq perl --no-install-recommends
          gh --version

      - name: Set Issue Number and Comment ID Output
        id: set_context_ids
        run: |
          echo "issue_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          echo "comment_id=${{ github.event.comment.id }}" >> $GITHUB_OUTPUT
          echo "Context ID (Issue/PR Number): ${{ github.event.issue.number }}, Comment ID: ${{ github.event.comment.id }}"

      - name: Add 'eyes' reaction to comment
        id: add_reaction
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          COMMENT_ID: ${{ steps.set_context_ids.outputs.comment_id }}
        run: |
          echo "Adding ðŸ‘€ reaction to comment ID ${COMMENT_ID}..."
          gh api --method POST -H "Accept: application/vnd.github+json" "/repos/${REPO}/issues/comments/${COMMENT_ID}/reactions" -f content='eyes' --silent || echo "::warning::Failed reaction."

      - name: Determine Context, Fetch Comments, Format Input
        id: format
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
          REPO: ${{ github.repository }}
        run: |
          # --- Initialization ---
          echo "::group::Initialization and User Request Extraction"
          shopt -s extglob
          set -e
          ISSUE_OR_PR_NUMBER=${{ steps.set_context_ids.outputs.issue_number }}
          RAW_COMMENT_BODY="${{ github.event.comment.body }}"
          GITHUB_API_ARGS_VERBOSE=(-H "Accept: application/vnd.github+json")
          
          # No escape_xml function needed; we are using raw text.
          USER_REQUEST_BODY_RAW="${RAW_COMMENT_BODY#${COMMAND_PREFIX}}"
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW##*( )}"
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW%%*( )}"
          USER_REQUEST_BODY="$USER_REQUEST_BODY_RAW"
          COMMENTS_XML=""
          echo "User request extracted: [${USER_REQUEST_BODY:0:100}...]"
          echo "::endgroup::"

          # --- Determine Context ---
          echo "::group::Determine Context Type"
          CONTEXT_TYPE="issue"
          echo "Detecting context for #$ISSUE_OR_PR_NUMBER in $REPO"
          if gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER" --jq .url > /dev/null 2>&1; then
             CONTEXT_TYPE="pr"
             echo "Context: PR"
          else
             EXIT_CODE=$?
             echo "PR API check failed ($EXIT_CODE). Assuming: Issue"
             if ! gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/issues/$ISSUE_OR_PR_NUMBER" --jq .url > /dev/null 2>&1; then
               echo "::warning::Issue API check also failed ($?). Check permissions/number."
             fi
             CONTEXT_TYPE="issue"
          fi
          FINAL_CONTEXT_TYPE=$CONTEXT_TYPE
          echo "Final Context Type: $FINAL_CONTEXT_TYPE"
          echo "::endgroup::"

          # --- Fetch Comments and Context Details ---
          echo "::group::Fetch Comments and Context Details"
          # --- Standard Comments ---
          echo "Fetching standard comments..."
          STD_COMMENTS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/issues/$ISSUE_OR_PR_NUMBER/comments" --paginate || echo "FETCH_FAILED")

          if [[ "$STD_COMMENTS_JSON" == "FETCH_FAILED" || -z "$STD_COMMENTS_JSON" ]]; then
              echo "::warning::Failed to fetch standard comments JSON or received empty response."
          else
              echo "$STD_COMMENTS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1
              IS_JSON_ARRAY_EXIT_CODE=$?
              if [[ $IS_JSON_ARRAY_EXIT_CODE -eq 0 ]]; then
                  TSV_OUTPUT=$(echo "$STD_COMMENTS_JSON" | jq -r '.[] | [.user.login // "unknown", .created_at // "N/A", .body // ""] | @tsv' 2> jq_std_error.log)
                  JQ_EXIT_CODE=$?
                  if [[ $JQ_EXIT_CODE -eq 0 ]]; then
                      if [[ -n "$TSV_OUTPUT" ]]; then
                          echo "Processing standard comments..."
                          while IFS=$'\t' read -r login created_at body; do
                              [[ -n "$login" || -n "$created_at" || -n "$body" ]] || continue
                              escaped_login="$login"
                              escaped_body="$body"
                              COMMENTS_XML="${COMMENTS_XML}<comment type=\"issue\"><author>$escaped_login</author><timestamp>$created_at</timestamp><content>$escaped_body</content></comment>"
                          done <<< "$TSV_OUTPUT"
                      else
                          echo "Standard comments JSON valid, but no comments found or jq produced empty TSV."
                      fi
                  else
                      echo "::warning::jq failed processing standard comments (exit code $JQ_EXIT_CODE). Error log:"
                      cat jq_std_error.log
                  fi
              else
                  echo "::warning::Fetched standard comments data is not a valid JSON array."
              fi
          fi
          echo "Standard comments processed. Current XML length: ${#COMMENTS_XML}"

          # --- Context Specific ---
          CONTEXT_DETAILS_XML=""
          DIFF_XML=""
          PROMPT_INSTRUCTION=""

          if [[ "$FINAL_CONTEXT_TYPE" == "pr" ]]; then
            echo "Fetching PR specific data..."
            PR_DATA=$(gh pr view "$ISSUE_OR_PR_NUMBER" --json title,body --repo "${REPO}" 2>/dev/null || echo 'FETCH_FAILED')
            if [[ "$PR_DATA" == "FETCH_FAILED" ]]; then
              echo "::warning::Failed PR details fetch."
              PR_TITLE="Error"
              PR_BODY="Error"
            else
              PR_TITLE=$(echo "$PR_DATA" | jq -r .title)
              PR_BODY=$(echo "$PR_DATA" | jq -r .body)
            fi

            PR_DIFF=$(gh pr diff "$ISSUE_OR_PR_NUMBER" --repo "${REPO}" 2>/dev/null || echo "FETCH_FAILED")
            if [[ "$PR_DIFF" == "FETCH_FAILED" ]]; then
              echo "::warning::Failed PR diff fetch."
              ESCAPED_PR_DIFF="<!-- Error fetching diff -->"
            else
              ESCAPED_PR_DIFF="$PR_DIFF"
            fi

            CONTEXT_DETAILS_XML="<details><title>$PR_TITLE</title><body>$PR_BODY</body></details>"
            DIFF_XML="<diff>$ESCAPED_PR_DIFF</diff>"

            # PR Review Comments
            echo "Fetching PR review comments..."
            REVIEW_COMMENTS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER/comments" --paginate || echo "FETCH_FAILED")
            if [[ "$REVIEW_COMMENTS_JSON" == "FETCH_FAILED" || -z "$REVIEW_COMMENTS_JSON" ]]; then
                echo "::warning::Failed to fetch PR review comments JSON or received empty response."
            else
                echo "$REVIEW_COMMENTS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1
                IS_JSON_ARRAY_EXIT_CODE=$?
                if [[ $IS_JSON_ARRAY_EXIT_CODE -eq 0 ]]; then
                    TSV_OUTPUT=$(echo "$REVIEW_COMMENTS_JSON" | jq -r '.[] | [.user.login // "unknown", .created_at // "N/A", .body // "", .path // "unknown", .diff_hunk // "", (.line // .original_line // "N/A")] | @tsv' 2> jq_rev_com_error.log)
                    JQ_EXIT_CODE=$?
                    if [[ $JQ_EXIT_CODE -eq 0 ]]; then
                         if [[ -n "$TSV_OUTPUT" ]]; then
                            echo "Processing review comments..."
                            while IFS=$'\t' read -r login created_at body path diff_hunk line; do
                               [[ -n "$login" || -n "$created_at" || -n "$body" ]] || continue
                               escaped_login="$login"
                               escaped_body="$body"
                               escaped_path="$path"
                               escaped_diff_hunk="$diff_hunk"
                               COMMENTS_XML="${COMMENTS_XML}<comment type=\"review_comment\" file=\"$escaped_path\" line=\"$line\"><author>$escaped_login</author><timestamp>$created_at</timestamp><diff_hunk>$escaped_diff_hunk</diff_hunk><content>$escaped_body</content></comment>"
                            done <<< "$TSV_OUTPUT"
                         else
                            echo "Review comments JSON valid, but no comments found or jq produced empty TSV."
                         fi
                    else
                         echo "::warning::jq failed processing review comments (exit code $JQ_EXIT_CODE). Error log:"
                         cat jq_rev_com_error.log
                    fi
                else
                     echo "::warning::Fetched review comments data is not a valid JSON array."
                fi
            fi
            echo "Review comments processed. Current XML length: ${#COMMENTS_XML}"

            # PR Reviews (Bodies)
            echo "Fetching PR reviews..."
            REVIEWS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER/reviews" --paginate || echo "FETCH_FAILED")
            if [[ "$REVIEWS_JSON" == "FETCH_FAILED" || -z "$REVIEWS_JSON" ]]; then
                 echo "::warning::Failed to fetch PR reviews JSON or received empty response."
            else
                 echo "$REVIEWS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1
                 IS_JSON_ARRAY_EXIT_CODE=$?
                 if [[ $IS_JSON_ARRAY_EXIT_CODE -eq 0 ]]; then
                     TSV_OUTPUT=$(echo "$REVIEWS_JSON" | jq -r '.[] | select(.body != null and .body != "") | [.user.login // "unknown", .submitted_at // "N/A", .body, .state // "N/A"] | @tsv' 2> jq_rev_error.log)
                     JQ_EXIT_CODE=$?
                     if [[ $JQ_EXIT_CODE -eq 0 ]]; then
                         if [[ -n "$TSV_OUTPUT" ]]; then
                             echo "Processing review bodies..."
                             while IFS=$'\t' read -r login submitted_at body state; do
                                [[ -n "$login" || -n "$submitted_at" || -n "$body" ]] || continue
                                escaped_login="$login"
                                escaped_body="$body"
                                escaped_state="$state"
                                COMMENTS_XML="${COMMENTS_XML}<comment type=\"review_body\" state=\"$escaped_state\"><author>$escaped_login</author><timestamp>$submitted_at</timestamp><content>$escaped_body</content></comment>"
                             done <<< "$TSV_OUTPUT"
                         else
                             echo "Review JSON valid, but no review bodies with content found or jq produced empty TSV."
                         fi
                     else
                          echo "::warning::jq failed processing review bodies (exit code $JQ_EXIT_CODE). Error log:"
                          cat jq_rev_error.log
                     fi
                 else
                      echo "::warning::Fetched reviews data is not a valid JSON array."
                 fi
            fi
            echo "Review bodies processed. Current XML length: ${#COMMENTS_XML}"

            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Pull Request. Answer user questions contextually..."

          elif [[ "$FINAL_CONTEXT_TYPE" == "issue" ]]; then
            echo "Fetching Issue specific data..."
            ISSUE_DATA=$(gh issue view "$ISSUE_OR_PR_NUMBER" --json title,body --repo "${REPO}" 2>/dev/null || echo 'FETCH_FAILED')
            if [[ "$ISSUE_DATA" == "FETCH_FAILED" ]]; then
              echo "::warning::Failed Issue details fetch."
              ISSUE_TITLE="Error"
              ISSUE_BODY="Error"
            else
              ISSUE_TITLE=$(echo "$ISSUE_DATA" | jq -r .title)
              ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r .body)
            fi
            CONTEXT_DETAILS_XML="<details><title>$ISSUE_TITLE</title><body>$ISSUE_BODY</body></details>"
            DIFF_XML=""
            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Issue. Answer user questions contextually..."
          fi
          echo "::endgroup::"

          # --- Assemble Final Prompt ---
          echo "::group::Assemble Final Prompt & Set Outputs"
          FORMATTED_PROMPT="<github_context type=\"$FINAL_CONTEXT_TYPE\" number=\"$ISSUE_OR_PR_NUMBER\">
            ${CONTEXT_DETAILS_XML}
            ${DIFF_XML}
            <comments>${COMMENTS_XML}</comments>
            <user_request author=\"${{ github.event.comment.user.login }}\" timestamp=\"${{ github.event.comment.created_at }}\">${USER_REQUEST_BODY}</user_request>
            </github_context>

            ${PROMPT_INSTRUCTION}"
          if [ ${#FORMATTED_PROMPT} -lt 200 ]; then
            echo "::warning::Formatted prompt seems short."
          fi
          echo "Final prompt assembled. Length: ${#FORMATTED_PROMPT}"

          PROMPT_FILENAME="formatted_prompt.txt"
          echo "$FORMATTED_PROMPT" > "$PROMPT_FILENAME"
          echo "Prompt written to $PROMPT_FILENAME"

          echo "Setting step outputs..."
          echo "context_type=${FINAL_CONTEXT_TYPE}" >> "$GITHUB_OUTPUT"
          echo "formatted_prompt_file=${PROMPT_FILENAME}" >> "$GITHUB_OUTPUT"
          echo "Outputs set."
          echo "::endgroup::"

      - name: Read Formatted Prompt from File
        id: read_prompt_file
        run: |
          PROMPT_FILE="${{ steps.format.outputs.formatted_prompt_file }}"
          if [[ -f "$PROMPT_FILE" ]]; then
            echo "Reading prompt from $PROMPT_FILE"
            {
              echo "formatted_prompt<<EOF_PROMPT_MARKER"
              cat "$PROMPT_FILE"
              echo "EOF_PROMPT_MARKER"
            } >> "$GITHUB_OUTPUT"
            echo "Set output 'formatted_prompt'."
          else
            echo "::error::Prompt file '$PROMPT_FILE' not found."
            echo "formatted_prompt=" >> "$GITHUB_OUTPUT"
            exit 1
          fi

      - name: Determine probe-chat Command
        id: determine_command
        run: |
          CMD="${{ secrets.PROBE_CHAT_COMMAND || inputs.default_probe_chat_command }}"
          if [[ "${{ secrets.PROBE_CHAT_COMMAND }}" ]]; then
            echo "Using command from secret."
          else
            echo "Using default: ${{ inputs.default_probe_chat_command }}"
          fi
          echo "Final command: $CMD"
          echo "command=$CMD" >> $GITHUB_OUTPUT

      - name: Run probe-chat
        id: probe
        env:
          PROBE_PROMPT: ${{ steps.read_prompt_file.outputs.formatted_prompt }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          set +e  # Disable set -e to prevent premature exit
          set -o pipefail
          PROMPT="$PROBE_PROMPT"
          COMMAND_TO_RUN='${{ steps.determine_command.outputs.command }}'
          RESPONSE_FILE="response.txt"
          ERROR_LOG="error.log"
      
          if [ -z "$PROMPT" ]; then
            echo "::error::Prompt env var empty." >&2
            echo "ðŸ¤– **Error:** Internal error - prompt empty." > "$RESPONSE_FILE"
            exit 1
          fi
      
          echo "Prompt length: ${#PROMPT}"
          echo "Command to run: $COMMAND_TO_RUN"
          echo "Running probe-chat..."
          bash -c "echo \"\$PROMPT\" | $COMMAND_TO_RUN" > "$RESPONSE_FILE" 2> "$ERROR_LOG"
          EXIT_CODE=$?
      
          # Debugging output
          echo "Exit code: $EXIT_CODE"
          if [ -s "$ERROR_LOG" ]; then
            echo "--- stderr ---" >&2
            cat "$ERROR_LOG" >&2
            echo "--- end stderr ---" >&2
          else
            echo "No stderr output from probe-chat." >&2
          fi
          if [ -s "$RESPONSE_FILE" ]; then
            echo "--- response ---" >&2
            cat "$RESPONSE_FILE" >&2
            echo "--- end response ---" >&2
          else
            echo "Response file is empty." >&2
          fi
      
          if [ $EXIT_CODE -ne 0 ]; then
            echo "::error::probe-chat failed with exit code $EXIT_CODE." >&2
            if [ ! -s "$RESPONSE_FILE" ]; then
              echo "ðŸ¤– **Error:** AI command failed (Exit code: $EXIT_CODE)." > "$RESPONSE_FILE"
            fi
            exit $EXIT_CODE
          fi
      
          echo "probe-chat finished successfully." >&2
          if [ ! -s "$RESPONSE_FILE" ]; then
            echo "::warning::probe-chat produced empty response." >&2
            echo "ðŸ¤– AI generated no response." > "$RESPONSE_FILE"
          fi

      - name: Read Response or Error and Format Output
        if: always()
        id: read_response
        env:
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
        run: |
          RESPONSE_CONTENT=$(cat response.txt 2>/dev/null || echo "")
          ERROR_LOG_CONTENT=$(cat error.log 2>/dev/null || echo "")
          FINAL_BODY=""
          FOOTER_TEMPLATE="\n\n-----\n*Tip: Start comment with \`%s <request>\`.*\n*Built by [probe](https://probeai.dev)*"
          printf -v FOOTER "$FOOTER_TEMPLATE" "$COMMAND_PREFIX"

          if [[ "${{ steps.probe.outcome }}" == "success" ]]; then
            if [[ -n "${RESPONSE_CONTENT// }" ]]; then
              FINAL_BODY="${RESPONSE_CONTENT}${FOOTER}"
            else
              FINAL_BODY="ðŸ¤– Processing succeeded, AI response empty.${FOOTER}"
            fi
          else
            ERROR_MESSAGE="ðŸ¤– **Error:** AI interaction failed."
            if [[ "${{ steps.format.outcome }}" == "failure" ]] || [[ "${{ steps.read_prompt_file.outcome }}" == "failure" ]]; then
              ERROR_MESSAGE="ðŸ¤– **Error:** Failed during context/prompt prep. Check logs."
            elif [[ -n "${RESPONSE_CONTENT// }" ]] && echo "$RESPONSE_CONTENT" | grep -q "ðŸ¤– **Error:**"; then
              ERROR_MESSAGE="${RESPONSE_CONTENT}"
            elif [[ -n "${ERROR_LOG_CONTENT// }" ]]; then
              ERROR_DETAILS=$(head -c 1000 <<< "$ERROR_LOG_CONTENT")
              if [[ ${#ERROR_LOG_CONTENT} -gt 1000 ]]; then
                ERROR_DETAILS="${ERROR_DETAILS}\n...(truncated)"
              fi
              ERROR_MESSAGE="${ERROR_MESSAGE}\n\n**Details (stderr):**\n\`\`\`\n${ERROR_DETAILS}\n\`\`\`"
            else
              ERROR_MESSAGE="${ERROR_MESSAGE} No details. Check 'Run probe-chat' logs (outcome: ${{ steps.probe.outcome }})."
            fi
            FINAL_BODY="${ERROR_MESSAGE}${FOOTER}"
          fi

          echo "Final response body prep'd. Length: ${#FINAL_BODY}"
          {
            echo "response<<EOF_RESPONSE_MARKER"
            echo "$FINAL_BODY"
            echo "EOF_RESPONSE_MARKER"
          } >> "$GITHUB_OUTPUT"

  post_response:
    if: needs.process_comment.result != 'skipped'
    runs-on: ubuntu-latest
    needs: [process_comment]
    steps:
      - name: Post Response Comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          issue-number: ${{ needs.process_comment.outputs.issue_number }}
          body: ${{ needs.process_comment.outputs.response_body }}
          reactions: ${{ needs.process_comment.outputs.probe_succeeded == 'true' && '+1' || '-1' }}

# </gh>
