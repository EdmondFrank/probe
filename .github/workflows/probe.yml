# <gh>
name: Probe chat Github Action

on:
  workflow_call:
    inputs:
      command_prefix:
        description: "The prefix required on comments to trigger the AI (e.g., /probe, /ai, etc)"
        default: "/probe"
        required: true
        type: string
      default_probe_chat_command:
        description: "The default probe-chat command if PROBE_CHAT_COMMAND secret is not set"
        required: false
        default: "npx -y @buger/probe-chat@latest"
        type: string
      # Note: The actual probe-chat command to run will prioritize the PROBE_CHAT_COMMAND secret
      # passed by the caller via "secrets: inherit", then fall back to inputs.default_probe_chat_command.

# Permissions required by the jobs within THIS reusable workflow
permissions:
  pull-requests: write
  issues: write
  contents: read
  # reactions: write # Usually covered by issues/pull-requests write

jobs:
  process_comment:
    if: startsWith(github.event.comment.body, inputs.command_prefix)
    runs-on: ubuntu-latest
    outputs:
      response_body: ${{ steps.read_response.outputs.response }}
      issue_number: ${{ steps.set_issue_number.outputs.issue_number }}
      probe_succeeded: ${{ steps.probe.outcome == 'success' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install jq (if needed) and Verify gh
        run: |
          sudo apt-get update && sudo apt-get install -y jq --no-install-recommends
          gh --version

      - name: Set Issue Number Output
        id: set_issue_number
        run: echo "issue_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT

      - name: Add 'eyes' reaction to comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMENT_URL: ${{ github.event.comment.html_url }}
        run: |
          echo "Adding ðŸ‘€ reaction to ${COMMENT_URL}"
          gh reaction add --content eyes "${COMMENT_URL}" || echo "::warning::Failed to add reaction to comment. Continuing..."

      - name: Determine Context and Format Input
        id: format
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
        run: |
          shopt -s extglob
          set -e
          # set -x

          ISSUE_OR_PR_NUMBER=${{ github.event.issue.number }}
          RAW_COMMENT_BODY="${{ github.event.comment.body }}"

          # Extract user request
          USER_REQUEST_BODY="${RAW_COMMENT_BODY#${COMMAND_PREFIX}}"
          USER_REQUEST_BODY="${USER_REQUEST_BODY##*( )}"
          USER_REQUEST_BODY="${USER_REQUEST_BODY%%*( )}"
          echo "User request extracted: [${USER_REQUEST_BODY}]"

          # Determine context type
          CONTEXT_TYPE="issue"
          if gh api "repos/${{ github.repository }}/issues/$ISSUE_OR_PR_NUMBER" --jq '.pull_request' | grep -q 'url'; then
             CONTEXT_TYPE="pr"
          fi
          echo "Context type: $CONTEXT_TYPE"

          # --- Fetch Common Data: Comments ---
          echo "Fetching comments for $CONTEXT_TYPE #$ISSUE_OR_PR_NUMBER..."
          COMMENTS_JSON=$(gh api -H "Accept: application/vnd.github+json" /repos/${{ github.repository }}/issues/$ISSUE_OR_PR_NUMBER/comments --jq '.' || echo "[]")
          COMMENTS_XML=""
          echo "$COMMENTS_JSON" | jq -c '.[] | {login: .user.login, created_at: .created_at, body: .body}' | while IFS= read -r comment_json; do
            login=$(echo "$comment_json" | jq -r .login | sed -e 's/&/\&/g' -e 's/</\</g' -e 's/>/\>/g' -e 's/"/\"/g' -e "s/'/\'/g")
            created_at=$(echo "$comment_json" | jq -r .created_at)
            # Escape comment body - crucially includes single quotes
            body=$(echo "$comment_json" | jq -r .body | sed -e 's/&/\&/g' -e 's/</\</g' -e 's/>/\>/g' -e 's/"/\"/g' -e "s/'/\'/g")
            COMMENTS_XML="${COMMENTS_XML}<comment><author>$login</author><timestamp>$created_at</timestamp><content>$body</content></comment>"
          done || { echo "Error processing comments JSON."; exit 1; }
          echo "Comments fetched. XML length: ${#COMMENTS_XML}"

          # --- Fetch Context-Specific Data & Build XML ---
          CONTEXT_DETAILS_XML=""
          DIFF_XML=""
          PROMPT_INSTRUCTION=""

          if [[ "$CONTEXT_TYPE" == "pr" ]]; then
            echo "Fetching PR details and diff..."
            PR_DATA=$(gh pr view $ISSUE_OR_PR_NUMBER --json title,body --repo ${{ github.repository }} || echo '{"title": "Error fetching PR title", "body": "Error fetching PR body"}')
            # Escape title and body
            PR_TITLE=$(echo "$PR_DATA" | jq -r .title | sed -e 's/&/\&/g' -e 's/</\</g' -e 's/>/\>/g' -e 's/"/\"/g' -e "s/'/\'/g")
            PR_BODY=$(echo "$PR_DATA" | jq -r .body | sed -e 's/&/\&/g' -e 's/</\</g' -e 's/>/\>/g' -e 's/"/\"/g' -e "s/'/\'/g")
            # Fetch diff - no need to XML escape if using CDATA
            PR_DIFF=$(gh pr diff $ISSUE_OR_PR_NUMBER --repo ${{ github.repository }} 2>/dev/null || echo "<!-- Error fetching diff -->")

            CONTEXT_DETAILS_XML="<details><title>$PR_TITLE</title><body>$PR_BODY</body></details>"
            DIFF_XML="<diff><![CDATA[$PR_DIFF]]></diff>" # Use CDATA

            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Pull Request. Based *only* on the information provided within the <github_context> XML structure (including PR details, comments, and the code diff), please provide a concise and helpful response to the <user_request>. Focus on aspects relevant to code review, understanding the changes, or summarizing the PR's intent and impact based *solely* on the provided context."

            echo "PR details fetched. Title length: ${#PR_TITLE}, Body length: ${#PR_BODY}"
            echo "Diff fetched. Diff length: ${#PR_DIFF}"

          elif [[ "$CONTEXT_TYPE" == "issue" ]]; then
            echo "Fetching Issue details..."
            ISSUE_DATA=$(gh issue view $ISSUE_OR_PR_NUMBER --json title,body --repo ${{ github.repository }} || echo '{"title": "Error fetching Issue title", "body": "Error fetching Issue body"}')
            # Escape title and body
            ISSUE_TITLE=$(echo "$ISSUE_DATA" | jq -r .title | sed -e 's/&/\&/g' -e 's/</\</g' -e 's/>/\>/g' -e 's/"/\"/g' -e "s/'/\'/g")
            ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r .body | sed -e 's/&/\&/g' -e 's/</\</g' -e 's/>/\>/g' -e 's/"/\"/g' -e "s/'/\'/g")

            CONTEXT_DETAILS_XML="<details><title>$ISSUE_TITLE</title><body>$ISSUE_BODY</body></details>"
            DIFF_XML=""

            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Issue. Based *only* on the information provided within the <github_context> XML structure (including issue details and comments), please provide a concise and helpful response to the <user_request>. Aim to summarize the issue, clarify points, suggest potential next steps, or answer questions based *solely* on the provided context. If asked for solutions, propose actionable ideas grounded in the issue's description and discussion."

            echo "Issue details fetched. Title length: ${#ISSUE_TITLE}, Body length: ${#ISSUE_BODY}"
          fi

          # --- Assemble Final Prompt ---
          echo "Assembling final prompt..."
          # Ensure User Request is also wrapped in CDATA for robustness
          FORMATTED_PROMPT="<github_context type=\"$CONTEXT_TYPE\" number=\"$ISSUE_OR_PR_NUMBER\">
            ${CONTEXT_DETAILS_XML}
            ${DIFF_XML}
            <comments>
            ${COMMENTS_XML}
            </comments>
            <user_request><![CDATA[${USER_REQUEST_BODY}]]></user_request>
            </github_context>

            ${PROMPT_INSTRUCTION}"

          if [ -z "$FORMATTED_PROMPT" ]; then
             echo "::error::Formatted prompt became empty after assembly. Check variable contents."
             exit 1
          fi
          echo "Final prompt assembled successfully. Length: ${#FORMATTED_PROMPT}"

          # Output the potentially large prompt securely using delimiters
          echo "formatted_prompt<<EOF_PROMPT_MARKER" >> $GITHUB_OUTPUT
          echo "$FORMATTED_PROMPT" >> $GITHUB_OUTPUT
          echo "EOF_PROMPT_MARKER" >> $GITHUB_OUTPUT
          echo "Formatted prompt output set."

      - name: Determine probe-chat Command
        id: determine_command
        run: |
          CMD="${{ secrets.PROBE_CHAT_COMMAND }}"
          if [[ -z "$CMD" ]]; then
            CMD="${{ inputs.default_probe_chat_command }}"
            echo "Using default probe-chat command."
          else
            echo "Using probe-chat command from PROBE_CHAT_COMMAND secret."
          fi
          echo "Final command: $CMD"
          echo "command=$CMD" >> $GITHUB_OUTPUT

      - name: Run probe-chat
        id: probe
        shell: bash
        env:
          # --- MODIFICATION START ---
          # Pass the formatted prompt as an environment variable
          PROBE_PROMPT: ${{ steps.format.outputs.formatted_prompt }}
          # --- MODIFICATION END ---

          # Map the inherited secrets
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          ANTHROPIC_API_URL: ${{ secrets.ANTHROPIC_API_URL }}
          OPENAI_API_URL: ${{ secrets.OPENAI_API_URL }}
          GOOGLE_API_URL: ${{ secrets.GOOGLE_API_URL }}
          LLM_BASE_URL: ${{ secrets.LLM_BASE_URL }}
          MODEL_NAME: ${{ secrets.MODEL_NAME }}
          FORCE_PROVIDER: ${{ secrets.FORCE_PROVIDER }}
        run: |
          set -e
          set -o pipefail

          # --- MODIFICATION START ---
          # Read the prompt from the environment variable
          # Use double quotes to preserve newlines and special chars correctly within the variable
          PROMPT="$PROBE_PROMPT"
          # --- MODIFICATION END ---

          # The command itself is usually simple enough for direct substitution
          COMMAND_TO_RUN='${{ steps.determine_command.outputs.command }}'
          RESPONSE_FILE="response.txt"
          ERROR_LOG="error.log"
          > "$RESPONSE_FILE"
          > "$ERROR_LOG"

          # Add a check in case the prompt environment variable is somehow empty
          if [ -z "$PROMPT" ]; then
            echo "::error::Prompt environment variable (PROBE_PROMPT) is empty. Cannot run probe-chat."
            echo "ðŸ¤– **Error:** Failed to prepare the AI prompt content." > "$RESPONSE_FILE"
            # Exit with non-zero code to ensure the step outcome reflects failure
            # This will be caught by the `if: always()` in the next step
            exit 1
          fi

          echo "Running probe-chat..."
          echo "--- Start AI Prompt (first 500 chars) ---"
          # Use printf for safer handling of potential % characters in the prompt snippet
          printf "%.500s...\n" "$PROMPT"
          echo "--- End AI Prompt Snippet ---"
          echo "Command to run: $COMMAND_TO_RUN"
          EXIT_CODE=0

          # Pipe the prompt (read from the variable) to the command
          echo "$PROMPT" | $COMMAND_TO_RUN > "$RESPONSE_FILE" 2> "$ERROR_LOG" || EXIT_CODE=$?

          if [ $EXIT_CODE -ne 0 ]; then
            echo "::error::probe-chat command failed with exit code $EXIT_CODE."
            echo "Stderr output from probe-chat:"
            cat "$ERROR_LOG"
            # Format error response for GitHub comment
            echo "ðŸ¤– **Error:** The AI command failed (exit code $EXIT_CODE)." > "$RESPONSE_FILE"
            echo "" >> "$RESPONSE_FILE"
            echo "**Details:**" >> "$RESPONSE_FILE"
            echo '```' >> "$RESPONSE_FILE"
            # Ensure cat doesn't fail if error log is empty
            cat "$ERROR_LOG" 2>/dev/null || echo "(No stderr output captured)" >> "$RESPONSE_FILE"
            echo '```' >> "$RESPONSE_FILE"
            echo "" >> "$RESPONSE_FILE"
            echo "> Check the Action logs for the full prompt and details." >> "$RESPONSE_FILE"
            # Do not exit 1 here, let the workflow continue to post the error
          else
            echo "probe-chat command finished successfully."
          fi

      - name: Read Response or Error
        if: always() # Run even if 'probe' fails to capture the error message
        id: read_response
        run: |
          RESPONSE=$(cat response.txt 2>/dev/null || echo "")
          # Add prefix to successful AI responses only if probe step succeeded
          if [[ "${{ steps.probe.outcome }}" == "success" ]] && [[ -n "${RESPONSE// }" ]]; then
             RESPONSE="ðŸ¤– AI Response:\n\n${RESPONSE}"
          # If response is empty, check outcomes of previous steps
          elif [[ -z "${RESPONSE// }" ]]; then
             if [[ "${{ steps.probe.outcome }}" == "failure" ]]; then
                # Use the already formatted error message from response.txt if probe failed but wrote to it
                # If response.txt is STILL empty even after probe failed, use a generic message.
                if [[ -s response.txt ]]; then
                    RESPONSE=$(cat response.txt) # Use the error message generated in the probe step
                else
                    RESPONSE="ðŸ¤– Processing failed: AI command execution error (exit code ${{ steps.probe.outputs.exit_code || 'unknown' }}). Check Action logs."
                fi
             elif [[ "${{ steps.format.outcome }}" == "failure" ]]; then
                RESPONSE="ðŸ¤– Processing failed: Error during context preparation. Check Action logs."
             else
                # Probe succeeded but produced no output
                RESPONSE="ðŸ¤– Processing finished, but no response was generated by the AI."
             fi
          # If probe failed but produced an error message in response.txt, RESPONSE is already set
          # No need for an extra 'elif' here for that case.
          fi
          echo "Response content prepared for output."
          # Use multi-line output handling
          echo "response<<EOF_RESPONSE_MARKER" >> $GITHUB_OUTPUT
          echo "$RESPONSE" >> $GITHUB_OUTPUT
          echo "EOF_RESPONSE_MARKER" >> $GITHUB_OUTPUT

  # Job 2: Post the response back to GitHub
  post_response:
    if: needs.process_comment.result != 'skipped'
    runs-on: ubuntu-latest
    needs: [process_comment]
    steps:
      - name: Post Response Comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          issue-number: ${{ needs.process_comment.outputs.issue_number }}
          body: ${{ needs.process_comment.outputs.response_body }}
# </gh>
