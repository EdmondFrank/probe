# <gh>
name: Probe chat Github Action

on:
  workflow_call:
    inputs:
      command_prefix:
        description: "The prefix required on comments to trigger the AI (e.g., /probe, /ai, etc)"
        default: "/probe"
        required: true
        type: string
      default_probe_chat_command:
        description: "The default probe-chat command if PROBE_CHAT_COMMAND secret is not set"
        required: false
        default: "npx -y @buger/probe-chat@latest"
        type: string
      # Note: The actual probe-chat command to run will prioritize the PROBE_CHAT_COMMAND secret
      # passed by the caller via "secrets: inherit", then fall back to inputs.default_probe_chat_command.

# Permissions required by the jobs within THIS reusable workflow
permissions:
  pull-requests: write
  issues: write
  contents: read
  # reactions: write # Required for gh api reaction POST

jobs:
  process_comment:
    if: startsWith(github.event.comment.body, inputs.command_prefix)
    runs-on: ubuntu-latest
    outputs:
      response_body: ${{ steps.read_response.outputs.response }}
      issue_number: ${{ steps.set_issue_number.outputs.issue_number }}
      probe_succeeded: ${{ steps.probe.outcome == 'success' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install jq (if needed) and Verify gh
        run: |
          sudo apt-get update && sudo apt-get install -y jq --no-install-recommends
          gh --version

      - name: Set Issue Number and Comment ID Output
        id: set_context_ids
        run: |
          echo "issue_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          echo "comment_id=${{ github.event.comment.id }}" >> $GITHUB_OUTPUT

      # --- MODIFIED: Add reaction using gh api ---
      - name: Add 'eyes' reaction to comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          COMMENT_ID: ${{ steps.set_context_ids.outputs.comment_id }}
        run: |
          echo "Adding ðŸ‘€ reaction to comment ID ${COMMENT_ID} in repo ${REPO}"
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            "/repos/${REPO}/issues/comments/${COMMENT_ID}/reactions" \
            -f content='eyes' \
            --silent || echo "::warning::Failed to add reaction to comment ${COMMENT_ID}. Continuing..."
          # Using --silent to suppress success output, || catches errors

      - name: Determine Context and Format Input
        id: format
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
        run: |
          shopt -s extglob
          set -e
          # set -x

          ISSUE_OR_PR_NUMBER=${{ steps.set_context_ids.outputs.issue_number }} # Use output from previous step
          RAW_COMMENT_BODY="${{ github.event.comment.body }}"

          # Extract user request - escape basic XML entities
          USER_REQUEST_BODY_RAW="${RAW_COMMENT_BODY#${COMMAND_PREFIX}}"
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW##*( )}"
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW%%*( )}"
          USER_REQUEST_BODY=$(echo "$USER_REQUEST_BODY_RAW" | sed -e 's/&/\&/g' -e 's/</\</g' -e 's/>/\>/g' -e 's/"/\"/g' -e "s/'/\'/g")
          echo "User request extracted and escaped: [${USER_REQUEST_BODY:0:100}...]" # Log snippet

          # Determine context type
          CONTEXT_TYPE="issue"
          # Use --silent on gh api call to avoid polluting logs if check fails
          if gh api "repos/${{ github.repository }}/issues/$ISSUE_OR_PR_NUMBER" --jq '.pull_request' --silent 2>/dev/null | grep -q 'url'; then
             CONTEXT_TYPE="pr"
          fi
          echo "Context type: $CONTEXT_TYPE"

          # --- Fetch Common Data: Comments ---
          echo "Fetching comments for $CONTEXT_TYPE #$ISSUE_OR_PR_NUMBER..."
          COMMENTS_JSON=$(gh api -H "Accept: application/vnd.github+json" /repos/${{ github.repository }}/issues/$ISSUE_OR_PR_NUMBER/comments --jq '.' || echo "[]")
          COMMENTS_XML=""
          echo "$COMMENTS_JSON" | jq -c '.[] | {login: .user.login, created_at: .created_at, body: .body}' | while IFS= read -r comment_json; do
            login=$(echo "$comment_json" | jq -r .login | sed -e 's/&/\&/g' -e 's/</\</g' -e 's/>/\>/g' -e 's/"/\"/g' -e "s/'/\'/g")
            created_at=$(echo "$comment_json" | jq -r .created_at)
            body=$(echo "$comment_json" | jq -r .body | sed -e 's/&/\&/g' -e 's/</\</g' -e 's/>/\>/g' -e 's/"/\"/g' -e "s/'/\'/g") # Basic XML escaping
            COMMENTS_XML="${COMMENTS_XML}<comment><author>$login</author><timestamp>$created_at</timestamp><content>$body</content></comment>"
          done || { echo "Error processing comments JSON."; exit 1; }
          echo "Comments fetched. XML length: ${#COMMENTS_XML}"

          # --- Fetch Context-Specific Data & Build XML ---
          CONTEXT_DETAILS_XML=""
          DIFF_XML=""
          PROMPT_INSTRUCTION="" # Will be set based on context type below

          if [[ "$CONTEXT_TYPE" == "pr" ]]; then
            echo "Fetching PR details and diff..."
            PR_DATA=$(gh pr view $ISSUE_OR_PR_NUMBER --json title,body --repo ${{ github.repository }} || echo '{"title": "Error fetching PR title", "body": "Error fetching PR body"}')
            PR_TITLE=$(echo "$PR_DATA" | jq -r .title | sed -e 's/&/\&/g' -e 's/</\</g' -e 's/>/\>/g' -e 's/"/\"/g' -e "s/'/\'/g")
            PR_BODY=$(echo "$PR_DATA" | jq -r .body | sed -e 's/&/\&/g' -e 's/</\</g' -e 's/>/\>/g' -e 's/"/\"/g' -e "s/'/\'/g")
            # Fetch diff - NO CDATA, raw diff
            PR_DIFF=$(gh pr diff $ISSUE_OR_PR_NUMBER --repo ${{ github.repository }} 2>/dev/null || echo "<!-- Error fetching diff -->")

            CONTEXT_DETAILS_XML="<details><title>$PR_TITLE</title><body>$PR_BODY</body></details>"
            DIFF_XML="<diff>$PR_DIFF</diff>" # No CDATA

            # --- MODIFIED PR PROMPT (Less Restrictive) ---
            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Pull Request. Use the information provided within the <github_context> XML structure (including PR details, comments, and the code diff) as the primary source to understand the request. Provide a concise and helpful response to the <user_request>. You may leverage your general knowledge or other capabilities where appropriate to enhance the response, focusing on code review, understanding changes, or summarizing intent and impact."

            echo "PR details fetched. Title length: ${#PR_TITLE}, Body length: ${#PR_BODY}"
            echo "Diff fetched. Diff length: ${#PR_DIFF}"

          elif [[ "$CONTEXT_TYPE" == "issue" ]]; then
            echo "Fetching Issue details..."
            ISSUE_DATA=$(gh issue view $ISSUE_OR_PR_NUMBER --json title,body --repo ${{ github.repository }} || echo '{"title": "Error fetching Issue title", "body": "Error fetching Issue body"}')
            ISSUE_TITLE=$(echo "$ISSUE_DATA" | jq -r .title | sed -e 's/&/\&/g' -e 's/</\</g' -e 's/>/\>/g' -e 's/"/\"/g' -e "s/'/\'/g")
            ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r .body | sed -e 's/&/\&/g' -e 's/</\</g' -e 's/>/\>/g' -e 's/"/\"/g' -e "s/'/\'/g")

            CONTEXT_DETAILS_XML="<details><title>$ISSUE_TITLE</title><body>$ISSUE_BODY</body></details>"
            DIFF_XML="" # No diff for issues

            # --- MODIFIED ISSUE PROMPT (Less Restrictive) ---
            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Issue. Use the information provided within the <github_context> XML structure (including issue details and comments) as the primary source to understand the request. Provide a concise and helpful response to the <user_request>. You may leverage your general knowledge or other capabilities where appropriate to enhance the response, aiming to summarize the issue, clarify points, suggest potential next steps, or answer questions. If asked for solutions, propose actionable ideas informed by the issue's description and discussion."

            echo "Issue details fetched. Title length: ${#ISSUE_TITLE}, Body length: ${#ISSUE_BODY}"
          fi

          # --- Assemble Final Prompt ---
          echo "Assembling final prompt..."
          # Construct the prompt string directly
          FORMATTED_PROMPT="<github_context type=\"$CONTEXT_TYPE\" number=\"$ISSUE_OR_PR_NUMBER\">
            ${CONTEXT_DETAILS_XML}
            ${DIFF_XML}
            <comments>
            ${COMMENTS_XML}
            </comments>
            <user_request>${USER_REQUEST_BODY}</user_request>
            </github_context>

            ${PROMPT_INSTRUCTION}" # Note: User request is now directly embedded, not CDATA

          if [ -z "$FORMATTED_PROMPT" ]; then
             echo "::error::Formatted prompt became empty after assembly. Check variable contents."
             exit 1
          fi
          echo "Final prompt assembled successfully. Length: ${#FORMATTED_PROMPT}"

          # Output the potentially large prompt securely using delimiters
          echo "formatted_prompt<<EOF_PROMPT_MARKER" >> $GITHUB_OUTPUT
          echo "$FORMATTED_PROMPT" >> $GITHUB_OUTPUT
          echo "EOF_PROMPT_MARKER" >> $GITHUB_OUTPUT
          echo "Formatted prompt output set."

      - name: Determine probe-chat Command
        id: determine_command
        run: |
          CMD="${{ secrets.PROBE_CHAT_COMMAND }}"
          if [[ -z "$CMD" ]]; then
            CMD="${{ inputs.default_probe_chat_command }}"
            echo "Using default probe-chat command."
          else
            echo "Using probe-chat command from PROBE_CHAT_COMMAND secret."
          fi
          echo "Final command: $CMD"
          echo "command=$CMD" >> $GITHUB_OUTPUT

      - name: Run probe-chat
        id: probe
        shell: bash
        env:
          PROBE_PROMPT: ${{ steps.format.outputs.formatted_prompt }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          ANTHROPIC_API_URL: ${{ secrets.ANTHROPIC_API_URL }}
          OPENAI_API_URL: ${{ secrets.OPENAI_API_URL }}
          GOOGLE_API_URL: ${{ secrets.GOOGLE_API_URL }}
          LLM_BASE_URL: ${{ secrets.LLM_BASE_URL }}
          MODEL_NAME: ${{ secrets.MODEL_NAME }}
          FORCE_PROVIDER: ${{ secrets.FORCE_PROVIDER }}
        run: |
          set -e
          set -o pipefail
          PROMPT="$PROBE_PROMPT"
          COMMAND_TO_RUN='${{ steps.determine_command.outputs.command }}'
          RESPONSE_FILE="response.txt"
          ERROR_LOG="error.log"
          > "$RESPONSE_FILE"
          > "$ERROR_LOG"

          if [ -z "$PROMPT" ]; then
            echo "::error::Prompt environment variable (PROBE_PROMPT) is empty. Cannot run probe-chat."
            echo "ðŸ¤– **Error:** Failed to prepare the AI prompt content." > "$RESPONSE_FILE"
            exit 1 # Fail the step explicitly
          fi

          echo "Running probe-chat..."
          echo "--- Start AI Prompt (first 500 chars) ---"
          printf "%.500s...\n" "$PROMPT"
          echo "--- End AI Prompt Snippet ---"
          echo "Command to run: $COMMAND_TO_RUN"
          EXIT_CODE=0

          echo "$PROMPT" | $COMMAND_TO_RUN > "$RESPONSE_FILE" 2> "$ERROR_LOG" || EXIT_CODE=$?

          if [ $EXIT_CODE -ne 0 ]; then
            echo "::error::probe-chat command failed with exit code $EXIT_CODE."
            echo "Stderr output from probe-chat:"
            cat "$ERROR_LOG"
            # Format error response for GitHub comment - keep prefix for errors
            echo "ðŸ¤– **Error:** The AI command failed (exit code $EXIT_CODE)." > "$RESPONSE_FILE"
            echo "" >> "$RESPONSE_FILE"
            echo "**Details:**" >> "$RESPONSE_FILE"
            echo '```' >> "$RESPONSE_FILE"
            cat "$ERROR_LOG" 2>/dev/null || echo "(No stderr output captured)" >> "$RESPONSE_FILE"
            echo '```' >> "$RESPONSE_FILE"
            echo "" >> "$RESPONSE_FILE"
            echo "> Check the Action logs for the full prompt and details." >> "$RESPONSE_FILE"
          else
            echo "probe-chat command finished successfully."
          fi

      # --- MODIFIED: Read Response/Error and add Footer ---
      - name: Read Response or Error and Format Output
        if: always()
        id: read_response
        env:
          COMMAND_PREFIX: ${{ inputs.command_prefix }} # Make prefix available here
        run: |
          RESPONSE_CONTENT=$(cat response.txt 2>/dev/null || echo "")
          FINAL_BODY=""

          # Define the footer - Use printf for reliable newline handling
          FOOTER=$(printf "\n\n-----\n*Tip: Start your comment with \`%s <your request>\` to trigger the AI.*\n*Built by [probe](https://probeai.dev)*" "$COMMAND_PREFIX")

          # Check outcomes and determine main body
          if [[ "${{ steps.probe.outcome }}" == "success" ]] && [[ -n "${RESPONSE_CONTENT// }" ]]; then
             # Successful AI response - no prefix, just content
             FINAL_BODY="${RESPONSE_CONTENT}${FOOTER}"
          elif [[ -z "${RESPONSE_CONTENT// }" ]]; then
             # Response file is empty, determine why
             if [[ "${{ steps.probe.outcome }}" == "failure" ]]; then
                FINAL_BODY="ðŸ¤– Processing failed: AI command execution error (exit code ${{ steps.probe.outputs.exit_code || 'unknown' }}). Check Action logs.${FOOTER}"
             elif [[ "${{ steps.format.outcome }}" == "failure" ]]; then
                FINAL_BODY="ðŸ¤– Processing failed: Error during context preparation. Check Action logs.${FOOTER}"
             else
                # Probe succeeded but produced no output
                FINAL_BODY="ðŸ¤– Processing finished, but no response was generated by the AI.${FOOTER}"
             fi
          else
             # Probe failed, but response.txt likely contains the formatted error message from the previous step
             # Append the footer to the existing error message
             FINAL_BODY="${RESPONSE_CONTENT}${FOOTER}"
          fi

          echo "Final response body prepared for output."
          # Use multi-line output handling
          echo "response<<EOF_RESPONSE_MARKER" >> $GITHUB_OUTPUT
          echo "$FINAL_BODY" >> $GITHUB_OUTPUT
          echo "EOF_RESPONSE_MARKER" >> $GITHUB_OUTPUT

  # Job 2: Post the response back to GitHub (no changes needed here)
  post_response:
    if: needs.process_comment.result != 'skipped'
    runs-on: ubuntu-latest
    needs: [process_comment]
    steps:
      - name: Post Response Comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          issue-number: ${{ needs.process_comment.outputs.issue_number }} # Use the correct output name
          body: ${{ needs.process_comment.outputs.response_body }}
# </gh>
