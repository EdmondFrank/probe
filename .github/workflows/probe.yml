# <gh>
name: Probe chat Github Action

on:
  workflow_call:
    inputs:
      command_prefix:
        description: "The prefix required on comments to trigger the AI (e.g., /probe, /ai, etc)"
        default: "/probe"
        required: true
        type: string
      default_probe_chat_command:
        description: "The default probe-chat command if PROBE_CHAT_COMMAND secret is not set"
        required: false
        default: "npx -y @buger/probe-chat@latest"
        type: string
      # Note: The actual probe-chat command to run will prioritize the PROBE_CHAT_COMMAND secret
      # passed by the caller via "secrets: inherit", then fall back to inputs.default_probe_chat_command.

# Permissions required by the jobs within THIS reusable workflow
permissions:
  pull-requests: write # Needed for reading PR data/comments/reviews, posting comments, adding reactions
  issues: write        # Needed for reading issue data/comments, posting comments, adding reactions
  contents: read

jobs:
  process_comment:
    # Run only if the comment starts with the specified prefix
    if: startsWith(github.event.comment.body, inputs.command_prefix)
    runs-on: ubuntu-latest
    outputs:
      response_body: ${{ steps.read_response.outputs.response }}
      issue_number: ${{ steps.set_context_ids.outputs.issue_number }}
      probe_succeeded: ${{ steps.probe.outcome == 'success' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install jq (if needed) and Verify gh
        run: |
          sudo apt-get update && sudo apt-get install -y jq --no-install-recommends
          gh --version

      - name: Set Issue Number and Comment ID Output
        id: set_context_ids
        run: |
          # Use issue.number which is present for both issue_comment and pull_request_review_comment events
          echo "issue_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          echo "comment_id=${{ github.event.comment.id }}" >> $GITHUB_OUTPUT

      - name: Add 'eyes' reaction to comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          COMMENT_ID: ${{ steps.set_context_ids.outputs.comment_id }}
        run: |
          echo "Adding ðŸ‘€ reaction to comment ID ${COMMENT_ID} in repo ${REPO}"
          # Use issues API endpoint for comments as it works for both PRs and Issues
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            "/repos/${REPO}/issues/comments/${COMMENT_ID}/reactions" \
            -f content='eyes' \
            --silent || echo "::warning::Failed to add reaction to comment ${COMMENT_ID}. Continuing..."

      # --- MODIFIED: Determine Context, Fetch ALL Comments, Format Input ---
      - name: Determine Context, Fetch Comments, Format Input
        id: format
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
          REPO: ${{ github.repository }}
        run: |
          shopt -s extglob # Enable extended globbing for string trimming
          set -e           # Exit on error
          # set -x         # Uncomment for deep debugging

          ISSUE_OR_PR_NUMBER=${{ steps.set_context_ids.outputs.issue_number }}
          RAW_COMMENT_BODY="${{ github.event.comment.body }}"
          GITHUB_API_ARGS=(-H "Accept: application/vnd.github+json" --silent) # Common args for gh api

          # Basic XML escaping function (ampersand first!)
          escape_xml() {
            sed -e 's/&/\&/g' \
                -e 's/</\</g' \
                -e 's/>/\>/g' \
                -e 's/"/\"/g' \
                -e "s/'/\'/g"
          }

          # Extract user request, trim prefix and whitespace
          USER_REQUEST_BODY_RAW="${RAW_COMMENT_BODY#${COMMAND_PREFIX}}"
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW##*( )}" # Trim leading whitespace
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW%%*( )}" # Trim trailing whitespace
          USER_REQUEST_BODY=$(echo "$USER_REQUEST_BODY_RAW" | escape_xml)
          echo "User request extracted and escaped: [${USER_REQUEST_BODY:0:100}...]"

          # Determine context type: check if it's a pull request
          CONTEXT_TYPE="issue"
          if gh api "${GITHUB_API_ARGS[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER" --jq .url > /dev/null 2>&1; then
             CONTEXT_TYPE="pr"
          fi
          echo "Context type: $CONTEXT_TYPE"

          # --- Fetch ALL Comments ---
          # Initialize variable in the current shell
          COMMENTS_XML=""

          # 1. Fetch regular issue/PR comments
          echo "Fetching standard comments for $CONTEXT_TYPE #$ISSUE_OR_PR_NUMBER..."
          # Use process substitution < <(...) to avoid subshell issues with the while loop
          while IFS= read -r comment_json; do
              login=$(echo "$comment_json" | jq -r .login | escape_xml)
              created_at=$(echo "$comment_json" | jq -r .created_at)
              body=$(echo "$comment_json" | jq -r .body | escape_xml)
              # Append to the variable in the current shell
              COMMENTS_XML="${COMMENTS_XML}<comment type=\"issue\"><author>$login</author><timestamp>$created_at</timestamp><content>$body</content></comment>"
              echo "  Processed standard comment by $login" # Debug log
          done < <(gh api "${GITHUB_API_ARGS[@]}" "/repos/${REPO}/issues/$ISSUE_OR_PR_NUMBER/comments" --paginate --jq '.[] | {login: .user.login, created_at: .created_at, body: .body}' 2>/dev/null || { echo "::warning::Failed to fetch or process standard comments."; echo "[]"; }) # Add --paginate, handle potential errors


          # --- Fetch Context-Specific Data & Build XML ---
          CONTEXT_DETAILS_XML=""
          DIFF_XML=""
          PROMPT_INSTRUCTION=""

          if [[ "$CONTEXT_TYPE" == "pr" ]]; then
            echo "Fetching PR details and diff..."
            # Fetch PR details using gh cli
            PR_DATA=$(gh pr view $ISSUE_OR_PR_NUMBER --json title,body --repo ${REPO} 2>/dev/null || echo '{"title": "Error fetching PR title", "body": "Error fetching PR body"}')
            PR_TITLE=$(echo "$PR_DATA" | jq -r .title | escape_xml)
            PR_BODY=$(echo "$PR_DATA" | jq -r .body | escape_xml)
            # Fetch PR diff using gh cli
            PR_DIFF=$(gh pr diff $ISSUE_OR_PR_NUMBER --repo ${REPO} 2>/dev/null || echo "<!-- Error fetching diff -->")
            # Escape the diff content for XML safety, especially if it contains <, >, &
            ESCAPED_PR_DIFF=$(echo "$PR_DIFF" | escape_xml)

            CONTEXT_DETAILS_XML="<details><title>$PR_TITLE</title><body>$PR_BODY</body></details>"
            # Use the escaped diff
            DIFF_XML="<diff>$ESCAPED_PR_DIFF</diff>"

            # 2. Fetch PR review comments (comments on the diff)
            echo "Fetching PR review comments (diff comments)..."
            # Use process substitution < <(...)
            while IFS= read -r comment_json; do
                login=$(echo "$comment_json" | jq -r .login | escape_xml)
                created_at=$(echo "$comment_json" | jq -r .created_at)
                body=$(echo "$comment_json" | jq -r .body | escape_xml)
                path=$(echo "$comment_json" | jq -r .path | escape_xml)
                # Use diff_hunk for better context if available, otherwise body
                diff_hunk=$(echo "$comment_json" | jq -r .diff_hunk | escape_xml)
                line=$(echo "$comment_json" | jq -r .line // .original_line) # Prefer line, fallback to original_line
                COMMENTS_XML="${COMMENTS_XML}<comment type=\"review_comment\" file=\"$path\" line=\"$line\"><author>$login</author><timestamp>$created_at</timestamp><diff_hunk>$diff_hunk</diff_hunk><content>$body</content></comment>"
                echo "  Processed review comment by $login on $path:$line" # Debug log
            done < <(gh api "${GITHUB_API_ARGS[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER/comments" --paginate --jq '.[] | {login: .user.login, created_at: .created_at, body: .body, path: .path, line: .line, original_line: .original_line, diff_hunk: .diff_hunk}' 2>/dev/null || { echo "::warning::Failed to fetch or process review comments."; echo "[]"; })

            # 3. Fetch PR reviews (overall review comments/states)
            echo "Fetching PR reviews..."
             # Use process substitution < <(...) and filter empty/null bodies within jq
            while IFS= read -r review_json; do
                login=$(echo "$review_json" | jq -r .login | escape_xml)
                submitted_at=$(echo "$review_json" | jq -r .submitted_at)
                body=$(echo "$review_json" | jq -r .body | escape_xml)
                state=$(echo "$review_json" | jq -r .state | escape_xml)
                COMMENTS_XML="${COMMENTS_XML}<comment type=\"review_body\" state=\"$state\"><author>$login</author><timestamp>$submitted_at</timestamp><content>$body</content></comment>"
                echo "  Processed review body by $login (State: $state)" # Debug log
            done < <(gh api "${GITHUB_API_ARGS[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER/reviews" --paginate --jq '.[] | select(.body != null and .body != "") | {login: .user.login, submitted_at: .submitted_at, body: .body, state: .state}' 2>/dev/null || { echo "::warning::Failed to fetch or process reviews."; echo "[]"; })

            # --- MODIFIED PR PROMPT (Less Restrictive) ---
            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Pull Request. Use the information provided within the <github_context> XML structure (including PR details, comments/reviews, and the code diff) as the primary source to understand the request. Provide a concise and helpful response to the <user_request>. You may leverage your general knowledge or other capabilities where appropriate to enhance the response, focusing on code review, understanding changes, or summarizing intent and impact."

            echo "PR details fetched. Title length: ${#PR_TITLE}, Body length: ${#PR_BODY}"
            echo "Diff fetched. Original Diff length: ${#PR_DIFF}"

          elif [[ "$CONTEXT_TYPE" == "issue" ]]; then
            echo "Fetching Issue details..."
            ISSUE_DATA=$(gh issue view $ISSUE_OR_PR_NUMBER --json title,body --repo ${REPO} 2>/dev/null || echo '{"title": "Error fetching Issue title", "body": "Error fetching Issue body"}')
            ISSUE_TITLE=$(echo "$ISSUE_DATA" | jq -r .title | escape_xml)
            ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r .body | escape_xml)

            CONTEXT_DETAILS_XML="<details><title>$ISSUE_TITLE</title><body>$ISSUE_BODY</body></details>"
            DIFF_XML="" # No diff for issues

            # No extra comment types needed for issues, standard comments already fetched above

            # --- MODIFIED ISSUE PROMPT (Less Restrictive) ---
            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Issue. Use the information provided within the <github_context> XML structure (including issue details and comments) as the primary source to understand the request. Provide a concise and helpful response to the <user_request>. You may leverage your general knowledge or other capabilities where appropriate to enhance the response, aiming to summarize the issue, clarify points, suggest potential next steps, or answer questions. If asked for solutions, propose actionable ideas informed by the issue's description and discussion."

            echo "Issue details fetched. Title length: ${#ISSUE_TITLE}, Body length: ${#ISSUE_BODY}"
          fi

          # --- Assemble Final Prompt ---
          echo "Final comments XML length: ${#COMMENTS_XML}" # Log final length
          echo "Assembling final prompt..."
          # Ensure proper XML structure and include the final user request
          FORMATTED_PROMPT="<github_context type=\"$CONTEXT_TYPE\" number=\"$ISSUE_OR_PR_NUMBER\">
            ${CONTEXT_DETAILS_XML}
            ${DIFF_XML}
            <comments>
            ${COMMENTS_XML}
            </comments>
            <user_request author=\"${{ github.event.comment.user.login }}\" timestamp=\"${{ github.event.comment.created_at }}\">${USER_REQUEST_BODY}</user_request>
            </github_context>
            
            ${PROMPT_INSTRUCTION}"

          if [ -z "$FORMATTED_PROMPT" ]; then
             echo "::error::Formatted prompt became empty after assembly. Check preceding logs and variable contents."
             exit 1
          fi
          echo "Final prompt assembled successfully. Length: ${#FORMATTED_PROMPT}"

          # Output the potentially large prompt securely using delimiters
          echo "formatted_prompt<<EOF_PROMPT_MARKER" >> $GITHUB_OUTPUT
          echo "$FORMATTED_PROMPT" >> $GITHUB_OUTPUT
          echo "EOF_PROMPT_MARKER" >> $GITHUB_OUTPUT
          echo "Formatted prompt output set."

      - name: Determine probe-chat Command
        id: determine_command
        run: |
          # Use parameter expansion for default value if secret is empty or unset
          CMD="${{ secrets.PROBE_CHAT_COMMAND }}:-${{ inputs.default_probe_chat_command }}"
          if [[ "${{ secrets.PROBE_CHAT_COMMAND }}" ]]; then
             echo "Using probe-chat command from PROBE_CHAT_COMMAND secret."
          else
             echo "Using default probe-chat command: ${{ inputs.default_probe_chat_command }}"
          fi
          echo "Final command: $CMD"
          echo "command=$CMD" >> $GITHUB_OUTPUT

      - name: Run probe-chat
        id: probe
        # Use bash -e -o pipefail to ensure errors in pipes are caught
        env:
          # Pass the prompt via environment variable
          PROBE_PROMPT: ${{ steps.format.outputs.formatted_prompt }}
          # Pass API keys and config via environment variables
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          ANTHROPIC_API_URL: ${{ secrets.ANTHROPIC_API_URL }}
          OPENAI_API_URL: ${{ secrets.OPENAI_API_URL }}
          GOOGLE_API_URL: ${{ secrets.GOOGLE_API_URL }}
          LLM_BASE_URL: ${{ secrets.LLM_BASE_URL }}
          MODEL_NAME: ${{ secrets.MODEL_NAME }}
          FORCE_PROVIDER: ${{ secrets.FORCE_PROVIDER }}
        run: |
          # No need for set -e here, shell option does it
          PROMPT="$PROBE_PROMPT" # Assign from env var for clarity if needed later
          COMMAND_TO_RUN='${{ steps.determine_command.outputs.command }}'
          RESPONSE_FILE="response.txt"
          ERROR_LOG="error.log" # Capture stderr separately

          # Check prompt presence immediately
          if [ -z "$PROMPT" ]; then
            echo "::error::Prompt environment variable (PROBE_PROMPT) is empty. Check the 'format' step outputs."
            # Create an error message file to be read by the next step
            echo "ðŸ¤– **Error:** Failed to prepare the AI prompt content. The prompt was empty." > "$RESPONSE_FILE"
            exit 1 # Fail the step
          fi

          echo "Running probe-chat..."
          echo "--- Start AI Prompt (first 500 / last 100 chars) ---"
          printf "%.500s\n...\n%s\n" "$PROMPT" "${PROMPT: -100}"
          echo "--- End AI Prompt Snippet ---"
          echo "Command to run: $COMMAND_TO_RUN"

          # Execute the command, redirect stdout to response file, stderr to error log
          # The pipefail option ensures failure if any command in the pipe fails
          # The EXIT_CODE capture is now less critical due to -e, but kept for potential finer control
          EXIT_CODE=0
          echo "$PROMPT" | $COMMAND_TO_RUN > "$RESPONSE_FILE" 2> "$ERROR_LOG" || EXIT_CODE=$?

          # Check exit code explicitly (good practice even with -e)
          if [ $EXIT_CODE -ne 0 ]; then
            echo "::error::probe-chat command failed with exit code $EXIT_CODE."
            echo "Stderr output from probe-chat:"
            cat "$ERROR_LOG" # Display error log in Actions log
            # Format an error message into the response file for the GitHub comment
            {
              echo "ðŸ¤– **Error:** The AI command failed (exit code $EXIT_CODE)."
              echo ""
              echo "**Details (from stderr):**"
              echo '```'
              cat "$ERROR_LOG" # Include stderr in the comment
              echo '```'
              echo ""
              echo "> Check the Action logs for the full prompt and details."
            } > "$RESPONSE_FILE"
            exit $EXIT_CODE # Ensure the step fails with the same code
          else
             echo "probe-chat command finished successfully."
             # Optionally log stdout if needed for debugging success cases
             # echo "Stdout from probe-chat:"
             # cat "$RESPONSE_FILE"
          fi


      - name: Read Response or Error and Format Output
        # Always run this step to capture success/failure messages
        if: always()
        id: read_response
        env:
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
        run: |
          RESPONSE_CONTENT=$(cat response.txt 2>/dev/null || echo "") # Read content, default to empty if file missing
          FINAL_BODY=""

          # Define the footer (using printf for safer formatting)
          FOOTER_TEMPLATE="\n\n-----\n*Tip: Start your comment with \`%s <your request>\` to trigger the AI.*\n*Built by [probe](https://probeai.dev)*"
          printf -v FOOTER "$FOOTER_TEMPLATE" "$COMMAND_PREFIX" # Safely substitutes the prefix

          # Determine the final body based on outcomes and content
          if [[ "${{ steps.probe.outcome }}" == "success" ]]; then
            if [[ -n "${RESPONSE_CONTENT// }" ]]; then # Check if response content is not blank
              FINAL_BODY="${RESPONSE_CONTENT}${FOOTER}" # Successful response with content
            else
              # Probe step succeeded, but the response file is empty
              FINAL_BODY="ðŸ¤– Processing finished, but no response was generated by the AI.${FOOTER}"
            fi
          else # probe step failed or was skipped (though skip condition unlikely if this step runs)
            if [[ -n "${RESPONSE_CONTENT// }" ]]; then
              # Probe failed, but response.txt has content (likely the formatted error from probe step)
              FINAL_BODY="${RESPONSE_CONTENT}${FOOTER}"
            elif [[ "${{ steps.format.outcome }}" == "failure" ]]; then
              FINAL_BODY="ðŸ¤– **Error:** Processing failed: Error during context preparation (step 'format'). Check Action logs.${FOOTER}"
            else
              # Generic error if probe failed and left no message (e.g., killed)
              FINAL_BODY="ðŸ¤– **Error:** Processing failed unexpectedly (step 'probe'). Check Action logs.${FOOTER}"
            fi
          fi

          echo "Final response body prepared. Length: ${#FINAL_BODY}"
          # Use multi-line output handling for potentially large bodies
          echo "response<<EOF_RESPONSE_MARKER" >> $GITHUB_OUTPUT
          echo "$FINAL_BODY" >> $GITHUB_OUTPUT
          echo "EOF_RESPONSE_MARKER" >> $GITHUB_OUTPUT


  # Job 2: Post the response back to GitHub
  post_response:
    # Only run if the process_comment job ran (wasn't skipped by the 'if' condition)
    if: needs.process_comment.result != 'skipped'
    runs-on: ubuntu-latest
    needs: [process_comment] # Depend on the previous job
    steps:
      - name: Post Response Comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          # Use the correctly defined output from the previous job
          issue-number: ${{ needs.process_comment.outputs.issue_number }}
          # Use the processed body from the previous job's output
          body: ${{ needs.process_comment.outputs.response_body }}

# </gh>
