# <gh>
name: Probe chat Github Action

on:
  workflow_call:
    inputs:
      command_prefix:
        description: "The prefix required on comments to trigger the AI (e.g., /probe-chat)"
        default: "/probe"
        required: true
        type: string
      default_probe_chat_command:
        description: "The default probe-chat command if PROBE_CHAT_COMMAND secret is not set"
        required: false
        default: "npx -y @buger/probe-chat@latest"
        type: string
      # Note: The actual probe-chat command to run will prioritize the PROBE_CHAT_COMMAND secret
      # passed by the caller via "secrets: inherit", then fall back to inputs.default_probe_chat_command.

# Permissions required by the jobs within THIS reusable workflow
permissions:
  pull-requests: write # Need read for context/diff, write for posting comments
  issues: write # Need read for context, write for posting comments
  contents: read # Potentially needed by gh or probe-chat

jobs:
  # Job 1: Check trigger, process context, run AI
  process_comment:
    # Only run if the comment starts with the provided prefix
    if: startsWith(github.event.comment.body, inputs.command_prefix)
    runs-on: ubuntu-latest
    outputs:
      response_body: ${{ steps.read_response.outputs.response }}
      issue_number: ${{ github.event.issue.number }}
      # This will now correctly reflect if the probe step succeeded or failed
      should_post: ${{ steps.probe.outcome == 'success' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install jq (if needed) and Verify gh
        run: |
          # jq is usually pre-installed on ubuntu-latest, but ensure it is present
          sudo apt-get update && sudo apt-get install -y jq --no-install-recommends
          # Verify gh is available
          gh --version

      - name: Determine Context and Format Input
        id: format
        env:
          # Use the GITHUB_TOKEN secret passed from the caller
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMAND_PREFIX: ${{ inputs.command_prefix }} # Make prefix available
        run: |
          # Using SHELLOPTS=extglob in env is possible but less common; setting inside script is clearer
          shopt -s extglob
          set -e # Exit on error

          ISSUE_OR_PR_NUMBER=${{ github.event.issue.number }}
          RAW_COMMENT_BODY="${{ github.event.comment.body }}"

          # Extract user request (remove prefix, trim whitespace)
          # Using parameter expansion for robustness and avoiding external commands like sed/xargs if simple
          USER_REQUEST_BODY="${RAW_COMMENT_BODY#${COMMAND_PREFIX}}" # Remove prefix
          USER_REQUEST_BODY="${USER_REQUEST_BODY##*( )}" # Trim leading spaces (requires extglob)
          USER_REQUEST_BODY="${USER_REQUEST_BODY%%*( )}" # Trim trailing spaces (requires extglob)
          echo "User request extracted."

          # Determine context type
          CONTEXT_TYPE="issue"
          # Check if the issue context has pull_request data associated
          if gh api "repos/${{ github.repository }}/issues/$ISSUE_OR_PR_NUMBER" --jq '.pull_request' | grep -q 'url'; then
             CONTEXT_TYPE="pr"
          fi
          echo "Context type: $CONTEXT_TYPE"

          # --- Fetch Common Data: Comments ---
          echo "Fetching comments for $CONTEXT_TYPE #$ISSUE_OR_PR_NUMBER..."
          # Fetch comments, handling potential errors during fetch
          COMMENTS_JSON=$(gh api -H "Accept: application/vnd.github+json" /repos/${{ github.repository }}/issues/$ISSUE_OR_PR_NUMBER/comments --jq '.' || echo "[]") # Default to empty array on error
          COMMENTS_XML=""
          # NOTE: Parsing arbitrary comment bodies into XML can be fragile. Consider base64 encoding or CDATA if issues arise.
          echo "$COMMENTS_JSON" | jq -c '.[] | {login: .user.login, created_at: .created_at, body: .body}' | while IFS= read -r comment_json; do
            export login=$(echo "$comment_json" | jq -r .login)
            export created_at=$(echo "$comment_json" | jq -r .created_at)
            # Basic XML escaping for body to handle simple cases
            export body=$(echo "$comment_json" | jq -r .body | sed 's/&/\&/g; s/</\</g; s/>/\>/g; s/"/\"/g; s/'"'"'/\'/g;')
            COMMENTS_XML+=$(cat <<EOF
                  <comment><author>$(echo "$login" | sed 's/&/\&/g; s/</\</g; s/>/\>/g')</author><timestamp>$created_at</timestamp><content>$body</content></comment>
          EOF
          )
          done
          echo "Comments fetched."

          # --- Fetch Context-Specific Data & Build XML ---
          CONTEXT_DETAILS_XML=""
          DIFF_XML=""
          PROMPT_INSTRUCTION=""

          if [[ "$CONTEXT_TYPE" == "pr" ]]; then
            echo "Fetching PR details and diff..."
            # Fetch PR data, handle potential errors
            PR_DATA=$(gh pr view $ISSUE_OR_PR_NUMBER --json title,body --repo ${{ github.repository }} || echo '{"title": "Error fetching title", "body": "Error fetching body"}')
            # Basic XML escaping for title and body
            PR_TITLE=$(echo "$PR_DATA" | jq -r .title | sed 's/&/\&/g; s/</\</g; s/>/\>/g')
            PR_BODY=$(echo "$PR_DATA" | jq -r .body | sed 's/&/\&/g; s/</\</g; s/>/\>/g')
            # Fetch diff, handle potential errors and escape
            PR_DIFF=$(gh pr diff $ISSUE_OR_PR_NUMBER --repo ${{ github.repository }} 2>/dev/null | sed 's/&/\&/g; s/</\</g; s/>/\>/g' || echo "<!-- Error fetching diff -->")

            CONTEXT_DETAILS_XML="<details><title>$PR_TITLE</title><body>$PR_BODY</body></details>"
            # Wrap diff in CDATA for better handling of special characters
            DIFF_XML="<diff><![CDATA[\n$(echo "$PR_DIFF" | sed 's/]]>/]]>/g')\n]]></diff>" # Escape CDATA terminators if present in diff
            PROMPT_INSTRUCTION="Based *only* on the information provided within the <github_context> XML structure (including PR details, diff, and comments), please provide a response to the <user_request>."
            echo "PR details and diff fetched."

          elif [[ "$CONTEXT_TYPE" == "issue" ]]; then
            echo "Fetching Issue details..."
             # Fetch Issue data, handle potential errors
            ISSUE_DATA=$(gh issue view $ISSUE_OR_PR_NUMBER --json title,body --repo ${{ github.repository }} || echo '{"title": "Error fetching title", "body": "Error fetching body"}')
             # Basic XML escaping for title and body
            ISSUE_TITLE=$(echo "$ISSUE_DATA" | jq -r .title | sed 's/&/\&/g; s/</\</g; s/>/\>/g')
            ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r .body | sed 's/&/\&/g; s/</\</g; s/>/\>/g')

            CONTEXT_DETAILS_XML="<details><title>$ISSUE_TITLE</title><body>$ISSUE_BODY</body></details>"
            PROMPT_INSTRUCTION="Based *only* on the information provided within the <github_context> XML structure (including issue details and comments), please provide a response to the <user_request>."
            echo "Issue details fetched."
          fi

          # --- Assemble Final Prompt ---
          # Ensure user request is also escaped
          USER_REQUEST_ESCAPED=$(echo "$USER_REQUEST_BODY" | sed 's/&/\&/g; s/</\</g; s/>/\>/g')
          read -r -d '' FORMATTED_PROMPT <<EOF || true
          <github_context type="$CONTEXT_TYPE" number="$ISSUE_OR_PR_NUMBER">
          $CONTEXT_DETAILS_XML
          $DIFF_XML
            <comments>
          $COMMENTS_XML
            </comments>
            <user_request>
          $USER_REQUEST_ESCAPED
            </user_request>
          </github_context>

          $PROMPT_INSTRUCTION
          EOF

          echo "Final prompt assembled."
          # Output the potentially large prompt securely
          echo "formatted_prompt<<EOF_PROMPT_MARKER" >> $GITHUB_OUTPUT
          echo "$FORMATTED_PROMPT" >> $GITHUB_OUTPUT
          echo "EOF_PROMPT_MARKER" >> $GITHUB_OUTPUT


      - name: Determine probe-chat Command
        id: determine_command
        # Use PROBE_CHAT_COMMAND secret if passed by caller and non-empty, else use the default input
        run: |
          CMD="${{ secrets.PROBE_CHAT_COMMAND }}"
          if [[ -z "$CMD" ]]; then
            CMD="${{ inputs.default_probe_chat_command }}"
            echo "Using default probe-chat command."
          else
            echo "Using probe-chat command from PROBE_CHAT_COMMAND secret."
          fi
          echo "Final command: $CMD"
          echo "command=$CMD" >> $GITHUB_OUTPUT

      - name: Run probe-chat
        id: probe
        # Use bash for pipefail and better error handling
        shell: bash
        run: |
          # Exit script if any command fails, and ensure pipeline failures are caught
          set -e
          set -o pipefail

          PROMPT='${{ steps.format.outputs.formatted_prompt }}'
          COMMAND_TO_RUN='${{ steps.determine_command.outputs.command }}'
          RESPONSE_FILE="response.txt"
          ERROR_LOG="error.log"

          echo "Running probe-chat..."
          echo "--- Start AI Prompt (first 500 chars) ---"
          echo "${PROMPT:0:500}..." # Log only beginning of potentially large prompt
          echo "--- End AI Prompt Snippet ---"
          echo "Command to run: $COMMAND_TO_RUN"

          # Execute the command, capturing stdout and stderr
          # The command's exit code determines success/failure due to set -e and pipefail
          echo "$PROMPT" | $COMMAND_TO_RUN > "$RESPONSE_FILE" 2> "$ERROR_LOG"

          # If we reach here, the command succeeded (exit code 0)
          echo "probe-chat command finished successfully."

        # Define a separate step that runs *only* if the 'probe' step fails
        # This step will prepare the error message for the comment
      - name: Handle probe-chat Failure
        if: failure() && steps.probe.outcome == 'failure' # Run only if the previous step failed
        run: |
          echo "Error: probe-chat command failed." > response.txt
          echo "Stderr output:" >> response.txt
          echo '```' >> response.txt
          cat error.log >> response.txt || echo "(no stderr output captured)" >> response.txt
          echo '```' >> response.txt
          echo "Check the Action logs for more details." >> response.txt
          echo "Error details logged to response.txt"

      - name: Read Response or Error
        id: read_response
        # This step runs regardless of probe success/failure now
        # It reads response.txt which contains either the AI output or the error message
        run: |
          RESPONSE=$(cat response.txt)
          # Check if RESPONSE is empty or contains only whitespace
          if [[ -z "${RESPONSE// }" ]]; then
            RESPONSE="🤖 Processing failed or no response generated. Check Action logs."
          fi
          echo "Response content captured."
          # Use EOF markers for multiline output
          echo "response<<EOF_RESPONSE_MARKER" >> $GITHUB_OUTPUT
          echo "$RESPONSE" >> $GITHUB_OUTPUT
          echo "EOF_RESPONSE_MARKER" >> $GITHUB_OUTPUT


  # Job 2: Post the response back to GitHub
  post_response:
    # Run only if the triggering comment was valid AND the probe command succeeded
    # Note: If probe failed, process_comment still "succeeds" overall, but `should_post` is false.
    # We want to post the error message generated by 'Handle probe-chat Failure' step.
    # Therefore, we just check if the process_comment job finished (regardless of outcome)
    # and rely on the response_body containing either success or error message.
    if: needs.process_comment.result != 'skipped' # Post if the process_comment job ran (wasn't skipped by its own 'if')
    runs-on: ubuntu-latest
    needs: [process_comment] # Depends on the first job
    # Permissions are defined at the workflow level
    steps:
      - name: Post Response Comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }} # Use the token passed from the caller
          repository: ${{ github.repository }} # Explicitly provide repo context
          issue-number: ${{ needs.process_comment.outputs.issue_number }}
          body: ${{ needs.process_comment.outputs.response_body }}
