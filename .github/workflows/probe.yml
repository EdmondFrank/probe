# <gh>
name: Probe chat Github Action

on:
  workflow_call:
    inputs:
      command_prefix:
        description: "The prefix required on comments to trigger the AI (e.g., /probe, /ai, etc)"
        default: "/probe"
        required: true
        type: string
      default_probe_chat_command:
        description: "The default probe-chat command if PROBE_CHAT_COMMAND secret is not set"
        required: false
        default: "npx -y @buger/probe-chat@latest"
        type: string
      # Note: The actual probe-chat command to run will prioritize the PROBE_CHAT_COMMAND secret
      # passed by the caller via "secrets: inherit", then fall back to inputs.default_probe_chat_command.

# Permissions required by the jobs within THIS reusable workflow
permissions:
  pull-requests: write # Needed for reading PR data/comments/reviews, posting comments, adding reactions
  issues: write        # Needed for reading issue data/comments, posting comments, adding reactions
  contents: read       # Needed for gh pr diff etc.

jobs:
  process_comment:
    # Run only if the comment starts with the specified prefix AND the comment event is valid
    # Note: workflow_call doesn't expose the specific event easily, rely on issue.number presence
    if: >
      startsWith(github.event.comment.body, inputs.command_prefix) &&
      github.event.issue.number != null &&
      github.event.comment.id != null
    runs-on: ubuntu-latest
    outputs:
      response_body: ${{ steps.read_response.outputs.response }}
      issue_number: ${{ steps.set_context_ids.outputs.issue_number }}
      probe_succeeded: ${{ steps.probe.outcome == 'success' }}
      context_type: ${{ steps.format.outputs.context_type }} # Expose context type for debugging if needed

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install jq and Verify gh
        run: |
          sudo apt-get update && sudo apt-get install -y jq --no-install-recommends
          gh --version

      - name: Set Issue Number and Comment ID Output
        id: set_context_ids
        run: |
          # Use issue.number which is present for both issue_comment and pull_request_review_comment events
          echo "issue_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          echo "comment_id=${{ github.event.comment.id }}" >> $GITHUB_OUTPUT
          echo "Comment is on issue/PR number: ${{ github.event.issue.number }}"
          echo "Comment ID: ${{ github.event.comment.id }}"
          echo "Triggering user: ${{ github.event.comment.user.login }}"

      - name: Add 'eyes' reaction to comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          COMMENT_ID: ${{ steps.set_context_ids.outputs.comment_id }}
        run: |
          echo "Adding ðŸ‘€ reaction to comment ID ${COMMENT_ID} in repo ${REPO}"
          # Use issues API endpoint for comments as it works for both PRs and Issues
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            "/repos/${REPO}/issues/comments/${COMMENT_ID}/reactions" \
            -f content='eyes' \
            --silent || echo "::warning::Failed to add reaction to comment ${COMMENT_ID}. Continuing..."

      # --- MODIFIED: Determine Context, Fetch ALL Comments, Format Input ---
      - name: Determine Context, Fetch Comments, Format Input
        id: format
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
          REPO: ${{ github.repository }}
        outputs: # Define output for context type
          context_type: ${{ steps.determine_context.outputs.type }}
          formatted_prompt: ${{ steps.assemble_prompt.outputs.formatted_prompt }} # Pass through the final prompt
        run: |
          # Sub-steps within the run block for better organization
          # ------------------------------------------------------
          # Sub-step 1: Initialization and User Request Extraction
          # ------------------------------------------------------
          echo "::group::Initialization and User Request Extraction"
          shopt -s extglob # Enable extended globbing for string trimming
          set -e           # Exit on error
          # set -x         # Uncomment for deep debugging

          ISSUE_OR_PR_NUMBER=${{ steps.set_context_ids.outputs.issue_number }}
          RAW_COMMENT_BODY="${{ github.event.comment.body }}"
          GITHUB_API_ARGS_VERBOSE=(-H "Accept: application/vnd.github+json") # Common args for gh api calls where we want to see errors

          # Basic XML escaping function (ampersand first!)
          escape_xml() {
            # Using Perl for more robust XML escaping
            perl -pe 's/&/\&/g; s/</\</g; s/>/\>/g; s/"/\"/g; s/'"'"'/\'/g;'
          }

          # Extract user request, trim prefix and whitespace
          USER_REQUEST_BODY_RAW="${RAW_COMMENT_BODY#${COMMAND_PREFIX}}"
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW##*( )}" # Trim leading whitespace
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW%%*( )}" # Trim trailing whitespace
          USER_REQUEST_BODY=$(echo "$USER_REQUEST_BODY_RAW" | escape_xml)
          echo "User request extracted and escaped: [${USER_REQUEST_BODY:0:100}...]"
          echo "::endgroup::"

          # ------------------------------------------------------
          # Sub-step 2: Determine Context Type (PR or Issue)
          # This is the critical step for the reported issue.
          # ------------------------------------------------------
          echo "::group::Determine Context Type"
          CONTEXT_TYPE="issue" # Assume issue by default
          echo "Attempting to detect context for number: $ISSUE_OR_PR_NUMBER in repo $REPO"

          # Try hitting the Pull Request API endpoint for this number.
          # Use verbose args to see potential errors from the API or gh itself.
          # Redirect stdout to /dev/null because we only care about the exit status. Stderr will still print.
          if gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER" --jq .url > /dev/null 2>&1; then
             CONTEXT_TYPE="pr"
             echo "Successfully queried PR API endpoint (/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER). Context determined as: PR"
          else
             EXIT_CODE=$?
             echo "Query to PR API endpoint failed (Exit Code: $EXIT_CODE). Assuming context is: Issue"
             # Optional: Double-check if it's definitely an issue (helps diagnose weird cases)
             if gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/issues/$ISSUE_OR_PR_NUMBER" --jq .url > /dev/null 2>&1; then
                 echo "Successfully queried Issue API endpoint (/repos/${REPO}/issues/$ISSUE_OR_PR_NUMBER). Confirmed as Issue context."
             else
                 ISSUE_EXIT_CODE=$?
                 echo "::warning::Query to Issue API endpoint also failed (Exit Code: $ISSUE_EXIT_CODE). Cannot definitively confirm context. Proceeding as Issue, but check permissions and repo/number validity."
             fi
             CONTEXT_TYPE="issue" # Ensure it remains issue if PR check fails
          fi
          # Set the context type as an output of this internal "sub-step" for later use
          echo "CONTEXT_TYPE=${CONTEXT_TYPE}" > context_type.out
          echo "::set-output name=type::${CONTEXT_TYPE}" # Also set as step output directly
          echo "::endgroup::"


          # ------------------------------------------------------
          # Sub-step 3: Fetch Base Comments (Common to Issues & PRs)
          # ------------------------------------------------------
          echo "::group::Fetch Base Comments"
          COMMENTS_XML="" # Initialize variable

          echo "Fetching standard comments JSON for $CONTEXT_TYPE #$ISSUE_OR_PR_NUMBER..."
          STD_COMMENTS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/issues/$ISSUE_OR_PR_NUMBER/comments" --paginate)
          STD_COMMENTS_EXIT_CODE=$?

          if [[ $STD_COMMENTS_EXIT_CODE -ne 0 ]]; then
              echo "::warning::Failed to fetch standard comments (exit code $STD_COMMENTS_EXIT_CODE). See logs above for potential API errors."
          elif echo "$STD_COMMENTS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
              echo "Standard comments JSON is a valid array. Processing..."
              while IFS=$'\t' read -r login created_at body; do
                  escaped_login=$(echo "$login" | escape_xml)
                  escaped_body=$(echo "$body" | escape_xml)
                  COMMENTS_XML="${COMMENTS_XML}<comment type=\"issue\"><author>$escaped_login</author><timestamp>$created_at</timestamp><content>$escaped_body</content></comment>"
              done < <(echo "$STD_COMMENTS_JSON" | jq -r '.[] | [.user.login // "unknown", .created_at // "N/A", .body // ""] | @tsv')
              echo "Finished processing standard comments. XML length: ${#COMMENTS_XML}"
          else
              echo "::warning::API call for standard comments succeeded but did not return a valid JSON array. Response (first 500 chars):"
              echo "$STD_COMMENTS_JSON" | head -c 500
          fi
          echo "::endgroup::"

          # ------------------------------------------------------
          # Sub-step 4: Fetch Context-Specific Data & Build XML
          # ------------------------------------------------------
          echo "::group::Fetch Context-Specific Data"
          CONTEXT_DETAILS_XML=""
          DIFF_XML=""
          PROMPT_INSTRUCTION=""

          # Use the determined context type
          CURRENT_CONTEXT_TYPE=$(cat context_type.out | cut -d '=' -f 2)
          echo "Proceeding with context type: $CURRENT_CONTEXT_TYPE"

          if [[ "$CURRENT_CONTEXT_TYPE" == "pr" ]]; then
            echo "Fetching PR details, diff, review comments, and reviews..."
            # Fetch PR details
            PR_DATA=$(gh pr view $ISSUE_OR_PR_NUMBER --json title,body --repo ${REPO} 2> pr_view_error.log || echo 'FETCH_FAILED')
            if [[ "$PR_DATA" == "FETCH_FAILED" ]]; then
                echo "::warning::Failed to fetch PR details (title, body). Error log:" && cat pr_view_error.log
                PR_TITLE="Error fetching PR title" && PR_BODY="Error fetching PR body"
            else
                PR_TITLE=$(echo "$PR_DATA" | jq -r .title | escape_xml) && PR_BODY=$(echo "$PR_DATA" | jq -r .body | escape_xml)
            fi

            # Fetch PR diff
            PR_DIFF=$(gh pr diff $ISSUE_OR_PR_NUMBER --repo ${REPO} 2> pr_diff_error.log || echo "FETCH_FAILED")
            if [[ "$PR_DIFF" == "FETCH_FAILED" ]]; then
                 echo "::warning::Failed to fetch PR diff. Error log:" && cat pr_diff_error.log
                 ESCAPED_PR_DIFF="<!-- Error fetching diff -->"
            else
                 ESCAPED_PR_DIFF=$(echo "$PR_DIFF" | escape_xml)
            fi

            CONTEXT_DETAILS_XML="<details><title>$PR_TITLE</title><body>$PR_BODY</body></details>"
            DIFF_XML="<diff>$ESCAPED_PR_DIFF</diff>"

            # Fetch PR review comments (diff comments)
            echo "Fetching PR review comments (diff comments) JSON..."
            REVIEW_COMMENTS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER/comments" --paginate)
            REVIEW_COMMENTS_EXIT_CODE=$?
            if [[ $REVIEW_COMMENTS_EXIT_CODE -ne 0 ]]; then
                echo "::warning::Failed to fetch PR review comments (exit code $REVIEW_COMMENTS_EXIT_CODE). See logs."
            elif echo "$REVIEW_COMMENTS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
                echo "Processing PR review comments..."
                while IFS=$'\t' read -r login created_at body path diff_hunk line; do
                    escaped_login=$(echo "$login" | escape_xml) && escaped_body=$(echo "$body" | escape_xml)
                    escaped_path=$(echo "$path" | escape_xml) && escaped_diff_hunk=$(echo "$diff_hunk" | escape_xml)
                    COMMENTS_XML="${COMMENTS_XML}<comment type=\"review_comment\" file=\"$escaped_path\" line=\"$line\"><author>$escaped_login</author><timestamp>$created_at</timestamp><diff_hunk>$escaped_diff_hunk</diff_hunk><content>$escaped_body</content></comment>"
                done < <(echo "$REVIEW_COMMENTS_JSON" | jq -r '.[] | [.user.login // "unknown", .created_at // "N/A", .body // "", .path // "unknown", .diff_hunk // "", (.line // .original_line // "N/A")] | @tsv')
                echo "Finished processing review comments. XML length: ${#COMMENTS_XML}"
            else
                echo "::warning::API call for review comments succeeded but did not return a valid JSON array. Response (first 500 chars):" && echo "$REVIEW_COMMENTS_JSON" | head -c 500
            fi

            # Fetch PR reviews (overall review comments/states)
            echo "Fetching PR reviews JSON..."
            REVIEWS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER/reviews" --paginate)
            REVIEWS_EXIT_CODE=$?
            if [[ $REVIEWS_EXIT_CODE -ne 0 ]]; then
                echo "::warning::Failed to fetch PR reviews (exit code $REVIEWS_EXIT_CODE). See logs."
            elif echo "$REVIEWS_JSON" | jq -e '[.[] | select(.body != null and .body != "")] | type == "array"' > /dev/null 2>&1; then
                 echo "Processing PR review bodies..."
                 while IFS=$'\t' read -r login submitted_at body state; do
                     escaped_login=$(echo "$login" | escape_xml) && escaped_body=$(echo "$body" | escape_xml)
                     escaped_state=$(echo "$state" | escape_xml)
                     COMMENTS_XML="${COMMENTS_XML}<comment type=\"review_body\" state=\"$escaped_state\"><author>$escaped_login</author><timestamp>$submitted_at</timestamp><content>$escaped_body</content></comment>"
                 done < <(echo "$REVIEWS_JSON" | jq -r '.[] | select(.body != null and .body != "") | [.user.login // "unknown", .submitted_at // "N/A", .body, .state // "N/A"] | @tsv')
                 echo "Finished processing review bodies. XML length: ${#COMMENTS_XML}"
            else
                 echo "::warning::API call for reviews succeeded, but no valid review bodies found or response was not a JSON array. Response (first 500 chars):" && echo "$REVIEWS_JSON" | head -c 500
            fi

            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Pull Request. Use the information provided within the <github_context> XML structure (including PR details, comments/reviews, and the code diff) as the primary source to understand the request. Provide a concise and helpful response to the <user_request>. You may leverage your general knowledge or other capabilities where appropriate to enhance the response, focusing on code review, understanding changes, or summarizing intent and impact."
            echo "PR context preparation finished."

          elif [[ "$CURRENT_CONTEXT_TYPE" == "issue" ]]; then
            echo "Fetching Issue details..."
            ISSUE_DATA=$(gh issue view $ISSUE_OR_PR_NUMBER --json title,body --repo ${REPO} 2> issue_view_error.log || echo 'FETCH_FAILED')
             if [[ "$ISSUE_DATA" == "FETCH_FAILED" ]]; then
                echo "::warning::Failed to fetch Issue details (title, body). Error log:" && cat issue_view_error.log
                ISSUE_TITLE="Error fetching Issue title" && ISSUE_BODY="Error fetching Issue body"
            else
                ISSUE_TITLE=$(echo "$ISSUE_DATA" | jq -r .title | escape_xml) && ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r .body | escape_xml)
            fi

            CONTEXT_DETAILS_XML="<details><title>$ISSUE_TITLE</title><body>$ISSUE_BODY</body></details>"
            DIFF_XML="" # No diff for issues

            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Issue. Use the information provided within the <github_context> XML structure (including issue details and comments) as the primary source to understand the request. Provide a concise and helpful response to the <user_request>. You may leverage your general knowledge or other capabilities where appropriate to enhance the response, aiming to summarize the issue, clarify points, suggest potential next steps, or answer questions. If asked for solutions, propose actionable ideas informed by the issue's description and discussion."
            echo "Issue context preparation finished."
          fi
          echo "::endgroup::"

          # ------------------------------------------------------
          # Sub-step 5: Assemble Final Prompt
          # ------------------------------------------------------
          echo "::group::Assemble Final Prompt"
          # Re-read context type just in case
          FINAL_CONTEXT_TYPE=$(cat context_type.out | cut -d '=' -f 2)

          FORMATTED_PROMPT="<github_context type=\"$FINAL_CONTEXT_TYPE\" number=\"$ISSUE_OR_PR_NUMBER\">
            ${CONTEXT_DETAILS_XML}
            ${DIFF_XML}
            <comments>
            ${COMMENTS_XML}
            </comments>
            <user_request author=\"${{ github.event.comment.user.login }}\" timestamp=\"${{ github.event.comment.created_at }}\">${USER_REQUEST_BODY}</user_request>
            </github_context>

            ${PROMPT_INSTRUCTION}"

          if [ ${#FORMATTED_PROMPT} -lt 200 ]; then # Basic sanity check
             echo "::warning::Formatted prompt seems unusually short. Check preceding logs."
             echo "Prompt Snippet: ${FORMATTED_PROMPT:0:500}..."
          fi
          echo "Final prompt assembled. Length: ${#FORMATTED_PROMPT}"

          # Output the potentially large prompt securely using delimiters
          # This intermediate step helps avoid issues with complex characters in direct step output setting
          echo "$FORMATTED_PROMPT" > formatted_prompt.txt
          echo "::set-output name=formatted_prompt_file::formatted_prompt.txt"

          # Expose context_type as well
          echo "::set-output name=context_type::${FINAL_CONTEXT_TYPE}"
          echo "::endgroup::"

      - name: Read Formatted Prompt from File
        id: read_prompt_file
        # Read the prompt content from the file generated in the previous step
        run: |
          PROMPT_FILE="${{ steps.format.outputs.formatted_prompt_file }}"
          if [[ -f "$PROMPT_FILE" ]]; then
            echo "Reading prompt from $PROMPT_FILE"
            # Use heredoc to handle multi-line prompt content safely
            {
              echo "formatted_prompt<<EOF_PROMPT_MARKER"
              cat "$PROMPT_FILE"
              echo "EOF_PROMPT_MARKER"
            } >> "$GITHUB_OUTPUT"
            echo "Prompt successfully read and set to output."
          else
            echo "::error::Formatted prompt file '$PROMPT_FILE' not found."
            # Set an empty prompt to indicate failure downstream
            echo "formatted_prompt=" >> "$GITHUB_OUTPUT"
            exit 1
          fi

      - name: Determine probe-chat Command
        id: determine_command
        run: |
          CMD="${{ secrets.PROBE_CHAT_COMMAND || inputs.default_probe_chat_command }}"
          if [[ "${{ secrets.PROBE_CHAT_COMMAND }}" ]]; then
             echo "Using probe-chat command from PROBE_CHAT_COMMAND secret."
          else
             echo "Using default probe-chat command: ${{ inputs.default_probe_chat_command }}"
          fi
          echo "Final command: $CMD"
          echo "command=$CMD" >> $GITHUB_OUTPUT

      - name: Run probe-chat
        id: probe
        env:
          # Pass the prompt via environment variable, reading from the previous step's output
          PROBE_PROMPT: ${{ steps.read_prompt_file.outputs.formatted_prompt }}
          # Pass API keys and config via environment variables
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          ANTHROPIC_API_URL: ${{ secrets.ANTHROPIC_API_URL }}
          OPENAI_API_URL: ${{ secrets.OPENAI_API_URL }}
          GOOGLE_API_URL: ${{ secrets.GOOGLE_API_URL }}
          LLM_BASE_URL: ${{ secrets.LLM_BASE_URL }}
          MODEL_NAME: ${{ secrets.MODEL_NAME }}
          FORCE_PROVIDER: ${{ secrets.FORCE_PROVIDER }}
        run: |
          set -o pipefail # Catch pipe errors
          PROMPT="$PROBE_PROMPT" # Assign from env var for clarity
          COMMAND_TO_RUN='${{ steps.determine_command.outputs.command }}'
          RESPONSE_FILE="response.txt"
          ERROR_LOG="error.log" # Capture stderr separately

          if [ -z "$PROMPT" ]; then
            echo "::error::Prompt environment variable (PROBE_PROMPT) is empty. Check the 'format' and 'read_prompt_file' step outputs."
            echo "ðŸ¤– **Error:** Failed to prepare the AI prompt content. The prompt was empty." > "$RESPONSE_FILE"
            exit 1 # Fail the step
          fi

          echo "Running probe-chat..."
          echo "--- Start AI Prompt (first 500 / last 100 chars) ---"
          printf "%.500s\n...\n%s\n" "$PROMPT" "${PROMPT: -100}"
          echo "--- End AI Prompt Snippet ---"
          echo "Command to run: $COMMAND_TO_RUN"

          # Execute the command, redirect stdout to response file, stderr to error log
          # Use bash -c to handle potential complex commands and ensure pipefail applies correctly
          bash -c "echo \"\$PROMPT\" | $COMMAND_TO_RUN" > "$RESPONSE_FILE" 2> "$ERROR_LOG"
          EXIT_CODE=$?

          # Check exit code explicitly
          if [ $EXIT_CODE -ne 0 ]; then
             echo "::error::probe-chat command failed with exit code $EXIT_CODE."
             # Check if error log has content, otherwise provide generic message
             if [ -s "$ERROR_LOG" ]; then
                echo "--- stderr from probe-chat ---"
                cat "$ERROR_LOG"
                echo "--- end stderr ---"
             else
                echo "No specific error message captured on stderr."
             fi
             # Ensure an error message is in response.txt for the next step
             if [ ! -s "$RESPONSE_FILE" ]; then # If probe didn't write anything before failing
               echo "ðŸ¤– **Error:** The AI command failed to execute. Exit code: $EXIT_CODE. Check Action logs." > "$RESPONSE_FILE"
             fi
             exit $EXIT_CODE # Propagate the failure
          fi

          echo "probe-chat command finished successfully."
          if [ ! -s "$RESPONSE_FILE" ]; then
            echo "::warning::probe-chat succeeded but produced an empty response file."
            echo "ðŸ¤– Processing finished successfully, but no response content was generated by the AI." > "$RESPONSE_FILE" # Provide default content
          fi

      - name: Read Response or Error and Format Output
        if: always() # Always run to capture success/failure
        id: read_response
        env:
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
        run: |
          RESPONSE_CONTENT=$(cat response.txt 2>/dev/null || echo "") # Read content, default to empty if file missing
          ERROR_LOG_CONTENT=$(cat error.log 2>/dev/null || echo "")   # Read error log content from probe step
          FINAL_BODY=""

          FOOTER_TEMPLATE="\n\n-----\n*Tip: Start your comment with \`%s <your request>\` to trigger the AI.*\n*Built by [probe](https://probeai.dev)*"
          printf -v FOOTER "$FOOTER_TEMPLATE" "$COMMAND_PREFIX" # Safely substitutes the prefix

          # Determine final body based on outcomes
          if [[ "${{ steps.probe.outcome }}" == "success" ]]; then
              # Probe step succeeded, use content from response.txt (which might be empty or have a default message)
              if [[ -n "${RESPONSE_CONTENT// }" ]]; then # Check if response content is not blank
                  FINAL_BODY="${RESPONSE_CONTENT}${FOOTER}"
              else
                  # Should have been populated by probe step, but as a fallback:
                  FINAL_BODY="ðŸ¤– Processing finished successfully, but the AI response was empty.${FOOTER}"
              fi
          else # probe step failed or was skipped
              ERROR_MESSAGE="ðŸ¤– **Error:** The AI interaction failed."
              # Check previous steps first
              if [[ "${{ steps.format.outcome }}" == "failure" ]] || [[ "${{ steps.read_prompt_file.outcome }}" == "failure" ]]; then
                 ERROR_MESSAGE="ðŸ¤– **Error:** Processing failed during context preparation or prompt reading. Check Action logs for 'format' or 'read_prompt_file' steps."
              # Check if probe step wrote an error to response.txt
              elif [[ -n "${RESPONSE_CONTENT// }" ]] && echo "$RESPONSE_CONTENT" | grep -q "ðŸ¤– \*\*Error:\*\*" ; then
                  ERROR_MESSAGE="${RESPONSE_CONTENT}" # Use the error message written by probe step
              # Check if probe step captured stderr
              elif [[ -n "${ERROR_LOG_CONTENT// }" ]]; then
                  ERROR_MESSAGE="${ERROR_MESSAGE}\n\n**Details (from stderr):**\n\`\`\`\n$(cat error.log)\n\`\`\`" # Display captured stderr
              else
                  ERROR_MESSAGE="${ERROR_MESSAGE} No specific error details were captured. Check the Action logs for the 'Run probe-chat' step (outcome: ${{ steps.probe.outcome }})."
              fi
              FINAL_BODY="${ERROR_MESSAGE}${FOOTER}"
          fi

          echo "Final response body prepared. Length: ${#FINAL_BODY}"
          # Use multi-line output handling
          echo "response<<EOF_RESPONSE_MARKER" >> $GITHUB_OUTPUT
          echo "$FINAL_BODY" >> $GITHUB_OUTPUT
          echo "EOF_RESPONSE_MARKER" >> $GITHUB_OUTPUT

  post_response:
    if: needs.process_comment.result != 'skipped'
    runs-on: ubuntu-latest
    needs: [process_comment]
    steps:
      - name: Post Response Comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          issue-number: ${{ needs.process_comment.outputs.issue_number }}
          body: ${{ needs.process_comment.outputs.response_body }}
          # Add reaction based on probe success/failure
          reactions: ${{ needs.process_comment.outputs.probe_succeeded == 'true' && '+1' || '-1' }}
          # Optional: Edit the 'eyes' reaction added earlier (might be complex to find)
          # Instead, just add a thumbs up/down to the *new* comment.

# </gh>
