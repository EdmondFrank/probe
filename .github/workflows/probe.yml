# <gh>
name: Probe chat Github Action

on:
  workflow_call:
    inputs:
      command_prefix:
        description: "The prefix required on comments to trigger the AI (e.g., /probe, /ai, etc)"
        default: "/probe"
        required: true
        type: string
      default_probe_chat_command:
        description: "The default probe-chat command if PROBE_CHAT_COMMAND secret is not set"
        required: false
        default: "npx -y @buger/probe-chat@latest"
        type: string
      # Note: The actual probe-chat command to run will prioritize the PROBE_CHAT_COMMAND secret
      # passed by the caller via "secrets: inherit", then fall back to inputs.default_probe_chat_command.

# Permissions required by the jobs within THIS reusable workflow
permissions:
  pull-requests: write # Needed for reading PR data/comments/reviews, posting comments, adding reactions
  issues: write        # Needed for reading issue data/comments, posting comments, adding reactions
  contents: read       # Needed for gh pr diff etc.

jobs:
  process_comment:
    # Run only if the comment starts with the specified prefix AND the comment event is valid
    if: >
      startsWith(github.event.comment.body, inputs.command_prefix) &&
      github.event.issue.number != null &&
      github.event.comment.id != null
    runs-on: ubuntu-latest
    outputs:
      response_body: ${{ steps.read_response.outputs.response }}
      issue_number: ${{ steps.set_context_ids.outputs.issue_number }}
      probe_succeeded: ${{ steps.probe.outcome == 'success' }}
      # CORRECTED: Expose context_type from the format step's output
      context_type: ${{ steps.format.outputs.context_type }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install jq and Verify gh
        run: |
          sudo apt-get update && sudo apt-get install -y jq perl --no-install-recommends
          gh --version

      - name: Set Issue Number and Comment ID Output
        id: set_context_ids
        run: |
          echo "issue_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          echo "comment_id=${{ github.event.comment.id }}" >> $GITHUB_OUTPUT
          echo "Comment is on issue/PR number: ${{ github.event.issue.number }}"
          echo "Comment ID: ${{ github.event.comment.id }}"
          echo "Triggering user: ${{ github.event.comment.user.login }}"

      - name: Add 'eyes' reaction to comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          COMMENT_ID: ${{ steps.set_context_ids.outputs.comment_id }}
        run: |
          echo "Adding ðŸ‘€ reaction to comment ID ${COMMENT_ID} in repo ${REPO}"
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            "/repos/${REPO}/issues/comments/${COMMENT_ID}/reactions" \
            -f content='eyes' \
            --silent || echo "::warning::Failed to add reaction to comment ${COMMENT_ID}. Continuing..."

      # --- CORRECTED: Determine Context, Fetch ALL Comments, Format Input ---
      - name: Determine Context, Fetch Comments, Format Input
        id: format
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
          REPO: ${{ github.repository }}
        # CORRECTED: Define outputs at the step level
        outputs:
          context_type: ${{ steps.format_script.outputs.context_type_value }} # Referencing internal marker
          formatted_prompt_file: ${{ steps.format_script.outputs.prompt_file_path }} # Referencing internal marker
        run: |
          # Use an internal step ID marker for clarity when setting outputs
          # This isn't strictly necessary but helps readability if script gets complex
          INTERNAL_STEP_ID="format_script"

          # Sub-step 1: Initialization and User Request Extraction
          echo "::group::Initialization and User Request Extraction"
          shopt -s extglob # Enable extended globbing for string trimming
          set -e           # Exit on error
          # set -x         # Uncomment for deep debugging

          ISSUE_OR_PR_NUMBER=${{ steps.set_context_ids.outputs.issue_number }}
          RAW_COMMENT_BODY="${{ github.event.comment.body }}"
          GITHUB_API_ARGS_VERBOSE=(-H "Accept: application/vnd.github+json")

          # Basic XML escaping function (using Perl)
          escape_xml() {
            perl -pe 's/&/\&/g; s/</\</g; s/>/\>/g; s/"/\"/g; s/'"'"'/\'/g;'
          }

          USER_REQUEST_BODY_RAW="${RAW_COMMENT_BODY#${COMMAND_PREFIX}}"
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW##*( )}"
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW%%*( )}"
          USER_REQUEST_BODY=$(echo "$USER_REQUEST_BODY_RAW" | escape_xml)
          echo "User request extracted and escaped: [${USER_REQUEST_BODY:0:100}...]"
          echo "::endgroup::"

          # Sub-step 2: Determine Context Type
          echo "::group::Determine Context Type"
          CONTEXT_TYPE="issue" # Default
          echo "Attempting to detect context for number: $ISSUE_OR_PR_NUMBER in repo $REPO"
          if gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER" --jq .url > /dev/null 2>&1; then
             CONTEXT_TYPE="pr"
             echo "Successfully queried PR API endpoint. Context determined as: PR"
          else
             EXIT_CODE=$?
             echo "Query to PR API endpoint failed (Exit Code: $EXIT_CODE). Assuming context is: Issue"
             # Optional confirmation check
             if ! gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/issues/$ISSUE_OR_PR_NUMBER" --jq .url > /dev/null 2>&1; then
                 ISSUE_EXIT_CODE=$?
                 echo "::warning::Query to Issue API endpoint also failed (Exit Code: $ISSUE_EXIT_CODE). Cannot definitively confirm context. Proceeding as Issue, but check permissions/number validity."
             fi
             CONTEXT_TYPE="issue" # Ensure it's set to issue if PR check failed
          fi
          echo "Final Context Type: $CONTEXT_TYPE"
          # Store for final output setting later
          FINAL_CONTEXT_TYPE=$CONTEXT_TYPE
          echo "::endgroup::"

          # Sub-step 3: Fetch Base Comments
          echo "::group::Fetch Base Comments"
          COMMENTS_XML=""
          echo "Fetching standard comments JSON for $CONTEXT_TYPE #$ISSUE_OR_PR_NUMBER..."
          STD_COMMENTS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/issues/$ISSUE_OR_PR_NUMBER/comments" --paginate)
          STD_COMMENTS_EXIT_CODE=$?
          if [[ $STD_COMMENTS_EXIT_CODE -ne 0 ]]; then
              echo "::warning::Failed to fetch standard comments (exit code $STD_COMMENTS_EXIT_CODE)."
          elif echo "$STD_COMMENTS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
              echo "Processing standard comments..."
              while IFS=$'\t' read -r login created_at body; do
                  escaped_login=$(echo "$login" | escape_xml) && escaped_body=$(echo "$body" | escape_xml)
                  COMMENTS_XML="${COMMENTS_XML}<comment type=\"issue\"><author>$escaped_login</author><timestamp>$created_at</timestamp><content>$escaped_body</content></comment>"
              done < <(echo "$STD_COMMENTS_JSON" | jq -r '.[] | [.user.login // "unknown", .created_at // "N/A", .body // ""] | @tsv')
              echo "Finished processing standard comments. XML length: ${#COMMENTS_XML}"
          else
              echo "::warning::API call for standard comments succeeded but did not return a valid JSON array. Response (first 500 chars):" && echo "$STD_COMMENTS_JSON" | head -c 500
          fi
          echo "::endgroup::"

          # Sub-step 4: Fetch Context-Specific Data & Build XML
          echo "::group::Fetch Context-Specific Data"
          CONTEXT_DETAILS_XML=""
          DIFF_XML=""
          PROMPT_INSTRUCTION=""

          if [[ "$FINAL_CONTEXT_TYPE" == "pr" ]]; then
            echo "Fetching PR details, diff, review comments, and reviews..."
            PR_DATA=$(gh pr view $ISSUE_OR_PR_NUMBER --json title,body --repo ${REPO} 2> pr_view_error.log || echo 'FETCH_FAILED')
            if [[ "$PR_DATA" == "FETCH_FAILED" ]]; then echo "::warning::Failed to fetch PR details. Error log:" && cat pr_view_error.log; PR_TITLE="Error"; PR_BODY="Error"; else PR_TITLE=$(echo "$PR_DATA" | jq -r .title | escape_xml) && PR_BODY=$(echo "$PR_DATA" | jq -r .body | escape_xml); fi
            PR_DIFF=$(gh pr diff $ISSUE_OR_PR_NUMBER --repo ${REPO} 2> pr_diff_error.log || echo "FETCH_FAILED")
            if [[ "$PR_DIFF" == "FETCH_FAILED" ]]; then echo "::warning::Failed to fetch PR diff. Error log:" && cat pr_diff_error.log; ESCAPED_PR_DIFF="<!-- Error fetching diff -->"; else ESCAPED_PR_DIFF=$(echo "$PR_DIFF" | escape_xml); fi
            CONTEXT_DETAILS_XML="<details><title>$PR_TITLE</title><body>$PR_BODY</body></details>"
            DIFF_XML="<diff>$ESCAPED_PR_DIFF</diff>"

            echo "Fetching PR review comments (diff comments)..."
            REVIEW_COMMENTS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER/comments" --paginate)
            REVIEW_COMMENTS_EXIT_CODE=$?
            if [[ $REVIEW_COMMENTS_EXIT_CODE -ne 0 ]]; then echo "::warning::Failed to fetch PR review comments (exit code $REVIEW_COMMENTS_EXIT_CODE).";
            elif echo "$REVIEW_COMMENTS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
                echo "Processing PR review comments..."
                while IFS=$'\t' read -r login created_at body path diff_hunk line; do
                    escaped_login=$(echo "$login" | escape_xml) && escaped_body=$(echo "$body" | escape_xml) && escaped_path=$(echo "$path" | escape_xml) && escaped_diff_hunk=$(echo "$diff_hunk" | escape_xml)
                    COMMENTS_XML="${COMMENTS_XML}<comment type=\"review_comment\" file=\"$escaped_path\" line=\"$line\"><author>$escaped_login</author><timestamp>$created_at</timestamp><diff_hunk>$escaped_diff_hunk</diff_hunk><content>$escaped_body</content></comment>"
                done < <(echo "$REVIEW_COMMENTS_JSON" | jq -r '.[] | [.user.login // "unknown", .created_at // "N/A", .body // "", .path // "unknown", .diff_hunk // "", (.line // .original_line // "N/A")] | @tsv')
                echo "Finished processing review comments. XML length: ${#COMMENTS_XML}"
            else echo "::warning::API call for review comments succeeded but not a valid JSON array. Response (first 500):" && echo "$REVIEW_COMMENTS_JSON" | head -c 500; fi

            echo "Fetching PR reviews..."
            REVIEWS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER/reviews" --paginate)
            REVIEWS_EXIT_CODE=$?
            if [[ $REVIEWS_EXIT_CODE -ne 0 ]]; then echo "::warning::Failed to fetch PR reviews (exit code $REVIEWS_EXIT_CODE)." ;
            elif echo "$REVIEWS_JSON" | jq -e '[.[] | select(.body != null and .body != "")] | type == "array"' > /dev/null 2>&1; then
                 echo "Processing PR review bodies..."
                 while IFS=$'\t' read -r login submitted_at body state; do
                     escaped_login=$(echo "$login" | escape_xml) && escaped_body=$(echo "$body" | escape_xml) && escaped_state=$(echo "$state" | escape_xml)
                     COMMENTS_XML="${COMMENTS_XML}<comment type=\"review_body\" state=\"$escaped_state\"><author>$escaped_login</author><timestamp>$submitted_at</timestamp><content>$escaped_body</content></comment>"
                 done < <(echo "$REVIEWS_JSON" | jq -r '.[] | select(.body != null and .body != "") | [.user.login // "unknown", .submitted_at // "N/A", .body, .state // "N/A"] | @tsv')
                 echo "Finished processing review bodies. XML length: ${#COMMENTS_XML}"
            else echo "::warning::API call for reviews succeeded, but no valid review bodies/response not JSON array. Response (first 500):" && echo "$REVIEWS_JSON" | head -c 500; fi

            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Pull Request..." # Shortened for brevity

          elif [[ "$FINAL_CONTEXT_TYPE" == "issue" ]]; then
            echo "Fetching Issue details..."
            ISSUE_DATA=$(gh issue view $ISSUE_OR_PR_NUMBER --json title,body --repo ${REPO} 2> issue_view_error.log || echo 'FETCH_FAILED')
             if [[ "$ISSUE_DATA" == "FETCH_FAILED" ]]; then echo "::warning::Failed to fetch Issue details. Error log:" && cat issue_view_error.log; ISSUE_TITLE="Error"; ISSUE_BODY="Error"; else ISSUE_TITLE=$(echo "$ISSUE_DATA" | jq -r .title | escape_xml) && ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r .body | escape_xml); fi
            CONTEXT_DETAILS_XML="<details><title>$ISSUE_TITLE</title><body>$ISSUE_BODY</body></details>"
            DIFF_XML=""
            PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Issue..." # Shortened for brevity
          fi
          echo "::endgroup::"

          # Sub-step 5: Assemble Final Prompt
          echo "::group::Assemble Final Prompt"
          FORMATTED_PROMPT="<github_context type=\"$FINAL_CONTEXT_TYPE\" number=\"$ISSUE_OR_PR_NUMBER\">
            ${CONTEXT_DETAILS_XML}
            ${DIFF_XML}
            <comments>
            ${COMMENTS_XML}
            </comments>
            <user_request author=\"${{ github.event.comment.user.login }}\" timestamp=\"${{ github.event.comment.created_at }}\">${USER_REQUEST_BODY}</user_request>
            </github_context>

            ${PROMPT_INSTRUCTION}"

          if [ ${#FORMATTED_PROMPT} -lt 200 ]; then echo "::warning::Formatted prompt seems short."; fi
          echo "Final prompt assembled. Length: ${#FORMATTED_PROMPT}"

          # Write prompt to temporary file
          echo "$FORMATTED_PROMPT" > formatted_prompt.txt
          PROMPT_FILENAME="formatted_prompt.txt"
          echo "Prompt written to $PROMPT_FILENAME"

          # CORRECTED: Set outputs using $GITHUB_OUTPUT
          echo "Setting step outputs..."
          echo "context_type_value=${FINAL_CONTEXT_TYPE}" >> $GITHUB_OUTPUT
          echo "prompt_file_path=${PROMPT_FILENAME}" >> $GITHUB_OUTPUT
          echo "Outputs set: context_type=${FINAL_CONTEXT_TYPE}, prompt_file_path=${PROMPT_FILENAME}"

          echo "::endgroup::"

      - name: Read Formatted Prompt from File
        id: read_prompt_file
        run: |
          # CORRECTED: Use the output name defined in the previous step's `outputs:` block
          PROMPT_FILE="${{ steps.format.outputs.formatted_prompt_file }}"
          if [[ -f "$PROMPT_FILE" ]]; then
            echo "Reading prompt from $PROMPT_FILE"
            {
              echo "formatted_prompt<<EOF_PROMPT_MARKER"
              cat "$PROMPT_FILE"
              echo "EOF_PROMPT_MARKER"
            } >> "$GITHUB_OUTPUT"
            echo "Prompt successfully read and set to output."
          else
            echo "::error::Formatted prompt file '$PROMPT_FILE' not found."
            echo "formatted_prompt=" >> "$GITHUB_OUTPUT" # Set empty output on error
            exit 1
          fi

      - name: Determine probe-chat Command
        id: determine_command
        run: |
          CMD="${{ secrets.PROBE_CHAT_COMMAND || inputs.default_probe_chat_command }}"
          echo "Using probe-chat command: $CMD"
          echo "command=$CMD" >> $GITHUB_OUTPUT

      - name: Run probe-chat
        id: probe
        env:
          PROBE_PROMPT: ${{ steps.read_prompt_file.outputs.formatted_prompt }}
          # Pass API keys etc...
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          # ... other secrets/env vars ...
        run: |
          set -o pipefail
          PROMPT="$PROBE_PROMPT"
          COMMAND_TO_RUN='${{ steps.determine_command.outputs.command }}'
          RESPONSE_FILE="response.txt"
          ERROR_LOG="error.log"

          if [ -z "$PROMPT" ]; then
            echo "::error::Prompt environment variable is empty. Check 'read_prompt_file' step."
            echo "ðŸ¤– **Error:** Failed to prepare the AI prompt content (prompt was empty)." > "$RESPONSE_FILE"
            exit 1
          fi

          echo "Running probe-chat..."
          echo "--- Start AI Prompt Snippet ---"
          printf "%.500s\n...\n%s\n" "$PROMPT" "${PROMPT: -100}"
          echo "--- End AI Prompt Snippet ---"
          echo "Command: $COMMAND_TO_RUN"

          bash -c "echo \"\$PROMPT\" | $COMMAND_TO_RUN" > "$RESPONSE_FILE" 2> "$ERROR_LOG"
          EXIT_CODE=$?

          if [ $EXIT_CODE -ne 0 ]; then
             echo "::error::probe-chat command failed with exit code $EXIT_CODE."
             if [ -s "$ERROR_LOG" ]; then echo "--- stderr ---"; cat "$ERROR_LOG"; echo "--- end stderr ---"; fi
             # Ensure error message for next step if response is empty
             if [ ! -s "$RESPONSE_FILE" ]; then
               echo "ðŸ¤– **Error:** The AI command failed (Exit code: $EXIT_CODE). Check Action logs." > "$RESPONSE_FILE"
             fi
             exit $EXIT_CODE
          fi

          echo "probe-chat command finished successfully."
          if [ ! -s "$RESPONSE_FILE" ]; then
            echo "::warning::probe-chat succeeded but produced an empty response file."
            echo "ðŸ¤– Processing finished successfully, but no response content was generated by the AI." > "$RESPONSE_FILE"
          fi

      - name: Read Response or Error and Format Output
        if: always()
        id: read_response
        env:
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
        run: |
          RESPONSE_CONTENT=$(cat response.txt 2>/dev/null || echo "")
          ERROR_LOG_CONTENT=$(cat error.log 2>/dev/null || echo "")
          FINAL_BODY=""

          FOOTER_TEMPLATE="\n\n-----\n*Tip: Start your comment with \`%s <your request>\`.*\n*Built by [probe](https://probeai.dev)*"
          printf -v FOOTER "$FOOTER_TEMPLATE" "$COMMAND_PREFIX"

          if [[ "${{ steps.probe.outcome }}" == "success" ]]; then
              if [[ -n "${RESPONSE_CONTENT// }" ]]; then
                  FINAL_BODY="${RESPONSE_CONTENT}${FOOTER}"
              else # Should have default message from probe step now
                  FINAL_BODY="ðŸ¤– Processing finished successfully, but the AI response was empty.${FOOTER}"
              fi
          else # Failure
              ERROR_MESSAGE="ðŸ¤– **Error:** The AI interaction failed."
              # Check specific failure points
              if [[ "${{ steps.format.outcome }}" == "failure" ]] || [[ "${{ steps.read_prompt_file.outcome }}" == "failure" ]]; then
                 ERROR_MESSAGE="ðŸ¤– **Error:** Processing failed during context preparation or prompt reading. Check Action logs."
              # Check if probe step wrote an error to response.txt
              elif [[ -n "${RESPONSE_CONTENT// }" ]] && echo "$RESPONSE_CONTENT" | grep -q "ðŸ¤– \*\*Error:\*\*" ; then
                  ERROR_MESSAGE="${RESPONSE_CONTENT}" # Use the explicit error from response.txt
              # Check if probe step captured stderr
              elif [[ -n "${ERROR_LOG_CONTENT// }" ]]; then
                  ERROR_MESSAGE="${ERROR_MESSAGE}\n\n**Details (from stderr):**\n\`\`\`\n$(cat error.log)\n\`\`\`"
              else
                  ERROR_MESSAGE="${ERROR_MESSAGE} No specific error details captured. Check 'Run probe-chat' step logs (outcome: ${{ steps.probe.outcome }})."
              fi
              FINAL_BODY="${ERROR_MESSAGE}${FOOTER}"
          fi

          echo "Final response body prepared. Length: ${#FINAL_BODY}"
          echo "response<<EOF_RESPONSE_MARKER" >> $GITHUB_OUTPUT
          echo "$FINAL_BODY" >> $GITHUB_OUTPUT
          echo "EOF_RESPONSE_MARKER" >> $GITHUB_OUTPUT

  post_response:
    if: needs.process_comment.result != 'skipped'
    runs-on: ubuntu-latest
    needs: [process_comment]
    steps:
      - name: Post Response Comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          issue-number: ${{ needs.process_comment.outputs.issue_number }}
          body: ${{ needs.process_comment.outputs.response_body }}
          reactions: ${{ needs.process_comment.outputs.probe_succeeded == 'true' && '+1' || '-1' }}

# </gh>
