# <gh>
name: Probe chat Github Action

on:
  workflow_call:
    inputs:
      command_prefix:
        description: "The prefix required on comments to trigger the AI (e.g., /probe, /ai, etc)"
        default: "/probe"
        required: true
        type: string
      default_probe_chat_command:
        description: "The default probe-chat command if PROBE_CHAT_COMMAND secret is not set"
        required: false
        default: "npx -y @buger/probe-chat@latest"
        type: string
      git_user_name:
        description: "Git user name for commits (default: GitHub Actions)"
        required: false
        type: string
        default: "github-actions[bot]"
      git_user_email:
        description: "Git user email for commits (default: GitHub Actions bot email)"
        required: false
        type: string
        default: "41898282+github-actions[bot]@users.noreply.github.com"
      prompt:
        description: "Custom prompt to use (values: architect, code-review, support, path to a file, or arbitrary string)"
        required: false
        type: string
      allow_edit:
        description: "Enable the implement tool for editing files"
        required: false
        type: boolean
        default: false
    secrets:
      PROBE_CHAT_COMMAND:
        required: false
        description: "Optional command for probe chat"
      ANTHROPIC_API_KEY:
        required: false
        description: "API key for Anthropic service"
      OPENAI_API_KEY:
        required: false
        description: "API key for OpenAI service"
      GOOGLE_API_KEY:
        required: false
        description: "API key for Google service"
      ANTHROPIC_API_URL:
        required: false
        description: "Custom API URL for Anthropic service"
      OPENAI_API_URL:
        required: false
        description: "Custom API URL for OpenAI service"
      GOOGLE_API_URL:
        required: false
        description: "Custom API URL for Google service"
      LLM_BASE_URL:
        required: false
        description: "Base URL for the LLM service"
      MODEL_NAME:
        required: false
        description: "Name of the model to use"
      FORCE_PROVIDER:
        required: false
        description: "Force the use of a specific provider"

jobs:
  process_comment:
    runs-on: ubuntu-latest
    # Only run on issue comments that are not from bots and contain the command prefix
    if: github.event_name == 'issue_comment' && !contains(github.event.comment.user.login, '[bot]') && contains(github.event.comment.body, inputs.command_prefix)
    outputs:
      response_body: ${{ steps.read_response.outputs.response }}
      issue_number: ${{ steps.set_context_ids.outputs.issue_number }}
      probe_succeeded: ${{ steps.probe.outcome == 'success' }}
      context_type: ${{ steps.format.outputs.context_type }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for git diff base/head comparison

      - name: Install jq, perl and Verify gh
        run: |
          sudo apt-get update && sudo apt-get install -y jq perl --no-install-recommends
          gh --version

      # --- Detect Languages ---
      - name: Detect Project Languages
        id: detect_languages
        run: |
          # Initialize flags
          NODE_FOUND=false
          GO_FOUND=false
          RUST_FOUND=false
          PYTHON_FOUND=false

          # Check for dependency files
          if [ -f "package.json" ]; then
            echo "Detected Node.js (package.json)"
            NODE_FOUND=true
          fi
          if [ -f "go.mod" ]; then
            echo "Detected Go (go.mod)"
            GO_FOUND=true
          fi
          if [ -f "Cargo.toml" ]; then
            echo "Detected Rust (Cargo.toml)"
            RUST_FOUND=true
          fi
          if [ -f "requirements.txt" ]; then
            echo "Detected Python (requirements.txt)"
            PYTHON_FOUND=true
          fi

          # Set outputs for use in later steps
          echo "node_found=$NODE_FOUND" >> $GITHUB_OUTPUT
          echo "go_found=$GO_FOUND" >> $GITHUB_OUTPUT
          echo "rust_found=$RUST_FOUND" >> $GITHUB_OUTPUT
          echo "python_found=$PYTHON_FOUND" >> $GITHUB_OUTPUT

      # --- Node.js Setup and Caching (Conditional) ---
      - name: Set up Node.js (Project Deps)
        if: steps.detect_languages.outputs.node_found == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm" # Caches ~/.npm based on package-lock.json

      # --- Go Setup and Caching (Conditional) ---
      - name: Set up Go (Project Deps)
        if: steps.detect_languages.outputs.go_found == 'true'
        uses: actions/setup-go@v5
        with:
          go-version: "1.21"
          # Go caching is automatic in setup-go@v3.2+

      # --- Rust Setup and Caching (Conditional) ---
      - name: Set up Rust (Project Deps)
        if: steps.detect_languages.outputs.rust_found == 'true'
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Cache Rust dependencies (Project Deps)
        if: steps.detect_languages.outputs.rust_found == 'true'
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      # --- Python Setup and Caching (Conditional) ---
      - name: Set up Python (Project Deps)
        if: steps.detect_languages.outputs.python_found == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"
          cache: "pip"
          cache-dependency-path: "**/requirements.txt"

      # --- Install Project Dependencies (Conditional) ---
      - name: Install Project Dependencies
        run: |
          # Node.js - Check for package.json
          if [ "${{ steps.detect_languages.outputs.node_found }}" == "true" ]; then
            echo "Found package.json - Installing Node.js dependencies..."
            npm install || echo "::warning::npm install failed, continuing..."
          fi

          # Go - Check for go.mod
          if [ "${{ steps.detect_languages.outputs.go_found }}" == "true" ]; then
            echo "Found go.mod - Installing Go dependencies..."
            go mod download || echo "::warning::go mod download failed, continuing..."
          fi

          # Rust - Check for Cargo.toml
          if [ "${{ steps.detect_languages.outputs.rust_found }}" == "true" ]; then
            echo "Found Cargo.toml - Building Rust dependencies..."
            cargo build --quiet || echo "::warning::cargo build failed, continuing..."
          fi

          # Python - Check for requirements.txt
          if [ "${{ steps.detect_languages.outputs.python_found }}" == "true" ]; then
            echo "Found requirements.txt - Installing Python dependencies..."
            pip install -r requirements.txt || echo "::warning::pip install failed, continuing..."
          fi

      # --- Node.js setup for probe-chat command itself ---
      - name: Set up Node.js (for probe-chat command)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Set Issue Number and Comment ID Output
        id: set_context_ids
        run: |
          # Safety check: Ensure github.event context is as expected
          if [[ -z "${{ github.event.issue.number }}" || -z "${{ github.event.comment.id }}" ]]; then
            echo "::error::Could not get issue number or comment ID from event context."
            exit 1
          fi
          echo "issue_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          echo "comment_id=${{ github.event.comment.id }}" >> $GITHUB_OUTPUT
          echo "Context ID (Issue/PR Number): ${{ github.event.issue.number }}, Comment ID: ${{ github.event.comment.id }}"

      - name: Add 'eyes' reaction to comment
        id: add_reaction
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          COMMENT_ID: ${{ steps.set_context_ids.outputs.comment_id }}
        run: |
          echo "Adding ðŸ‘€ reaction to comment ID ${COMMENT_ID} in repo ${REPO}..."
          gh api --method POST -H "Accept: application/vnd.github+json" "/repos/${REPO}/issues/comments/${COMMENT_ID}/reactions" -f content='eyes' --silent || echo "::warning::Failed to add 'eyes' reaction."

      - name: Format - Initialize and Detect Context
        id: format_init
        env:
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
          REPO: ${{ github.repository }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Ensure gh uses the right token
        run: |
          echo "::group::Initialization and User Request Extraction"
          shopt -s extglob # Enable extended globbing for string manipulation
          set -e # Exit immediately if a command exits with a non-zero status.
          ISSUE_OR_PR_NUMBER=${{ steps.set_context_ids.outputs.issue_number }}
          RAW_COMMENT_BODY="${{ github.event.comment.body }}"

          # Trim prefix and leading/trailing whitespace from user request
          USER_REQUEST_BODY_RAW="${RAW_COMMENT_BODY#${COMMAND_PREFIX}}"
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW##*( )}"
          USER_REQUEST_BODY_RAW="${USER_REQUEST_BODY_RAW%%*( )}"
          # Use EOF markers for multi-line env var
          echo "USER_REQUEST_BODY<<EOF_USER_REQUEST" >> $GITHUB_ENV
          echo "$USER_REQUEST_BODY_RAW" >> $GITHUB_ENV
          echo "EOF_USER_REQUEST" >> $GITHUB_ENV
          echo "User request extracted: [${USER_REQUEST_BODY_RAW:0:100}...]"
          echo "::endgroup::"

          echo "::group::Determine Context Type"
          CONTEXT_TYPE="unknown" # Start with unknown

          echo "Detecting context for #${ISSUE_OR_PR_NUMBER} in $REPO"

          # Try viewing as PR first
          echo "Checking if #${ISSUE_OR_PR_NUMBER} is a Pull Request using 'gh pr view'..."
          # Use `--json id` as a lightweight check for existence
          set +e # Temporarily disable exit on error for the check
          gh pr view "$ISSUE_OR_PR_NUMBER" --repo "$REPO" --json id > /dev/null 2>&1
          PR_VIEW_EXIT_CODE=$?
          set -e # Re-enable exit on error

          if [[ $PR_VIEW_EXIT_CODE -eq 0 ]]; then
              CONTEXT_TYPE="pr"
              echo "Context detected: PR (gh pr view succeeded)"
          else
              echo "'gh pr view' failed or returned no JSON (exit code $PR_VIEW_EXIT_CODE). Checking if it's an Issue..."

              # Try viewing as Issue ONLY if PR view failed
              set +e # Temporarily disable exit on error for the check
              gh issue view "$ISSUE_OR_PR_NUMBER" --repo "$REPO" --json id > /dev/null 2>&1
              ISSUE_VIEW_EXIT_CODE=$?
              set -e # Re-enable exit on error

              if [[ $ISSUE_VIEW_EXIT_CODE -eq 0 ]]; then
                  CONTEXT_TYPE="issue"
                  echo "Context confirmed: Issue (gh issue view succeeded)"
              else
                  # BOTH views failed. This is problematic.
                  echo "::error::Failed to determine context for #${ISSUE_OR_PR_NUMBER}. 'gh pr view' failed (code $PR_VIEW_EXIT_CODE) AND 'gh issue view' failed (code $ISSUE_VIEW_EXIT_CODE)."
                  echo "::error::Please check the GITHUB_TOKEN permissions (needs issues:read and pull-requests:read) and if the item #${ISSUE_OR_PR_NUMBER} actually exists and is accessible."
                  # Defaulting to 'issue' as a fallback, consistent with original behavior but with better error logging
                  CONTEXT_TYPE="issue"
                  echo "::warning::Proceeding with 'issue' context as a fallback despite view errors."
               fi
          fi

          if [[ "$CONTEXT_TYPE" == "unknown" ]]; then
            # Safeguard - should not be reached with the logic above unless something unexpected happens
            echo "::error::Context type could not be determined after checks. Defaulting to 'issue'."
            CONTEXT_TYPE="issue"
          fi

          echo "Final Context Type: $CONTEXT_TYPE"
          echo "FINAL_CONTEXT_TYPE=$CONTEXT_TYPE" >> $GITHUB_ENV
          echo "ISSUE_OR_PR_NUMBER=$ISSUE_OR_PR_NUMBER" >> $GITHUB_ENV # Pass number too
          echo "::endgroup::"

      - name: Format - Fetch Standard Comments
        id: format_fetch_comments
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          # Read vars set by previous step
          ISSUE_OR_PR_NUMBER: ${{ env.ISSUE_OR_PR_NUMBER }}
        run: |
          echo "::group::Fetch Standard Comments"
          set -e
          GITHUB_API_ARGS_VERBOSE=(-H "Accept: application/vnd.github+json")
          COMMENTS_XML="" # Initialize here

          echo "Fetching standard comments for #${ISSUE_OR_PR_NUMBER}..."
          STD_COMMENTS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/issues/$ISSUE_OR_PR_NUMBER/comments" --paginate || echo "FETCH_FAILED")

          if [[ "$STD_COMMENTS_JSON" == "FETCH_FAILED" || -z "$STD_COMMENTS_JSON" ]]; then
              echo "::warning::Failed to fetch standard comments JSON or received empty response."
          else
              if echo "$STD_COMMENTS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
                  TSV_OUTPUT=$(echo "$STD_COMMENTS_JSON" | jq -r '.[] | select(.body != null) | [.user.login // "unknown", .created_at // "N/A", .body] | @tsv' 2> jq_std_error.log)
                  JQ_EXIT_CODE=$?
                  if [[ $JQ_EXIT_CODE -eq 0 ]]; then
                      if [[ -n "$TSV_OUTPUT" ]]; then
                          echo "Processing standard comments..."
                          while IFS=$'\t' read -r login created_at body; do
                              [[ -n "$login" || -n "$created_at" || -n "$body" ]] || continue
                              COMMENTS_XML="${COMMENTS_XML}<comment type=\"issue\"><author>$login</author><timestamp>$created_at</timestamp><content><![CDATA[$body]]></content></comment>"
                          done <<< "$TSV_OUTPUT"
                      else
                          echo "Standard comments JSON valid, but no comments found or jq produced empty TSV."
                      fi
                  else
                      echo "::warning::jq failed processing standard comments (exit code $JQ_EXIT_CODE). Error log:"
                      cat jq_std_error.log
                  fi
              else
                  echo "::warning::Fetched standard comments data is not a valid JSON array."
              fi
          fi
          echo "Standard comments processed. Current XML length: ${#COMMENTS_XML}"

          # Save multi-line COMMENTS_XML to env
          echo "COMMENTS_XML<<EOF_COMMENTS_XML" >> $GITHUB_ENV
          echo "$COMMENTS_XML" >> $GITHUB_ENV
          echo "EOF_COMMENTS_XML" >> $GITHUB_ENV
          echo "::endgroup::"

      - name: Format - Fetch PR Details (Title, Body, SHAs)
        id: format_pr_details
        # Only run this step if context is PR
        if: env.FINAL_CONTEXT_TYPE == 'pr'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          ISSUE_OR_PR_NUMBER: ${{ env.ISSUE_OR_PR_NUMBER }}
        run: |
          echo "::group::Fetch PR Details (Title, Body, SHAs)"
          set -e
          echo "Fetching PR specific data for #${ISSUE_OR_PR_NUMBER}..."

          # --- Fetch Base/Head SHAs ---
          echo "Fetching PR base and head SHAs..."
          # This part seems okay based on the logs showing SHAs were fetched
          PR_REFS_JSON=$(gh pr view "$ISSUE_OR_PR_NUMBER" --json baseRefOid,headRefOid --repo "${REPO}" 2> pr_refs_stderr.log || echo "FETCH_FAILED")
          BASE_SHA=""
          HEAD_SHA=""
          if [[ "$PR_REFS_JSON" == "FETCH_FAILED" ]]; then
            echo "::error::Failed to fetch PR SHAs."
            cat pr_refs_stderr.log >&2
            # Allow script to continue, handle missing SHAs in diff step
          else
            BASE_SHA=$(echo "$PR_REFS_JSON" | jq -r .baseRefOid)
            HEAD_SHA=$(echo "$PR_REFS_JSON" | jq -r .headRefOid)
            if [[ -z "$BASE_SHA" || "$BASE_SHA" == "null" || -z "$HEAD_SHA" || "$HEAD_SHA" == "null" ]]; then
               echo "::error::Could not extract valid base/head SHAs from JSON: $PR_REFS_JSON"
               BASE_SHA=""
               HEAD_SHA=""
            else
               echo "Base SHA: $BASE_SHA"
               echo "Head SHA: $HEAD_SHA"
            fi
          fi
          echo "BASE_SHA=$BASE_SHA" >> $GITHUB_ENV
          echo "HEAD_SHA=$HEAD_SHA" >> $GITHUB_ENV

          # --- Fetch PR Title/Body ---
          echo "Fetching PR Title and Body..." # Added echo for clarity
          PR_DATA=$(gh pr view "$ISSUE_OR_PR_NUMBER" --json title,body --repo "${REPO}" 2>/dev/null || echo 'FETCH_FAILED')
          PR_TITLE_DEFAULT="Error fetching title" # Define defaults
          PR_BODY_DEFAULT="Error fetching body"

          if [[ "$PR_DATA" == "FETCH_FAILED" ]]; then
            echo "::warning::Failed PR details fetch (gh pr view command failed)."
            PR_TITLE="$PR_TITLE_DEFAULT"
            PR_BODY="$PR_BODY_DEFAULT"
          else
            echo "Parsing PR Title and Body..."
            # Corrected jq syntax: // fallback operator is INSIDE the quotes
            PR_TITLE=$(echo "$PR_DATA" | jq -r --arg default "$PR_TITLE_DEFAULT" '.title // $default')
            PR_BODY=$(echo "$PR_DATA" | jq -r --arg default "$PR_BODY_DEFAULT" '.body // $default')

            # Optional: Check if jq failed for some other reason (e.g., invalid JSON) although unlikely here
            # Add checks on JQ_EXIT_CODE if needed for robustness
          fi

          # Save multi-line title/body to env
          echo "PR_TITLE<<EOF_PR_TITLE" >> $GITHUB_ENV
          echo "$PR_TITLE" >> $GITHUB_ENV
          echo "EOF_PR_TITLE" >> $GITHUB_ENV
          echo "PR_BODY<<EOF_PR_BODY" >> $GITHUB_ENV
          echo "$PR_BODY" >> $GITHUB_ENV
          echo "EOF_PR_BODY" >> $GITHUB_ENV
          echo "::endgroup::"

      - name: Format - Fetch & Filter PR Diff
        id: format_pr_diff
        # Only run this step if context is PR
        if: env.FINAL_CONTEXT_TYPE == 'pr'
        env:
          # Read SHAs set by previous step
          BASE_SHA: ${{ env.BASE_SHA }}
          HEAD_SHA: ${{ env.HEAD_SHA }}
          # Constants needed for filtering
        run: |
          echo "::group::Fetch & Filter PR Diff"
          set -e
          FILTERED_PR_DIFF="<!-- Diff generation skipped or failed -->" # Default value

          # Check if SHAs were obtained before attempting git diff
          if [[ -z "$BASE_SHA" || -z "$HEAD_SHA" ]]; then
              echo "::error::Cannot run git diff without valid base/head SHAs. Skipping diff generation."
              RAW_DIFF_CONTENT="FETCH_FAILED" # Signal failure
          else
              # Define allowed file patterns for git diff pathspec
              ALLOWED_PATTERNS=(
                  '*.go' '*.js' '*.ts' '*.jsx' '*.tsx' '*.rs' '*.java' '*.c' '*.h' '*.cpp' '*.hpp' '*.py'
                  '*.cs' '*.php' '*.rb' '*.swift' '*.kt' '*.kts' '*.scala' '*.sh' '*.pl' '*.pm' '*.lua' '*.sql'
                  '*.md' '*.yaml' '*.yml' '*.json'
                  'Dockerfile' 'Makefile' '.dockerignore' '.gitignore'
                  'go.mod' 'go.sum' 'package.json' 'package-lock.json' 'yarn.lock' 'pnpm-lock.yaml'
                  'requirements.txt' 'Pipfile' 'Pipfile.lock' 'pyproject.toml' 'poetry.lock'
                  'Cargo.toml' 'Cargo.lock' 'pom.xml' 'build.gradle' 'settings.gradle' 'build.gradle.kts' 'settings.gradle.kts'
                  'composer.json' 'composer.lock' 'Gemfile' 'Gemfile.lock'
                  '.*rc' '*.conf' '*.cfg' '*.ini' '*.toml' '*.properties'
                  'README.*' 'LICENSE*' 'CONTRIBUTING.*' 'CHANGELOG.*' '*.rst' '*.adoc'
              )
              RAW_DIFF_CONTENT=""
              GIT_DIFF_EXIT_CODE=1 # Default error

              echo "Running: git diff '${BASE_SHA}...${HEAD_SHA}' -- ${ALLOWED_PATTERNS[*]}"
              set +e # Temporarily disable exit on error for git diff
              git diff "${BASE_SHA}...${HEAD_SHA}" -- "${ALLOWED_PATTERNS[@]}" > raw_diff_output.txt 2> git_diff_stderr.log
              GIT_DIFF_EXIT_CODE=$?
              set -e # Re-enable exit on error
              RAW_DIFF_CONTENT=$(cat raw_diff_output.txt)

              if [[ $GIT_DIFF_EXIT_CODE -ne 0 ]]; then
                  echo "::warning::git diff command exited with code $GIT_DIFF_EXIT_CODE."
                  if [[ -s git_diff_stderr.log ]]; then echo "Stderr from git diff:"; cat git_diff_stderr.log; fi
              fi

              if [[ -z "$RAW_DIFF_CONTENT" ]]; then
                 if [[ $GIT_DIFF_EXIT_CODE -eq 0 || $GIT_DIFF_EXIT_CODE -eq 1 ]]; then
                   echo "git diff produced no output for the specified patterns."
                   FILTERED_PR_DIFF="<!-- No relevant file changes found for specified patterns -->"
                 else
                   echo "::error::git diff failed (Exit: $GIT_DIFF_EXIT_CODE) and produced no output."
                   RAW_DIFF_CONTENT="FETCH_FAILED" # Signal failure
                 fi
              else
                  echo "git diff successful. Raw diff size: ${#RAW_DIFF_CONTENT} bytes."
              fi
          fi # End SHA check

          # Proceed with Perl filtering only if git diff succeeded and produced content
          if [[ "$RAW_DIFF_CONTENT" != "FETCH_FAILED" && -n "$RAW_DIFF_CONTENT" ]]; then
              echo "Filtering suspected minified files..."
              set +e # Disable exit on error for the pipe
              # (Perl script remains the same as before)
              FILTERED_PR_DIFF_CONTENT=$(echo "$RAW_DIFF_CONTENT" | perl -ne '
                BEGIN { $chunk = ""; $print_chunk = 1; $max_len = 500; }
                if (/^diff --git a\/(.+)\s+b\/(.+)$/) {
                    print $chunk if $chunk ne "" && $print_chunk;
                    $chunk = $_; $print_chunk = 1; my $b_path = $2;
                    if ($b_path eq "/dev/null") { $print_chunk = 1; }
                    elsif ($b_path =~ m/\.(lock|sum|mod|toml|cfg|ini|properties|yaml|yml|json|md|rst|adoc|txt|conf)$/i ||
                           $b_path =~ m/(Makefile|Dockerfile|LICENSE|README|CONTRIBUTING|CHANGELOG)/i ||
                           $b_path =~ m/\.(gitignore|dockerignore|.*rc)$/ ) { $print_chunk = 1; }
                    elsif (! -e $b_path) { warn "Warning: File $b_path from diff not found at ./$b_path, including chunk."; $print_chunk = 1; }
                    else {
                         if (open my $fh, "<", $b_path) {
                             my $lines_read = 0;
                             while (my $line = <$fh>) {
                                 $lines_read++; chomp $line;
                                 if (length($line) > $max_len && $line !~ m{(https?://\S+|/\S+|[a-zA-Z0-9+/=]{20,}|d="M[\d\.,\sA-Za-z-]+"})}) {
                                     warn "Info: Filtering chunk for $b_path (line $lines_read length > $max_len)"; $print_chunk = 0; last;
                                 }
                                 last if $lines_read >= 3;
                             }
                             close $fh;
                         } else { warn "Warning: Could not open $b_path to check, including chunk."; $print_chunk = 1; }
                    }
                } else { $chunk .= $_; }
                END { print $chunk if $chunk ne "" && $print_chunk; }
              ' 2> filter_stderr.log)
              PERL_PIPE_STATUS=${PIPESTATUS[1]}
              set -e # Re-enable exit on error

              if [[ $PERL_PIPE_STATUS -ne 0 ]]; then echo "::warning::Perl filter script exited with status $PERL_PIPE_STATUS."; fi
              if [[ -s filter_stderr.log ]]; then echo "Perl filter script warnings/info:"; cat filter_stderr.log; fi

              if [[ -z "$FILTERED_PR_DIFF_CONTENT" ]] && [[ -n "$RAW_DIFF_CONTENT" ]]; then
                  echo "All diff chunks were filtered out by Perl script."
                  FILTERED_PR_DIFF="<!-- Diff contained only files filtered out by heuristic -->"
              elif [[ -z "$FILTERED_PR_DIFF_CONTENT" ]]; then
                  echo "Filtered diff is empty (remained empty after Perl filter)."
                  # Keep the message set previously based on git diff result
              else
                   echo "Perl filtering complete. Final diff size: ${#FILTERED_PR_DIFF_CONTENT} bytes."
                   FILTERED_PR_DIFF="$FILTERED_PR_DIFF_CONTENT" # Assign the successfully filtered content
              fi
          elif [[ "$RAW_DIFF_CONTENT" == "FETCH_FAILED" ]]; then
              FILTERED_PR_DIFF="<!-- Error fetching or generating diff -->"
          # else: FILTERED_PR_DIFF remains as set by the git diff check (e.g., no relevant changes)
          fi

          # Save final filtered diff (or error message) to env
          echo "FILTERED_PR_DIFF<<EOF_PR_DIFF" >> $GITHUB_ENV
          echo "$FILTERED_PR_DIFF" >> $GITHUB_ENV
          echo "EOF_PR_DIFF" >> $GITHUB_ENV
          echo "::endgroup::"

      - name: Format - Fetch PR Review Comments & Bodies
        id: format_pr_reviews
        # Only run this step if context is PR
        if: env.FINAL_CONTEXT_TYPE == 'pr'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          ISSUE_OR_PR_NUMBER: ${{ env.ISSUE_OR_PR_NUMBER }}
          # Read the comments XML from the earlier step
          COMMENTS_XML: ${{ env.COMMENTS_XML }}
        run: |
          echo "::group::Fetch PR Review Comments & Bodies"
          set -e
          GITHUB_API_ARGS_VERBOSE=(-H "Accept: application/vnd.github+json")
          # Initialize with comments from previous step
          CURRENT_COMMENTS_XML="$COMMENTS_XML"

          # --- PR Review Comments ---
          echo "Fetching PR review comments..."
          REVIEW_COMMENTS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER/comments" --paginate || echo "FETCH_FAILED")
          if [[ "$REVIEW_COMMENTS_JSON" == "FETCH_FAILED" || -z "$REVIEW_COMMENTS_JSON" ]]; then
              echo "::warning::Failed to fetch PR review comments JSON or received empty response."
          else
              if echo "$REVIEW_COMMENTS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
                  TSV_OUTPUT=$(echo "$REVIEW_COMMENTS_JSON" | jq -r '.[] | select(.body != null) | [.user.login // "unknown", .created_at // "N/A", .body, .path // "unknown", .diff_hunk // "", (.line // .original_line // "N/A")] | @tsv' 2> jq_rev_com_error.log)
                  JQ_EXIT_CODE=$?
                  if [[ $JQ_EXIT_CODE -eq 0 ]]; then
                       if [[ -n "$TSV_OUTPUT" ]]; then
                          echo "Processing review comments..."
                          while IFS=$'\t' read -r login created_at body path diff_hunk line; do
                             [[ -n "$login" || -n "$created_at" || -n "$body" ]] || continue
                             CURRENT_COMMENTS_XML="${CURRENT_COMMENTS_XML}<comment type=\"review_comment\" file=\"$path\" line=\"$line\"><author>$login</author><timestamp>$created_at</timestamp><diff_hunk><![CDATA[$diff_hunk]]></diff_hunk><content><![CDATA[$body]]></content></comment>"
                          done <<< "$TSV_OUTPUT"
                       else
                          echo "Review comments JSON valid, but no comments found or jq produced empty TSV."
                       fi
                  else
                       echo "::warning::jq failed processing review comments (exit code $JQ_EXIT_CODE). Error log:"
                       cat jq_rev_com_error.log
                  fi
              else
                   echo "::warning::Fetched review comments data is not a valid JSON array."
              fi
          fi
          echo "Review comments processed. Current XML length: ${#CURRENT_COMMENTS_XML}"

          # --- PR Reviews (Bodies) ---
          echo "Fetching PR reviews (bodies)..."
          REVIEWS_JSON=$(gh api "${GITHUB_API_ARGS_VERBOSE[@]}" "/repos/${REPO}/pulls/$ISSUE_OR_PR_NUMBER/reviews" --paginate || echo "FETCH_FAILED")
          if [[ "$REVIEWS_JSON" == "FETCH_FAILED" || -z "$REVIEWS_JSON" ]]; then
               echo "::warning::Failed to fetch PR reviews JSON or received empty response."
          else
               if echo "$REVIEWS_JSON" | jq -e '. | type == "array"' > /dev/null 2>&1; then
                   TSV_OUTPUT=$(echo "$REVIEWS_JSON" | jq -r '.[] | select(.body != null and .body != "") | [.user.login // "unknown", .submitted_at // "N/A", .body, .state // "N/A"] | @tsv' 2> jq_rev_error.log)
                   JQ_EXIT_CODE=$?
                   if [[ $JQ_EXIT_CODE -eq 0 ]]; then
                       if [[ -n "$TSV_OUTPUT" ]]; then
                           echo "Processing review bodies..."
                           while IFS=$'\t' read -r login submitted_at body state; do
                              [[ -n "$login" || -n "$submitted_at" || -n "$body" ]] || continue
                              CURRENT_COMMENTS_XML="${CURRENT_COMMENTS_XML}<comment type=\"review_body\" state=\"$state\"><author>$login</author><timestamp>$submitted_at</timestamp><content><![CDATA[$body]]></content></comment>"
                           done <<< "$TSV_OUTPUT"
                       else
                           echo "Review JSON valid, but no review bodies with content found or jq produced empty TSV."
                       fi
                   else
                        echo "::warning::jq failed processing review bodies (exit code $JQ_EXIT_CODE). Error log:"
                        cat jq_rev_error.log
                   fi
               else
                    echo "::warning::Fetched reviews data is not a valid JSON array."
               fi
          fi
          echo "Review bodies processed. Final XML length: ${#CURRENT_COMMENTS_XML}"

          # Save updated multi-line COMMENTS_XML back to env
          echo "COMMENTS_XML<<EOF_COMMENTS_XML_UPDATED" >> $GITHUB_ENV
          echo "$CURRENT_COMMENTS_XML" >> $GITHUB_ENV
          echo "EOF_COMMENTS_XML_UPDATED" >> $GITHUB_ENV
          echo "::endgroup::"

      - name: Format - Fetch Issue Details (Title, Body)
        id: format_issue_details
        # Only run this step if context is Issue
        if: env.FINAL_CONTEXT_TYPE == 'issue'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          ISSUE_OR_PR_NUMBER: ${{ env.ISSUE_OR_PR_NUMBER }}
        run: |
          echo "::group::Fetch Issue Details (Title, Body)"
          set -e
          echo "Fetching Issue specific data for #${ISSUE_OR_PR_NUMBER}..."
          ISSUE_DATA_JSON=$(gh issue view "$ISSUE_OR_PR_NUMBER" --json title,body --repo "${REPO}" 2>/dev/null || echo 'FETCH_FAILED')

          ISSUE_TITLE="Error fetching title"
          ISSUE_BODY="Error fetching body"

          if [[ "$ISSUE_DATA_JSON" != "FETCH_FAILED" && -n "$ISSUE_DATA_JSON" ]]; then
            echo "Issue data fetched successfully. Parsing title and body..."
            EXTRACTED_TITLE=$(printf "%s" "$ISSUE_DATA_JSON" | jq -e -r '.title // ""')
            JQ_TITLE_EXIT=$?
            if [[ $JQ_TITLE_EXIT -eq 0 && -n "$EXTRACTED_TITLE" ]]; then ISSUE_TITLE="$EXTRACTED_TITLE";
            elif [[ $JQ_TITLE_EXIT -eq 0 && -z "$EXTRACTED_TITLE" ]]; then echo "::debug::Issue title is null/empty."; ISSUE_TITLE="";
            else echo "::warning::jq failed to extract issue title (exit $JQ_TITLE_EXIT) or value was null."; fi

            EXTRACTED_BODY=$(printf "%s" "$ISSUE_DATA_JSON" | jq -e -r '.body // ""')
            JQ_BODY_EXIT=$?
            if [[ $JQ_BODY_EXIT -eq 0 && -n "$EXTRACTED_BODY" ]]; then ISSUE_BODY="$EXTRACTED_BODY";
            elif [[ $JQ_BODY_EXIT -eq 0 && -z "$EXTRACTED_BODY" ]]; then echo "::debug::Issue body is null/empty."; ISSUE_BODY="";
            else echo "::warning::jq failed to extract issue body (exit $JQ_BODY_EXIT) or value was null."; fi
          else
            echo "::warning::Failed Issue details fetch (gh command failed or returned empty)."
          fi

          # Save multi-line title/body to env
          echo "ISSUE_TITLE<<EOF_ISSUE_TITLE" >> $GITHUB_ENV
          echo "$ISSUE_TITLE" >> $GITHUB_ENV
          echo "EOF_ISSUE_TITLE" >> $GITHUB_ENV
          echo "ISSUE_BODY<<EOF_ISSUE_BODY" >> $GITHUB_ENV
          echo "$ISSUE_BODY" >> $GITHUB_ENV
          echo "EOF_ISSUE_BODY" >> $GITHUB_ENV
          echo "::endgroup::"

      - name: Format - Assemble Final Prompt
        id: format # Keep original ID for output mapping
        env:
          # Read all potentially set env vars
          FINAL_CONTEXT_TYPE: ${{ env.FINAL_CONTEXT_TYPE }}
          ISSUE_OR_PR_NUMBER: ${{ env.ISSUE_OR_PR_NUMBER }}
          USER_REQUEST_BODY: ${{ env.USER_REQUEST_BODY }}
          COMMENTS_XML: ${{ env.COMMENTS_XML }} # Use original if PR reviews didn't run/update
          UPDATED_COMMENTS_XML: ${{ env.COMMENTS_XML_UPDATED }} # Use this if PR reviews ran
          # PR specific
          PR_TITLE: ${{ env.PR_TITLE }}
          PR_BODY: ${{ env.PR_BODY }}
          FILTERED_PR_DIFF: ${{ env.FILTERED_PR_DIFF }}
          # Issue specific
          ISSUE_TITLE: ${{ env.ISSUE_TITLE }}
          ISSUE_BODY: ${{ env.ISSUE_BODY }}
        run: |
          echo "::group::Assemble Final Prompt & Set Outputs"
          set -e
          CONTEXT_DETAILS_XML=""
          DIFF_XML=""
          PROMPT_INSTRUCTION=""
          # Choose the correct comments XML based on whether PR reviews updated it
          FINAL_COMMENTS_XML="${UPDATED_COMMENTS_XML:-$COMMENTS_XML}"

          # Assemble context-specific parts
          if [[ "$FINAL_CONTEXT_TYPE" == "pr" ]]; then
              CONTEXT_DETAILS_XML="<details><title><![CDATA[$PR_TITLE]]></title><body><![CDATA[$PR_BODY]]></body></details>"
              DIFF_XML="<diff><![CDATA[$FILTERED_PR_DIFF]]></diff>"
              PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Pull Request..." # Keep your instruction
          elif [[ "$FINAL_CONTEXT_TYPE" == "issue" ]]; then
              CONTEXT_DETAILS_XML="<details><title><![CDATA[$ISSUE_TITLE]]></title><body><![CDATA[$ISSUE_BODY]]></body></details>"
              DIFF_XML="" # No diff for issues
              PROMPT_INSTRUCTION="You are an AI assistant analyzing a GitHub Issue..." # Keep your instruction
          fi

          USER_LOGIN="${{ github.event.comment.user.login }}"
          TIMESTAMP="${{ github.event.comment.created_at }}"

          # Assemble the final prompt
          FORMATTED_PROMPT="<github_context type=\"$FINAL_CONTEXT_TYPE\" number=\"$ISSUE_OR_PR_NUMBER\">
            ${CONTEXT_DETAILS_XML}
            ${DIFF_XML}
            <comments>${FINAL_COMMENTS_XML}</comments>
            <user_request author=\"${USER_LOGIN}\" timestamp=\"${TIMESTAMP}\"><![CDATA[${USER_REQUEST_BODY}]]></user_request>
            </github_context>
            
            <instructions><![CDATA[${PROMPT_INSTRUCTION}]]></instructions>"

          if [ ${#FORMATTED_PROMPT} -lt 200 ]; then
            echo "::warning::Formatted prompt seems very short (${#FORMATTED_PROMPT} bytes)."
          fi
          echo "Final prompt assembled. Length: ${#FORMATTED_PROMPT} bytes."

          PROMPT_FILENAME="formatted_prompt.txt"
          echo "$FORMATTED_PROMPT" > "$PROMPT_FILENAME"
          echo "Prompt written to $PROMPT_FILENAME"

          echo "Setting step outputs..."
          echo "context_type=${FINAL_CONTEXT_TYPE}" >> "$GITHUB_OUTPUT"
          echo "formatted_prompt_file=${PROMPT_FILENAME}" >> "$GITHUB_OUTPUT"
          echo "Outputs set."
          echo "::endgroup::"

      - name: Determine probe-chat command
        id: determine_command
        env:
          PROBE_CHAT_COMMAND_SECRET: ${{ secrets.PROBE_CHAT_COMMAND }}
        run: |
          COMMAND_VAR=""
          if [[ -n "${PROBE_CHAT_COMMAND_SECRET}" ]]; then
            echo "Using PROBE_CHAT_COMMAND secret."
            COMMAND_VAR="${PROBE_CHAT_COMMAND_SECRET}"
          else
            echo "Using default_probe_chat_command input: ${{ inputs.default_probe_chat_command }}"
            COMMAND_VAR="${{ inputs.default_probe_chat_command }}"
          fi

          if [[ -z "$COMMAND_VAR" ]]; then
             echo "::error::Command is empty after evaluation. Check secrets/inputs."
             exit 1
          fi

          echo "Determined command base: $COMMAND_VAR"
          echo "command=$COMMAND_VAR" >> "$GITHUB_OUTPUT"

      - name: Set up Python and Install Aider
        if: inputs.allow_edit
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install Aider
        if: inputs.allow_edit
        run: |
          echo "Installing aider for code editing capabilities..."
          python -m pip install aider-install
          aider-install
          echo "Aider installation completed."

      - name: Run probe-chat
        id: probe
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          ANTHROPIC_API_URL: ${{ secrets.ANTHROPIC_API_URL }}
          ANTHROPIC_BASE_URL: ${{ secrets.ANTHROPIC_API_URL }}
          OPENAI_API_URL: ${{ secrets.OPENAI_API_URL }}
          GOOGLE_API_URL: ${{ secrets.GOOGLE_API_URL }}
          LLM_BASE_URL: ${{ secrets.LLM_BASE_URL }}
          MODEL_NAME: ${{ secrets.MODEL_NAME }}
          FORCE_PROVIDER: ${{ secrets.FORCE_PROVIDER }}
          ALLOW_EDIT: ${{ inputs.allow_edit == 'true' && '1' || '0' }}
        run: |
          # Check and modify ANTHROPIC_API_URL to set ANTHROPIC_BASE_URL
          if [[ -n "$ANTHROPIC_API_URL" ]]; then
            # If ANTHROPIC_API_URL ends with /v1, remove it for ANTHROPIC_BASE_URL
            if [[ "$ANTHROPIC_API_URL" == */v1 ]]; then
              export ANTHROPIC_BASE_URL="${ANTHROPIC_API_URL%/v1}"
              echo "ANTHROPIC_BASE_URL set to $ANTHROPIC_BASE_URL (removed /v1 from ANTHROPIC_API_URL)"
            else
              # If it doesn't end with /v1, use as is
              export ANTHROPIC_BASE_URL="$ANTHROPIC_API_URL"
              echo "ANTHROPIC_BASE_URL set to $ANTHROPIC_BASE_URL (same as ANTHROPIC_API_URL)"
            fi
          fi

          set -o pipefail # Fail pipe if any command fails
          PROMPT_FILE="${{ steps.format.outputs.formatted_prompt_file }}"
          COMMAND_BASE="${{ steps.determine_command.outputs.command }}"
          RESPONSE_FILE="response.txt"
          ERROR_LOG="error.log"
          COMMAND_TO_RUN="$COMMAND_BASE" # Start building command

          # Check if custom prompt is provided as input
          if [[ -n "${{ inputs.prompt }}" ]]; then
            # Store prompt in a variable and properly quote it to handle multiline values
            PROMPT_VALUE="${{ inputs.prompt }}"
            COMMAND_TO_RUN="$COMMAND_TO_RUN --prompt '$PROMPT_VALUE'"
            echo "Using custom prompt from workflow input (properly quoted for multiline support)"
          else
            # Use default prompt type based on context if no custom prompt provided
            CONTEXT_TYPE="${{ steps.format.outputs.context_type }}"
            if [[ "$CONTEXT_TYPE" == "pr" ]]; then
              COMMAND_TO_RUN="$COMMAND_TO_RUN --prompt code-review"
              echo "Using code-review prompt for pull request context"
            elif [[ "$CONTEXT_TYPE" == "issue" ]]; then
              COMMAND_TO_RUN="$COMMAND_TO_RUN --prompt support"
              echo "Using support prompt for issue context"
            else
              echo "::warning:: Unknown context type '$CONTEXT_TYPE', not adding specific prompt flag."
            fi
          fi

          # Add allow-edit flag if enabled in workflow input
          if [[ "${{ inputs.allow_edit }}" == "true" ]]; then
            COMMAND_TO_RUN="$COMMAND_TO_RUN --allow-edit"
            echo "Enabling implement tool with --allow-edit flag"
          fi

          if [[ -z "$COMMAND_TO_RUN" ]]; then
            echo "::error::COMMAND_TO_RUN is unexpectedly empty after building!" >&2
            echo "ðŸ¤– **Error:** Internal configuration error - AI command is missing." > "$RESPONSE_FILE"
            exit 1
          fi

          if [ ! -s "$PROMPT_FILE" ]; then
            echo "::error::Prompt file '$PROMPT_FILE' not found or is empty. Check 'format' step logs." >&2
            echo "ðŸ¤– **Error:** Internal error - prompt file missing or empty." > "$RESPONSE_FILE"
            exit 1
          fi

          echo "Prompt file: $PROMPT_FILE"
          echo "Prompt file size: $(wc -c < "$PROMPT_FILE") bytes"
          echo "Command to run: $COMMAND_TO_RUN"
          echo "Running probe-chat..."

          # Pipe prompt content to command stdin, capture stdout/stderr
          # Use tee with process substitution to both display stderr in real-time and save to file
          cat "$PROMPT_FILE" | $COMMAND_TO_RUN > "$RESPONSE_FILE" 2> >(tee "$ERROR_LOG" >&2)
          EXIT_CODE=${PIPESTATUS[1]} # Get exit code of $COMMAND_TO_RUN

          if [ $EXIT_CODE -ne 0 ]; then
            echo "::error::probe-chat command failed with exit code $EXIT_CODE." >&2
            if [ -s "$ERROR_LOG" ]; then
              echo "--- probe-chat stderr ---" >&2
              cat "$ERROR_LOG" >&2
              echo "--- end probe-chat stderr ---" >&2
            fi
            # If response file empty, write a generic error
            if [ ! -s "$RESPONSE_FILE" ]; then
               echo "ðŸ¤– **Error:** AI command failed (Exit code: $EXIT_CODE). Check Action logs." > "$RESPONSE_FILE"
            fi
             # Let workflow continue to reporting step
          else
            echo "probe-chat command finished successfully (Exit code: 0)."
          fi

          # Check for empty response on success
          if [ $EXIT_CODE -eq 0 ] && [ ! -s "$RESPONSE_FILE" ]; then
            echo "::warning::probe-chat command succeeded but produced an empty response."
            echo "ðŸ¤– AI command ran successfully but generated no response." > "$RESPONSE_FILE"
          fi

      - name: Upload Debug Files as Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: probe-debug-files
          path: |
            error.log
            formatted_prompt.txt
            jq_std_error.log
            response.txt
          if-no-files-found: ignore
          retention-days: 7

      - name: Handle Git Changes
        id: handle_git
        if: inputs.allow_edit && steps.probe.outcome == 'success'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CONTEXT_TYPE: ${{ steps.format.outputs.context_type }}
          ISSUE_NUMBER: ${{ steps.set_context_ids.outputs.issue_number }}
        run: |
          echo "::group::Checking for Git Changes"
          # Configure git user based on inputs
          git config --global user.name "${{ inputs.git_user_name }}"
          git config --global user.email "${{ inputs.git_user_email }}"
          echo "Using git identity: ${{ inputs.git_user_name }} <${{ inputs.git_user_email }}>"

          # Check if there are any changes
          git status --porcelain
          if [[ -z $(git status --porcelain) ]]; then
            echo "No changes detected in the repository."
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 0
          fi

          echo "Changes detected in the repository."
          echo "has_changes=true" >> $GITHUB_OUTPUT

          # Read AI response to use as commit message
          RESPONSE_CONTENT=$(cat response.txt 2>/dev/null || echo "AI-assisted changes")
          # Truncate and format commit message
          COMMIT_MSG=$(printf "AI: %s" "$RESPONSE_CONTENT")

          # Handle different contexts
          PR_URL=""

          if [[ "$CONTEXT_TYPE" == "pr" ]]; then
            # If in PR context, commit to the current branch to extend the PR
            echo "In PR context, extending the existing PR..."
            
            # Add changes but exclude debug files
            git add --all
            git reset -- error.log formatted_prompt.txt jq_std_error.log response.txt
            git commit -m "$COMMIT_MSG"
            
            # Push to the current branch
            CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
            echo "Pushing changes to current branch: $CURRENT_BRANCH..."
            git push origin "$CURRENT_BRANCH"
            echo "pr_url=" >> $GITHUB_OUTPUT
            
          elif [[ "$CONTEXT_TYPE" == "issue" ]]; then
            # If in issue context, create a new branch and PR
            echo "Creating PR for issue #${ISSUE_NUMBER}..."
            
            # Create a branch name that includes the issue number
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            BRANCH_NAME="probe-ai/issue-${ISSUE_NUMBER}-${TIMESTAMP}"
            
            # Create a new branch
            git checkout -b "$BRANCH_NAME"
            
            # Add changes but exclude debug files
            git add --all
            git reset -- error.log formatted_prompt.txt jq_std_error.log response.txt
            git commit -m "$COMMIT_MSG"
            
            PR_TITLE="AI-assisted changes for issue #${ISSUE_NUMBER}"
            PR_BODY=$(printf "This PR was automatically created by Probe AI in response to issue #%s.\n\nChanges include:\n\n%s" "$ISSUE_NUMBER" "$RESPONSE_CONTENT")
            
            # Push the branch
            git push origin "$BRANCH_NAME"
            
            # Create PR
            PR_URL=$(gh pr create --title "$PR_TITLE" --body "$PR_BODY" --base main --head "$BRANCH_NAME")
            echo "Created PR: $PR_URL"
            echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
            
          else
            # Not in PR or issue context, use current branch
            echo "Not in PR or issue context, using current branch..."
            
            # Get current branch name
            CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
            
            # Add changes but exclude debug files
            git add --all
            git reset -- error.log formatted_prompt.txt jq_std_error.log response.txt
            git commit -m "$COMMIT_MSG"
            
            # Push the changes to current branch
            echo "Pushing changes to current branch: $CURRENT_BRANCH..."
            git push origin "$CURRENT_BRANCH"
            echo "pr_url=" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      - name: Read Response or Error and Format Output
        if: always() # Run always to report status
        id: read_response
        env:
          COMMAND_PREFIX: ${{ inputs.command_prefix }}
          HAS_CHANGES: ${{ steps.handle_git.outputs.has_changes }}
          PR_URL: ${{ steps.handle_git.outputs.pr_url }}
          CONTEXT_TYPE: ${{ steps.format.outputs.context_type }}
        run: |
          RESPONSE_CONTENT=$(cat response.txt 2>/dev/null || echo "")
          ERROR_LOG_CONTENT=$(cat error.log 2>/dev/null || echo "")
          FINAL_BODY=""

          # Add info about changes based on context
          if [[ "$HAS_CHANGES" == "true" ]]; then
            if [[ "$CONTEXT_TYPE" == "pr" ]]; then
              # In PR context
              RESPONSE_CONTENT="${RESPONSE_CONTENT}\n\n**Changes have been applied and pushed to the current PR branch.**"
            elif [[ "$CONTEXT_TYPE" == "issue" && -n "$PR_URL" ]]; then
              # In issue context with PR created
              RESPONSE_CONTENT="${RESPONSE_CONTENT}\n\n**Changes have been applied and a PR has been created: ${PR_URL}**"
            else
              # Not in PR or issue context, or issue context but PR creation failed
              RESPONSE_CONTENT="${RESPONSE_CONTENT}\n\n**Changes have been applied and committed to the current branch.**"
            fi
          fi

          FOOTER_TEMPLATE="\n\n-----\n*Tip: Mention me again using \`%s <request>\`.*\n*Powered by [Probe AI](https://probeai.dev)*"
          printf -v FOOTER "$FOOTER_TEMPLATE" "$COMMAND_PREFIX"

          # Check the outcome of the 'probe' step
          if [[ "${{ steps.probe.outcome }}" == "success" ]]; then
            if [[ -n "${RESPONSE_CONTENT// }" ]]; then # Check if not empty or just whitespace
              FINAL_BODY="${RESPONSE_CONTENT}${FOOTER}"
            else
              # Probe succeeded but response file was empty (handled in probe step)
              FINAL_BODY="${RESPONSE_CONTENT}${FOOTER}" # Use the message written in probe step
            fi
          else
            # Probe step failed or earlier steps failed
            ERROR_MESSAGE="ðŸ¤– **Error:** AI interaction failed."
            if [[ "${{ steps.format.outcome }}" == "failure" ]]; then
              ERROR_MESSAGE="ðŸ¤– **Error:** Failed during context preparation. Check 'Format Input' logs."
            elif [[ "${{ steps.probe.outcome }}" == "failure" ]]; then
                # Prefer error message from response.txt if it looks like an error
                if [[ -n "${RESPONSE_CONTENT// }" ]] && echo "$RESPONSE_CONTENT" | grep -q -E "(Error:|ERROR:|Failed|failed|Cannot|Could not)"; then
                   ERROR_MESSAGE="${RESPONSE_CONTENT}" # Use the error from response.txt
                else
                   # Fallback to generic message + stderr if available
                   ERROR_MESSAGE="ðŸ¤– **Error:** The AI command failed to execute or returned an error."
                   if [[ -n "${ERROR_LOG_CONTENT// }" ]]; then
                     ERROR_DETAILS=$(head -c 1000 <<< "$ERROR_LOG_CONTENT")
                     if [[ ${#ERROR_LOG_CONTENT} -gt 1000 ]]; then ERROR_DETAILS="${ERROR_DETAILS}\n...(truncated)"; fi
                     ERROR_MESSAGE="${ERROR_MESSAGE}\n\n**Details (stderr):**\n\`\`\`\n${ERROR_DETAILS}\n\`\`\`"
                   else
                     ERROR_MESSAGE="${ERROR_MESSAGE} Check 'Run probe-chat' logs."
                   fi
                fi
            else # Other preceding failure
              ERROR_MESSAGE="ðŸ¤– **Error:** Workflow failed before AI interaction. Check logs."
            fi
            FINAL_BODY="${ERROR_MESSAGE}${FOOTER}"
          fi

          echo "Final response body prepared. Length: ${#FINAL_BODY}"
          {
            echo "response<<EOF_RESPONSE_MARKER"
            echo "$FINAL_BODY"
            echo "EOF_RESPONSE_MARKER"
          } >> "$GITHUB_OUTPUT"

  post_response:
    if: always() && needs.process_comment.result != 'skipped' # Run if process_comment ran, even if it failed
    runs-on: ubuntu-latest
    needs: [process_comment]
    steps:
      - name: Post Response Comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          issue-number: ${{ needs.process_comment.outputs.issue_number }}
          body: ${{ needs.process_comment.outputs.response_body }}
          reactions: ${{ needs.process_comment.outputs.probe_succeeded == 'true' && '+1' || '-1' }}
# </gh>
