<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Probe - AI-Native Code Understanding</title>
	<!-- Add Marked.js for Markdown rendering -->
	<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
	<!-- Add Highlight.js for syntax highlighting -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
	<!-- Add Mermaid.js for diagram rendering -->
	<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
	<style>
		body {
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
			margin: 0;
			padding: 0;
			line-height: 1.5;
			color: #333;
			min-height: 100vh;
			overflow-x: hidden;
			overflow-y: auto;
		}

		#chat-container {
			max-width: 868px;
			/* 900px - 16px padding on each side */
			margin: 0 auto;
			display: flex;
			flex-direction: column;
			height: 100vh;
			position: relative;
			box-sizing: border-box;
		}

		.header {
			padding: 10px 0;
			border-bottom: 1px solid #eee;
		}

		.header-container {
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		.header-left {
			display: flex;
			align-items: center;
		}

		.header-logo {
			height: 30px;
			margin-right: 10px;
		}

		.new-chat-link {
			font-size: 15px;
			color: #555;
			text-decoration: none;
			font-weight: 500;
			padding: 5px 10px;
			border: 1px solid #ddd;
			border-radius: 4px;
			margin-left: 5px;
			transition: all 0.2s ease;
		}

		.new-chat-link:hover {
			background-color: #f5f5f5;
			border-color: #ccc;
		}

		#messages {
			flex: 1;
			background-color: #fff;
			overflow-y: auto;
			margin-bottom: 80px;
			margin-top: 20px;
			/* Space for fixed input form */
		}

		.tool-call {
			margin: 10px 0;
			border: 1px solid #ddd;
			border-radius: 8px;
			background-color: #f8f9fa;
			overflow: hidden;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
			transition: all 0.2s ease;
		}

		.tool-call:hover {
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
		}

		.tool-call-header {
			background-color: #e9ecef;
			padding: 10px 14px;
			font-weight: bold;
			border-bottom: 1px solid #ddd;
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		.tool-call-name {
			color: #0066cc;
			font-size: 1.05em;
		}

		.tool-call-timestamp {
			font-size: 0.8em;
			color: #666;
			font-style: italic;
		}

		.tool-call-content {
			padding: 12px;
		}

		.tool-call-description {
			background-color: #ffffff;
			padding: 10px 12px;
			border-radius: 6px;
			border-left: 3px solid #44CDF3;
			margin-bottom: 10px;
			font-size: 0.95em;
			color: #333;
		}

		.tool-call-args {
			background-color: #ffffff;
			padding: 10px;
			border-radius: 6px;
			border: 1px solid #eee;
			font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
			font-size: 0.9em;
			margin-bottom: 10px;
			white-space: pre-wrap;
		}

		.tool-call-result {
			background-color: #f0f8ff;
			padding: 10px;
			border-radius: 6px;
			border: 1px solid #e0e8ff;
			font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
			font-size: 0.9em;
			white-space: pre-wrap;
			max-height: 300px;
			overflow-y: auto;
		}


		#input-form {
			position: fixed;
			display: flex;
			padding: 16px 0;
			background-color: white;
			border-top: 1px solid #ddd;
			z-index: 100;
			max-width: 868px;
			width: calc(100% - 32px);
			margin: 0 auto;
			left: 50%;
			transform: translateX(-50%);
			box-sizing: border-box;
			align-items: flex-end;
			/* Align items to the bottom */
		}

		#input-form.centered {
			top: 50%;
			transform: translate(-50%, -50%);
			border-top: none;
		}

		.centered-logo-container {
			text-align: center;
			margin-bottom: 20px;
			position: fixed;
			top: 35%;
			left: 50%;
			transform: translate(-50%, -100%);
			z-index: 99;
		}

		.api-setup-mode .centered-logo-container {
			position: static;
			margin: 40px auto 20px;
			width: 100%;
			max-width: 800px;
			transform: none;
		}

		.centered-logo-container h1 {
			font-weight: 300;
			display: flex;
			align-items: center;
			justify-content: center;
			margin: 0;
		}

		.centered-logo-container h1 img {
			height: 80px;
			margin-right: 16px;
		}

		.centered-logo-container h1 {
			font-size: 38px;
		}

		#input-form.bottom {
			bottom: 0;
		}

		.search-suggestions {
			color: #999;
			font-size: 0.85em;
			display: none;
			text-align: left;
			padding: 0;
			position: fixed;
			max-width: 868px;
			width: calc(100% - 32px);
			margin: 0 auto;
			background-color: white;
			left: 50%;
			transform: translateX(-50%);
			z-index: 99;
		}

		.search-suggestions ul {
			list-style: none;
			padding: 0;
			margin: 0;
			display: flex;
			flex-wrap: wrap;
		}

		.search-suggestions li {
			padding: 6px 16px 6px 0;
			white-space: nowrap;
			cursor: pointer;
		}

		.search-suggestions li:hover {
			color: #44CDF3;
		}

		#input-form.centered .search-suggestions {
			display: block;
		}

		.folder-info {
			color: #666;
			font-size: 0.9em;
			margin-top: 10px;
			padding-top: 10px;
			border-top: 1px solid #e0e0e0;
			font-style: italic;
			font-weight: 500;
		}

		#input-form.centered .folder-info {
			display: block;
		}


		#message-input {
			resize: none;
			flex: 1;
			padding: 12px 16px;
			border: 1px solid #ddd;
			border-radius: 8px;
			font-size: 14px;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
			resize: none;
			overflow-y: auto;
			height: 1.5em;
			/* Changed from 44px to auto */
			min-height: 44px;
			/* Ensures 1 row minimum */
			max-height: 200px;
			/* Limits to ~10 rows */
			line-height: 1.5em;

			box-sizing: border-box;
		}

		button {
			padding: 12px 24px;
			margin-left: 10px;
			background-color: #44CDF3;
			color: white;
			border: none;
			border-radius: 8px;
			cursor: pointer;
			font-weight: bold;
			font-size: 18px;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
			transition: all 0.2s ease;
			align-self: flex-end;
			/* Ensure button aligns to bottom */
			height: 44px;
			/* Match the height of the single-line textarea */
		}

		button:hover {
			background-color: #2bb5db;
		}


		#folder-list ul {
			margin: 4px 0;
			padding-left: 20px;
		}

		#folder-list li {
			padding: 2px 0;
		}

		#folder-list strong {
			color: #333;
			font-weight: 600;
		}

		.footer {
			text-align: center;
			padding: 10px;
			font-size: 14px;
			color: #666;
			position: fixed;
			bottom: 0;
			left: 0;
			right: 0;
			background-color: white;
			border-top: 1px solid #eee;
			z-index: 50;
		}

		.footer a {
			color: #2196F3;
			text-decoration: none;
		}

		.footer a:hover {
			text-decoration: underline;
		}

		.header-container {
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.example {
			font-style: italic;
			color: #666;
			margin: 8px 0;
		}

		/* Markdown styling */
		.markdown-content {
			line-height: 1.6;
		}

		.markdown-content h1,
		.markdown-content h2,
		.markdown-content h3 {
			margin-top: 24px;
			margin-bottom: 16px;
			font-weight: 600;
			line-height: 1.25;
		}

		.markdown-content h1 {
			font-size: 2em;
		}

		.markdown-content h2 {
			font-size: 1.5em;
		}

		.markdown-content h3 {
			font-size: 1.25em;
		}

		.markdown-content p,
		.markdown-content ul,
		.markdown-content ol {
			margin-top: 0;
			margin-bottom: 16px;
		}

		.markdown-content code {
			padding: 0.2em 0.4em;
			margin: 0;
			font-size: 85%;
			background-color: rgba(27, 31, 35, 0.05);
			border-radius: 3px;
			font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
		}

		.markdown-content pre {
			padding: 16px;
			overflow: auto;
			font-size: 85%;
			line-height: 1.45;
			background-color: #f6f8fa;
			border-radius: 3px;
			margin-top: 0;
			margin-bottom: 16px;
		}

		.markdown-content pre code {
			padding: 0;
			margin: 0;
			font-size: 100%;
			background-color: transparent;
			border: 0;
		}

		.user-message {
			background-color: #f1f1f1;
			padding: 10px 14px;
			border-radius: 18px;
			margin-bottom: 12px;
			max-width: 80%;
			align-self: flex-end;
			font-weight: 500;
		}

		.ai-message {
			background-color: transparent;
			padding: 10px 14px;
			margin-bottom: 4px;
			max-width: 90%;
			align-self: flex-start;
		}

		.message-container {
			display: flex;
			flex-direction: column;
		}

		.copy-button-container {
			align-self: flex-start;
			margin-bottom: 12px;
			margin-top: -20px;
		}

		.copy-button {
			background-color: white;
			border-radius: 4px;
			padding: 4px 8px;
			cursor: pointer;
			font-size: 12px;
			color: #666;
			display: flex;
			align-items: center;
			border: none;
		}

		.copy-button:hover {
			background-color: #d0d0d0;
		}

		.copy-button svg {
			width: 16px;
			height: 16px;
			margin-right: 4px;
		}

		.message-container {
			display: flex;
			flex-direction: column;
		}

		/* Mermaid diagram styling */
		.mermaid {
			background-color: #f8f9fa;
			padding: 16px;
			border-radius: 8px;
			margin: 16px 0;
			overflow-x: auto;
			text-align: center;
		}

		.mermaid svg {
			max-width: 100%;
			height: auto;
		}
	</style>
	<style>
		/* Styles for the API key setup message */
		#api-key-setup {
			display: none;
			background-color: #f8f9fa;
			border: 1px solid #ddd;
			border-radius: 8px;
			padding: 20px;
			margin: 20px auto;
			max-width: 800px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
		}

		#api-key-setup h2 {
			color: #333;
			margin-top: 0;
			border-bottom: 1px solid #eee;
			padding-bottom: 10px;
		}

		#api-key-setup code {
			background-color: #f1f1f1;
			padding: 2px 5px;
			border-radius: 3px;
			font-family: monospace;
		}

		/* API Key Form Styles */
		#api-key-form {
			background-color: #fff;
			border: 1px solid #ddd;
			border-radius: 8px;
			padding: 20px;
			margin-top: 20px;
		}

		#api-key-form h3 {
			margin-top: 0;
			color: #44CDF3;
		}

		#api-key-form .form-group {
			margin-bottom: 15px;
		}

		#api-key-form label {
			display: block;
			margin-bottom: 5px;
			font-weight: 500;
		}

		#api-key-form select,
		#api-key-form input {
			width: 100%;
			padding: 10px;
			border: 1px solid #ddd;
			border-radius: 4px;
			font-size: 14px;
		}

		#api-key-form .buttons {
			display: flex;
			justify-content: space-between;
			margin-top: 20px;
		}

		#api-key-form button {
			padding: 10px 15px;
			background-color: #44CDF3;
			color: white;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-weight: bold;
		}

		#api-key-form button:hover {
			background-color: #2bb5db;
		}

		#reset-api-key {
			background-color: #f44336 !important;
		}

		#reset-api-key:hover {
			background-color: #d32f2f !important;
		}

		.api-key-status {
			margin-top: 10px;
			padding: 10px;
			border-radius: 4px;
			font-size: 14px;
		}

		.api-key-status.success {
			background-color: #e8f5e9;
			color: #2e7d32;
			border-left: 4px solid #4caf50;
		}

		.api-key-status.error {
			background-color: #ffebee;
			color: #c62828;
			border-left: 4px solid #f44336;
		}

		h1 a:hover {
			text-decoration: underline;
		}
	</style>
</head>

<body>
	<div id="chat-container">
		<div class="header">
			<div class="header-container">
				<div class="header-left">
					<img src="logo.png" alt="Probe Logo" class="header-logo">
					<a href="javascript:location.reload()" class="new-chat-link">New chat</a>
				</div>
				<div id="api-settings">
					<a href="#" id="header-reset-api-key"
						style="display: none; font-size: 12px; color: #f44336; text-decoration: none;">Reset API Key</a>
				</div>
			</div>
		</div>

		<div id="empty-state-logo" class="centered-logo-container">
			<h1><img src="logo.png" alt="Probe Logo"><a href="https://probeai.dev/"
					style="color: inherit; text-decoration: none;">Probe </a>&nbsp;- AI-Native Code Understanding</h1>
		</div>

		<!-- API Key Setup Instructions -->
		<div id="api-key-setup">
			<h2>API Key Setup Required</h2>
			<p>To use the Probe AI chat interface, you need to configure at least one API key. You have two options:</p>

			<!-- API Key Web Form -->
			<div id="api-key-form">
				<h3>Option 1: Configure API Key in Browser</h3>
				<p>Enter your API key details below to start using the chat interface immediately:</p>

				<div class="form-group">
					<label for="api-provider">API Provider:</label>
					<select id="api-provider">
						<option value="anthropic">Anthropic Claude</option>
						<option value="openai">OpenAI</option>
						<option value="google">Google AI</option>
					</select>
				</div>

				<div class="form-group">
					<label for="api-key">API Key:</label>
					<input type="password" id="api-key" placeholder="Enter your API key">
				</div>

				<div class="form-group">
					<label for="api-url">Custom API URL (Optional):</label>
					<input type="text" id="api-url" placeholder="Leave blank for default API URL">
				</div>

				<div class="api-key-status" id="api-key-status" style="display: none;"></div>

				<div class="buttons">
					<button type="button" id="save-api-key">Save API Key</button>
				</div>

				<p style="margin-top: 10px; font-size: 0.9em; color: #666;">
					Your API key will be stored in your browser's local storage and sent with each request.
					No data is stored on our servers.
				</p>
			</div>

			<div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee;">
				<h3>Option 2: Using Server-Side Configuration</h3>
				<p>Alternatively, you can configure API keys on the server:</p>

				<div style="background-color: #f8f9fa; padding: 15px; border-radius: 6px; margin-top: 10px;">
					<p><strong>Using a .env file:</strong></p>
					<ol style="margin-left: 20px;">
						<li>Create a <code>.env</code> file in the current directory by copying <code>.env.example</code></li>
						<li>Add your API key to the <code>.env</code> file (uncomment and replace with your key)</li>
						<li>Restart the application</li>
					</ol>

					<p style="margin-top: 15px;"><strong>Using environment variables:</strong></p>
					<ul style="margin-left: 20px;">
						<li>Anthropic: <code>ANTHROPIC_API_KEY=your_anthropic_api_key</code></li>
						<li>OpenAI: <code>OPENAI_API_KEY=your_openai_api_key</code></li>
						<li>Google AI: <code>GOOGLE_API_KEY=your_google_api_key</code></li>
					</ul>
				</div>
			</div>
		</div>
		<div id="messages" class="message-container"></div>
	</div>
	<form id="input-form">
		<textarea id="message-input" placeholder="Ask about code..." required rows="1"></textarea>
		<button type="submit">Search</button>
	</form>
	<div class="search-suggestions">
		<ul>
			<li>Find functions that handle user authentication</li>
			<li>Search for database connection implementations</li>
			<li>Show error handling patterns in the codebase</li>
			<li>List all API endpoints in the project</li>
			<li>Find code that processes user input</li>
			<li>Show how configuration is loaded</li>
			<li>Find file parsing implementations</li>
		</ul>
		<div id="folder-info" class="folder-info"></div>
	</div>
	<div class="footer">
		Powered by <a href="https://probeai.dev/" target="_blank">Probe</a>
	</div>
	</div>
	<script>
		function convertSvgToPng(svgElement, containerDiv, index) {
			if (!svgElement) {
				console.error('No SVG found!');
				return;
			}

			try {
				// Get the actual rendered size of the SVG
				const rect = svgElement.getBoundingClientRect();
				const svgWidth = rect.width;
				const svgHeight = rect.height;
				console.log(`SVG rendered size: ${svgWidth}x${svgHeight}`);

				// Define scale factor for higher resolution (increase for more clarity)
				const scale = 2; // Try 3 or 4 if still blurry

				// Create canvas with scaled dimensions
				const canvasWidth = svgWidth * scale;
				const canvasHeight = svgHeight * scale;
				const canvas = document.createElement('canvas');
				canvas.width = canvasWidth;
				canvas.height = canvasHeight;
				const ctx = canvas.getContext('2d');

				// Enable image smoothing for better quality
				ctx.imageSmoothingEnabled = true;
				ctx.imageSmoothingQuality = 'high';

				// Serialize SVG to string
				const svgString = new XMLSerializer().serializeToString(svgElement);
				const svgDataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgString);

				const img = new Image();
				img.onload = function () {
					// Draw the image onto the canvas at scaled size
					ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);

					// Convert canvas to PNG data URL
					const pngDataUrl = canvas.toDataURL('image/png');

					// Create the PNG image element
					const pngImage = document.createElement('img');
					pngImage.src = pngDataUrl;
					pngImage.width = svgWidth; // Display at original size
					pngImage.height = svgHeight;
					pngImage.alt = 'Diagram as PNG';
					pngImage.className = 'mermaid-png';

					// Log PNG natural size to verify resolution
					pngImage.onload = function () {
						console.log(`PNG natural size: ${this.naturalWidth}x${this.naturalHeight}`);
					};

					// Replace the SVG with the PNG image
					svgElement.style.display = 'none';
					svgElement.insertAdjacentElement('afterend', pngImage);

					console.log(`Replaced SVG with PNG image (index: ${index || 0})`);
				};
				img.onerror = function () {
					console.error('Error loading SVG image for conversion');
				};
				img.src = svgDataUrl;
			} catch (error) {
				console.error('Error in SVG to PNG conversion process:', error);
			}
		}

		// Session ID for this chat session - we'll store it in localStorage to maintain consistency
		let sessionId;
		// Try to get the session ID from localStorage
		if (localStorage.getItem('probeSessionId')) {
			sessionId = localStorage.getItem('probeSessionId');
			console.log(`Using existing session ID from localStorage: ${sessionId}`);
		} else {
			// Generate a new session ID if none exists
			sessionId = crypto.randomUUID();
			localStorage.setItem('probeSessionId', sessionId);
			console.log(`Generated new session ID: ${sessionId}`);
		}
		const messagesDiv = document.getElementById('messages');
		const form = document.getElementById('input-form');
		const searchSuggestionsDiv = document.querySelector('.search-suggestions');
		const input = document.getElementById('message-input');
		const folderListDiv = document.getElementById('folder-list');

		// Position the input form in the center initially and handle UI elements visibility
		function positionInputForm() {
			const footer = document.querySelector('.footer');
			const header = document.querySelector('.header');
			const emptyStateLogo = document.getElementById('empty-state-logo');

			if (messagesDiv.children.length === 0) {
				form.classList.add('centered');
				form.classList.remove('bottom');
				// Show footer when no messages
				if (footer) {
					footer.style.display = 'block';
				}
				// Hide the top header and show the centered logo
				if (header) {
					header.style.display = 'none';
				}
				if (emptyStateLogo) {
					emptyStateLogo.style.display = 'block';
				}
			} else {
				form.classList.remove('centered');
				form.classList.add('bottom');
				// Hide footer when chat is started
				if (footer) {
					footer.style.display = 'none';
				}
				// Show the top header and hide the centered logo
				if (header) {
					header.style.display = 'block';
				}
				if (emptyStateLogo) {
					emptyStateLogo.style.display = 'none';
				}
			}
		}

		// Make search suggestions clickable
		function setupSearchSuggestions() {
			document.querySelectorAll('.search-suggestions li').forEach(item => {
				item.addEventListener('click', () => {
					input.value = item.textContent;
					input.focus();
				});
			});
		}

		// Initialize on page load
		window.addEventListener('load', () => {
			setupSearchSuggestions();
			positionInputForm();
			positionSearchSuggestions();

			// Focus the input field on page load
			setTimeout(() => {
				const inputField = document.getElementById('message-input');
				if (inputField) {
					inputField.focus();
				}
			}, 100);
		});


		// Position search suggestions relative to input form
		function positionSearchSuggestions() {
			const formRect = form.getBoundingClientRect();

			if (form.classList.contains('centered')) {
				// Position directly below the form
				searchSuggestionsDiv.style.top = formRect.bottom + 'px';
				searchSuggestionsDiv.style.display = 'block';
			} else {
				searchSuggestionsDiv.style.display = 'none';
			}
		}

		// Update search suggestions position when window is resized
		window.addEventListener('resize', positionSearchSuggestions);

		// Check if Mermaid is properly loaded
		function checkMermaidLoaded() {
			if (typeof mermaid === 'undefined') {
				console.error('Mermaid is not loaded properly');
				return false;
			}
			console.log('Mermaid version:', mermaid.version);
			return true;
		}

		// Initialize mermaid
		if (checkMermaidLoaded()) {
			mermaid.initialize({
				startOnLoad: false,
				theme: 'default',
				securityLevel: 'loose',
				flowchart: { htmlLabels: true },
				logLevel: 3, // Add logging for debugging (1: error, 2: warn, 3: info, 4: debug, 5: trace)
				fontFamily: 'monospace'
			});

			// Run mermaid on page load to render the test diagram
			window.addEventListener('DOMContentLoaded', () => {
				setTimeout(() => {
					try {
						console.log('Running mermaid on page load');
						mermaid.run();
					} catch (error) {
						console.error('Error initializing mermaid:', error);
					}
				}, 500);
			});
		}

		// Configure marked.js
		// Configure Marked.js with logging
		marked.setOptions({
			highlight: function (code, lang) {
				console.log(`Highlighting code with language: ${lang}`);
				if (lang === 'mermaid') {
					console.log('Returning mermaid div');
					return `<div class="mermaid">${code}</div>`;
				}
				const language = hljs.getLanguage(lang) ? lang : 'plaintext';
				return hljs.highlight(code, { language }).value;
			},
			langPrefix: 'hljs language-',
			gfm: true,
			breaks: true
		});
		// Fetch API key status and check for no API keys mode on page load
		window.addEventListener('DOMContentLoaded', async () => {
			// First check if we have an API key in local storage
			const storedApiKey = localStorage.getItem('probeApiKey');
			if (storedApiKey) {
				// Show the reset button in the header
				const headerResetButton = document.getElementById('header-reset-api-key');
				if (headerResetButton) {
					headerResetButton.style.display = 'inline-block';
				}
			}
			// Check if we're in API key setup mode
			const apiKeySetupDiv = document.getElementById('api-key-setup');
			const inputForm = document.getElementById('input-form');
			const searchSuggestions = document.querySelector('.search-suggestions');

			// If API key setup is visible, we're in API setup mode
			if (apiKeySetupDiv && window.getComputedStyle(apiKeySetupDiv).display !== 'none') {
				// Add class to body for API setup mode styling
				document.body.classList.add('api-setup-mode');

				// Hide search suggestions and input form
				if (inputForm) inputForm.style.display = 'none';
				if (searchSuggestions) searchSuggestions.style.display = 'none';
			} else {
				// Remove API setup mode class if not in setup mode
				document.body.classList.remove('api-setup-mode');
			}

			try {
				const response = await fetch('/folders');
				const data = await response.json();

				// Check if we're in no API keys mode
				if (data.noApiKeysMode) {
					handleNoApiKeysMode();
				}

				// Display folder information
				displayFolderInfo(data.folders);
			} catch (error) {
				console.error('Error fetching API status:', error);
			}
		});

		// Function to display folder information
		function displayFolderInfo(folders) {
			const folderInfoDiv = document.getElementById('folder-info');

			if (!folderInfoDiv) return;

			// Clear any existing content
			folderInfoDiv.innerHTML = '';

			if (folders && folders.length > 0) {
				// Create content for the folder info
				if (folders.length === 1) {
					folderInfoDiv.textContent = `Searching in: ${folders[0]}`;
				} else {
					folderInfoDiv.textContent = `Searching in: ${folders[0]} (and ${folders.length - 1} other folder${folders.length > 2 ? 's' : ''})`;
				}
			} else {
				// When no folders are configured, we need to show the absolute path of the current working directory
				// We'll use the process.cwd() value from the server, which is typically /Users/leonidbugaev/go/src/code-search
				// for this project based on the environment details
				folderInfoDiv.textContent = `Searching in: /Users/leonidbugaev/go/src/code-search (current directory)`;
			}
		}

		// Handle no API keys mode
		function handleNoApiKeysMode() {
			// Check if body has the data-no-api-keys attribute
			const noApiKeys = document.body.getAttribute('data-no-api-keys') === 'true';

			// Check if API key is already stored in local storage
			const storedApiKey = localStorage.getItem('probeApiKey');

			// Add or remove api-setup-mode class based on whether we need to show the API key setup
			if (noApiKeys && !storedApiKey) {
				document.body.classList.add('api-setup-mode');
			} else {
				document.body.classList.remove('api-setup-mode');
			}

			// Get UI elements
			const apiKeySetupDiv = document.getElementById('api-key-setup');
			const inputForm = document.getElementById('input-form');
			const searchSuggestions = document.querySelector('.search-suggestions');

			if (noApiKeys && !storedApiKey) {
				console.log('No API keys detected and no local storage key - showing setup instructions');

				// Show the API key setup div
				if (apiKeySetupDiv) {
					apiKeySetupDiv.style.display = 'block';
				}

				// Hide the chat interface elements
				if (inputForm) {
					inputForm.style.display = 'none';
				}

				if (searchSuggestions) {
					searchSuggestions.style.display = 'none';
				}
			} else if (noApiKeys && storedApiKey) {
				console.log('No server API keys but local storage key found - enabling chat interface');

				// Hide the API key setup div
				if (apiKeySetupDiv) {
					apiKeySetupDiv.style.display = 'none';
				}

				// Show the chat interface elements
				if (inputForm) {
					inputForm.style.display = 'flex';
				}

				// Remove API setup mode class
				document.body.classList.remove('api-setup-mode');
			}
		}


		// Render markdown content
		function renderMarkdown(text) {
			// Just parse the markdown and return the HTML
			return marked.parse(text);
		}

		// Test function to manually render a Mermaid diagram
		function testMermaidRendering() {
			console.log('Testing Mermaid rendering...');
			try {
				// Create a simple test diagram directly
				const testDiv = document.createElement('div');
				testDiv.className = 'mermaid';
				testDiv.textContent = 'graph TD;\nA-->B;';
				document.body.appendChild(testDiv);

				console.log('Created test diagram with content:', testDiv.textContent);

				// Render the direct mermaid div
				setTimeout(() => {
					try {
						console.log('Running mermaid on test div');
						if (typeof mermaid.run === 'function') {
							console.log('Using mermaid.run() for test');
							mermaid.run({
								nodes: [testDiv]
							});
						} else if (typeof mermaid.init === 'function') {
							console.log('Using mermaid.init() for test');
							mermaid.init(undefined, [testDiv]);
						}

						// Verify if rendering worked
						setTimeout(() => {
							const svg = testDiv.querySelector('svg');
							if (svg) {
								console.log('Test diagram rendered successfully!');
							} else {
								console.error('Test diagram did not render to SVG');
							}

							// Remove test div after verification
							document.body.removeChild(testDiv);
						}, 100);
					} catch (error) {
						console.error('Error rendering test mermaid diagram:', error);
						console.error('Error details:', error.message);

						// Remove test div on error
						document.body.removeChild(testDiv);
					}
				}, 200);
			} catch (error) {
				console.error('Unexpected error in test function:', error);
			}
		}

		// Run test on page load
		window.addEventListener('DOMContentLoaded', () => {
			setTimeout(testMermaidRendering, 1000);
		});

		// Connect to SSE endpoint for tool calls
		let eventSource;
		let currentAiMessageDiv = null;

		function connectToToolEvents() {
			// Close existing connection if any
			if (eventSource) {
				console.log('Closing existing SSE connection');
				eventSource.close();
			}

			console.log(`%c Connecting to SSE endpoint with session ID: ${sessionId}`, 'background: #FF9800; color: white; padding: 2px 5px; border-radius: 2px;');
			// Connect to SSE endpoint with session ID
			const sseUrl = `/api/tool-events?sessionId=${sessionId}`;
			console.log('SSE URL:', sseUrl);
			eventSource = new EventSource(sseUrl);

			// Handle connection event
			eventSource.addEventListener('connection', (event) => {
				console.log('%c Connected to tool events stream', 'background: #4CAF50; color: white; padding: 2px 5px; border-radius: 2px;', event.data);
				try {
					const connectionData = JSON.parse(event.data);
					console.log('Connection data:', connectionData);
				} catch (error) {
					console.error('Error parsing connection data:', error, event.data);
				}
			});

			// Handle test events
			eventSource.addEventListener('test', (event) => {
				console.log('%c Received test event:', 'background: #9C27B0; color: white; padding: 2px 5px; border-radius: 2px;', event.data);
				try {
					const testData = JSON.parse(event.data);
					console.log('%c Test data:', 'background: #673AB7; color: white; padding: 2px 5px; border-radius: 2px;', testData);

					// Log specific test data properties
					console.log('Test message:', testData.message);
					console.log('Test timestamp:', testData.timestamp);
					console.log('Test session ID:', testData.sessionId);

					if (testData.status) {
						console.log('Test status:', testData.status);
					}

					if (testData.connectionInfo) {
						console.log('Connection info:', testData.connectionInfo);
					}

					if (testData.sequence === 2) {
						console.log('%c SSE connection fully verified with follow-up test', 'background: #4CAF50; color: white; padding: 2px 5px; border-radius: 2px;');
					}

					// Add a visual indicator that the SSE connection is working
					const connectionIndicator = document.createElement('div');
					connectionIndicator.style.position = 'fixed';
					connectionIndicator.style.bottom = '10px';
					connectionIndicator.style.right = '10px';
					connectionIndicator.style.backgroundColor = '#4CAF50';
					connectionIndicator.style.color = 'white';
					connectionIndicator.style.padding = '5px 10px';
					connectionIndicator.style.borderRadius = '4px';
					connectionIndicator.style.fontSize = '12px';
					connectionIndicator.style.zIndex = '1000';
					connectionIndicator.style.opacity = '0.8';
					connectionIndicator.textContent = 'SSE Connected';

					// Remove after 3 seconds
					setTimeout(() => {
						if (document.body.contains(connectionIndicator)) {
							document.body.removeChild(connectionIndicator);
						}
					}, 3000);

					document.body.appendChild(connectionIndicator);

				} catch (error) {
					console.error('Error parsing test event data:', error, event.data);
				}
			});

			// Handle tool call events
			eventSource.addEventListener('toolCall', (event) => {
				console.log('%c Received tool call event:', 'background: #4CAF50; color: white; padding: 2px 5px; border-radius: 2px;', event);
				try {
					const toolCall = JSON.parse(event.data);
					console.log('%c Tool call data:', 'background: #2196F3; color: white; padding: 2px 5px; border-radius: 2px;', toolCall);
					console.log('Tool call name:', toolCall.name);
					console.log('Tool call args:', toolCall.args);
					console.log('Tool call result preview:', toolCall.resultPreview);
					// Create a more robust ID for deduplication
					// Include all relevant properties to ensure uniqueness
					const query = toolCall.args.query || toolCall.args.keywords || toolCall.args.pattern || '';
					const path = toolCall.args.path || toolCall.args.folder || '.';
					const toolCallId = toolCall.id ||
						`${toolCall.name}-${query}-${path}-${toolCall.timestamp}`;

					// Store tool call descriptions to check for duplicates
					if (!window.toolCallDescriptions) {
						window.toolCallDescriptions = new Map();
					}

					// Format the tool call description (same as in addToolCallToMessage)
					let toolDescription = '';
					if (toolCall.name === 'searchCode') {
						toolDescription = `Searching code with "${query}"${path === '.' ? '' : ` in ${path}`}`;
					} else if (toolCall.name === 'queryCode') {
						toolDescription = `Querying code with pattern "${query}"${path === '.' ? '' : ` in ${path}`}`;
					} else if (toolCall.name === 'extractCode') {
						const filePath = toolCall.args.file_path || '';
						const line = toolCall.args.line;
						const endLine = toolCall.args.end_line;

						if (line && endLine) {
							toolDescription = `Extracting code from ${filePath} (lines ${line}-${endLine})`;
						} else if (line) {
							toolDescription = `Extracting code from ${filePath} (from line ${line})`;
						} else {
							toolDescription = `Extracting code from ${filePath}`;
						}
					} else {
						toolDescription = `Using ${toolCall.name} tool`;
					}

					// Check if we've already processed this exact description
					if (window.toolCallDescriptions.has(toolDescription)) {
						console.log(`%c Skipping duplicate tool call: "${toolDescription}"`, 'background: #FF9800; color: white; padding: 2px 5px; border-radius: 2px;');
						return;
					}

					// Add this description to our map
					window.toolCallDescriptions.set(toolDescription, toolCallId);
					console.log(`%c Added tool call description: "${toolDescription}"`, 'background: #9C27B0; color: white; padding: 2px 5px; border-radius: 2px;');

					// Also track by ID for backward compatibility
					if (!window.processedToolCalls) {
						window.processedToolCalls = new Set();
					}
					window.processedToolCalls.add(toolCallId);
					console.log(`%c Added tool call to processed set: ${toolCallId}`, 'background: #9C27B0; color: white; padding: 2px 5px; border-radius: 2px;');

					// Add tool call to the current AI message if it exists
					if (currentAiMessageDiv) {
						addToolCallToMessage(currentAiMessageDiv, toolCall);
					} else {
						console.warn('No current AI message div to add tool call to');
						// Create a temporary div to display the tool call
						const tempDiv = document.createElement('div');
						tempDiv.className = 'ai-message';
						tempDiv.innerHTML = '<div class="tool-call-header">Tool call received but no message context</div>';
						messagesDiv.appendChild(tempDiv);
						addToolCallToMessage(tempDiv, toolCall);
					}
				} catch (error) {
					console.error('Error parsing tool call data:', error, event.data);
				}
			});

			// Handle errors
			eventSource.onerror = (error) => {
				console.error('%c SSE Error:', 'background: #F44336; color: white; padding: 2px 5px; border-radius: 2px;', error);

				// Log detailed readyState information
				const readyStateMap = {
					0: 'CONNECTING',
					1: 'OPEN',
					2: 'CLOSED'
				};
				const readyState = eventSource.readyState;
				console.log(`EventSource readyState: ${readyState} (${readyStateMap[readyState] || 'UNKNOWN'})`);

				// Check if the connection was established before the error
				if (readyState === 2) {
					console.log('Connection was closed. Attempting to reconnect...');
				} else if (readyState === 0) {
					console.log('Connection is still trying to connect. Will retry if it fails.');
				}

				// Try to reconnect after a delay
				console.log('Will attempt to reconnect in 5 seconds...');
				setTimeout(connectToToolEvents, 5000);
			};

			// Add open event handler
			eventSource.onopen = () => {
				console.log('%c SSE connection opened successfully', 'background: #4CAF50; color: white; padding: 2px 5px; border-radius: 2px;');
				console.log('Ready to receive tool call events for session:', sessionId);
			};
		}

		// Add tool call to the AI message
		function addToolCallToMessage(messageDiv, toolCall) {
			console.log('%c Adding tool call to message:', 'background: #4CAF50; color: white; padding: 2px 5px; border-radius: 2px;', toolCall);

			try {
				// Format the tool call in a user-friendly way
				let toolDescription = '';

				// Format based on tool type
				if (toolCall.name === 'searchCode') {
					const query = toolCall.args.query || toolCall.args.keywords || '';
					const path = toolCall.args.path || toolCall.args.folder || '.';

					toolDescription = `Searching code with "${query}"${path === '.' ? '' : ` in ${path}`}`;
				}
				else if (toolCall.name === 'queryCode') {
					const pattern = toolCall.args.pattern || '';
					const path = toolCall.args.path || '.';

					toolDescription = `Querying code with pattern "${pattern}"${path === '.' ? '' : ` in ${path}`}`;
				}
				else if (toolCall.name === 'extractCode') {
					const filePath = toolCall.args.file_path || '';
					const line = toolCall.args.line;
					const endLine = toolCall.args.end_line;

					if (line && endLine) {
						toolDescription = `Extracting code from ${filePath} (lines ${line}-${endLine})`;
					} else if (line) {
						toolDescription = `Extracting code from ${filePath} (from line ${line})`;
					} else {
						toolDescription = `Extracting code from ${filePath}`;
					}
				}
				else {
					// Default formatting for other tools
					toolDescription = `Using ${toolCall.name} tool`;
				}

				// Create a paragraph element for the tool description
				const toolParagraph = document.createElement('p');
				toolParagraph.textContent = toolDescription;
				toolParagraph.style.fontStyle = 'italic';
				toolParagraph.style.color = '#555';
				toolParagraph.style.margin = '8px 0';

				// Add the paragraph to the message div
				messageDiv.appendChild(toolParagraph);

				// Scroll to the bottom
				messagesDiv.scrollTop = messagesDiv.scrollHeight;

				console.log('%c Tool call added successfully', 'background: #4CAF50; color: white; padding: 2px 5px; border-radius: 2px;');
			} catch (error) {
				console.error('Error adding tool call to message:', error);
			}
		}

		// Connect to tool events on page load
		window.addEventListener('DOMContentLoaded', () => {
			// Check if we're in no API keys mode
			const noApiKeys = document.body.getAttribute('data-no-api-keys') === 'true';

			if (!noApiKeys) {
				connectToToolEvents();
			}
		});

		// Controller for aborting fetch requests
		let currentController = null;
		// Flag to track if a request is in progress
		let isRequestInProgress = false;

		// Function to cancel the current request on the server
		async function cancelRequest(sessionId) {
			try {
				const response = await fetch('/cancel-request', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ sessionId })
				});

				if (response.ok) {
					console.log('Request cancelled successfully on server');
				} else {
					console.error('Failed to cancel request on server');
				}
			} catch (error) {
				console.error('Error cancelling request:', error);
			}
		}

		// Handle form submission
		form.addEventListener('submit', async (e) => {
			e.preventDefault();

			// If this is a stop action
			if (form.querySelector('button').textContent === 'Stop') {
				// Abort the current fetch request
				if (currentController) {
					currentController.abort();
					currentController = null;
				}

				// Send cancellation request to the server
				if (isRequestInProgress) {
					await cancelRequest(sessionId);
					isRequestInProgress = false;
				}

				// Reset the button to "Search" and enable input
				form.querySelector('button').textContent = 'Search';
				form.querySelector('button').style.backgroundColor = '#44CDF3';
				input.disabled = false;
				return;
			}

			const message = input.value.trim();
			if (!message) return;

			// Check if this is the first message
			const isFirstMessage = messagesDiv.children.length === 0;

			// Display user message
			const userMsgDiv = document.createElement('div');
			userMsgDiv.className = 'user-message';
			userMsgDiv.textContent = message;
			messagesDiv.appendChild(userMsgDiv);
			input.value = '';

			// If this is the first message, move the input form to the bottom and hide UI elements
			if (isFirstMessage) {
				positionInputForm();
				searchSuggestionsDiv.style.display = 'none';

				// Ensure footer is hidden when chat starts
				const footer = document.querySelector('.footer');
				if (footer) {
					footer.style.display = 'none';
				}

				// Keep the allowed folders section visible during chat
				// This is the key change - we don't hide the folder information anymore
			}

			// Create AI message container
			const aiMsgDiv = document.createElement('div');
			aiMsgDiv.className = 'ai-message markdown-content';

			// Store the original message for copying
			aiMsgDiv.setAttribute('data-original-markdown', '');

			// Add the AI message to the DOM
			messagesDiv.appendChild(aiMsgDiv);

			// Set as current AI message for tool calls
			currentAiMessageDiv = aiMsgDiv;

			// Disable input and change button to "Stop"
			input.disabled = true;
			const submitButton = form.querySelector('button');
			submitButton.textContent = 'Stop';
			submitButton.style.backgroundColor = '#f44336';

			// Set request in progress flag
			isRequestInProgress = true;

			// Send message to server
			try {
				// Log the session ID being used
				console.log(`%c Using session ID for chat request: ${sessionId}`, 'background: #FF9800; color: white; padding: 2px 5px; border-radius: 2px;');

				// Get API key from local storage if available
				const storedApiProvider = localStorage.getItem('probeApiProvider');
				const storedApiKey = localStorage.getItem('probeApiKey');
				const storedApiUrl = localStorage.getItem('probeApiUrl');

				const requestData = {
					message,
					sessionId, // Include session ID with the request
					apiProvider: storedApiProvider,
					apiKey: storedApiKey,
					apiUrl: storedApiUrl
				};
				console.log('Sending chat request with data:', requestData);

				// Add a visual indicator that we're using this session ID
				const sessionIndicator = document.createElement('div');
				sessionIndicator.style.position = 'fixed';
				sessionIndicator.style.top = '10px';
				sessionIndicator.style.right = '10px';
				sessionIndicator.style.backgroundColor = '#FF9800';
				sessionIndicator.style.color = 'white';
				sessionIndicator.style.padding = '5px 10px';
				sessionIndicator.style.borderRadius = '4px';
				sessionIndicator.style.fontSize = '12px';
				sessionIndicator.style.zIndex = '1000';
				sessionIndicator.style.opacity = '0.8';
				sessionIndicator.textContent = `Session ID: ${sessionId.substring(0, 8)}...`;

				// Remove after 3 seconds
				setTimeout(() => {
					if (document.body.contains(sessionIndicator)) {
						document.body.removeChild(sessionIndicator);
					}
				}, 3000);

				document.body.appendChild(sessionIndicator);

				// Create a new AbortController for this request
				currentController = new AbortController();
				const signal = currentController.signal;

				const response = await fetch('/chat', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify(requestData),
					signal: signal
				}).catch(error => {
					if (error.name === 'AbortError') {
						console.log('Fetch aborted');
						aiMsgDiv.innerHTML += '<p><em>Search was stopped by user.</em></p>';
						return null;
					}
					throw error;
				});

				// If response is null (aborted), reset UI and return
				if (!response) {
					// Reset button to "Search" and enable input
					form.querySelector('button').textContent = 'Search';
					form.querySelector('button').style.backgroundColor = '#44CDF3';
					input.disabled = false;
					return;
				}

				const reader = response.body.getReader();
				const decoder = new TextDecoder();
				let aiResponse = '';

				while (true) {
					const { done, value } = await reader.read();
					if (done) break;
					const chunk = decoder.decode(value, { stream: true });
					aiResponse += chunk;

					// Update the original markdown attribute
					aiMsgDiv.setAttribute('data-original-markdown', aiResponse);

					try {
						// Render markdown content
						aiMsgDiv.innerHTML = renderMarkdown(aiResponse);

						// Apply syntax highlighting to code blocks
						aiMsgDiv.querySelectorAll('pre code').forEach((block) => {
							hljs.highlightElement(block);
						});

						// Don't render mermaid diagrams during streaming - will render once at the end
						// This prevents premature rendering attempts that might fail

						messagesDiv.scrollTop = messagesDiv.scrollHeight;
					} catch (error) {
						console.error('Error processing response chunk:', error);
						// If there's an error with markdown parsing, just show the raw text
						aiMsgDiv.textContent = aiResponse;
					}
				}

				// Final render after all content is received
				setTimeout(() => {
					try {
						// Specifically target mermaid diagrams in the current message
						const finalMermaidDivs = aiMsgDiv.querySelectorAll('.language-mermaid');

						if (finalMermaidDivs.length > 0) {
							console.log(`Final render: Found ${finalMermaidDivs.length} mermaid diagrams in current message`);

							// Log the content of the first diagram for debugging
							if (finalMermaidDivs[0]) {
								console.log('First diagram content:', finalMermaidDivs[0].textContent.substring(0, 100) + '...');
							}

							// Try direct rendering with specific nodes from current message
							if (typeof mermaid.run === 'function') {
								console.log('Using mermaid.run() for rendering');
								mermaid.run({
									nodes: finalMermaidDivs
								});
							} else if (typeof mermaid.init === 'function') {
								// Fallback to older mermaid versions
								console.log('Using mermaid.init() for rendering');
								mermaid.init(undefined, finalMermaidDivs);
							} else {
								console.error('No suitable mermaid rendering method found');
							}

							// Verify rendering success
							setTimeout(() => {
								// Update selector to find SVGs inside code.language-mermaid elements
								const renderedSvgs = aiMsgDiv.querySelectorAll('.language-mermaid svg, .mermaid svg');
								console.log(`Rendering verification: Found ${renderedSvgs.length} rendered SVGs`);

								// Convert SVGs to PNGs if any were rendered
								if (renderedSvgs.length > 0) {
									console.log('Converting SVGs to PNGs...');
									renderedSvgs.forEach((svg, index) => {
										convertSvgToPng(svg, aiMsgDiv, index);
									});
								}
							}, 100);
						} else {
							console.log('No mermaid diagrams found in current message');
						}
					} catch (error) {
						console.warn('Final mermaid rendering error:', error);
						console.error('Error details:', error.message);
					}

					// Add copy button below the message after rendering is complete
					if (!aiMsgDiv.nextElementSibling || !aiMsgDiv.nextElementSibling.classList.contains('copy-button-container')) {
						// Create copy button container
						const copyButtonContainer = document.createElement('div');
						copyButtonContainer.className = 'copy-button-container';

						// Create copy button
						const copyButton = document.createElement('button');
						copyButton.className = 'copy-button';
						copyButton.innerHTML = `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="#666"></path></svg>Copy`;

						// Add click event to copy button
						copyButton.addEventListener('click', function () {
							const markdown = aiMsgDiv.getAttribute('data-original-markdown');
							if (markdown) {
								navigator.clipboard.writeText(markdown).then(() => {
									// Visual feedback
									copyButton.textContent = 'Copied!';

									setTimeout(() => {
										copyButton.innerHTML = `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="#666"></path></svg>Copy`;
									}, 2000);
								}).catch(err => {
									console.error('Failed to copy text: ', err);
									copyButton.textContent = 'Failed to copy';

									setTimeout(() => {
										copyButton.innerHTML = `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 5C7 3.34315 8.34315 2 10 2H19C20.6569 2 22 3.34315 22 5V14C22 15.6569 20.6569 17 19 17H17V19C17 20.6569 15.6569 22 14 22H5C3.34315 22 2 20.6569 2 19V10C2 8.34315 3.34315 7 5 7H7V5ZM9 7H14C15.6569 7 17 8.34315 17 10V15H19C19.5523 15 20 14.5523 20 14V5C20 4.44772 19.5523 4 19 4H10C9.44772 4 9 4.44772 9 5V7ZM5 9C4.44772 9 4 9.44772 4 10V19C4 19.5523 4.44772 20 5 20H14C14.5523 20 15 19.5523 15 19V10C15 9.44772 14.5523 9 14 9H5Z" fill="#666"></path></svg>Copy`;
									}, 2000);
								});
							}
						});

						// Add elements to the DOM
						copyButtonContainer.appendChild(copyButton);

						// Insert after the AI message
						if (aiMsgDiv.nextSibling) {
							messagesDiv.insertBefore(copyButtonContainer, aiMsgDiv.nextSibling);
						} else {
							messagesDiv.appendChild(copyButtonContainer);
						}
					}
				}, 500); // Increased timeout to ensure DOM is fully updated
			} catch (error) {
				console.error('Error:', error);
				const errorMsg = document.createElement('div');
				errorMsg.className = 'ai-message';
				errorMsg.textContent = 'Error occurred while processing your request.';
				messagesDiv.appendChild(errorMsg);
			} finally {
				// Reset button to "Search" and enable input
				form.querySelector('button').textContent = 'Search';
				form.querySelector('button').style.backgroundColor = '#44CDF3';
				input.disabled = false;
				currentController = null;
				isRequestInProgress = false;
			}

			messagesDiv.scrollTop = messagesDiv.scrollHeight;
		});

		const messageInput = document.getElementById('message-input');

		function autoResizeTextarea() {
			messageInput.style.height = 'auto'; // Reset to natural height
			const scrollHeight = messageInput.scrollHeight;
			messageInput.style.height = Math.min(scrollHeight, 200) + 'px'; // Set height, capped at 200px
		}

		// Initialize height on page load
		window.addEventListener('load', () => {
			autoResizeTextarea(); // Set initial height based on content (empty = min-height)
		});

		// Auto-resize as user types
		messageInput.addEventListener('input', autoResizeTextarea);

		// Handle Shift+Enter for new line and Enter for form submission
		messageInput.addEventListener('keydown', function (e) {
			if (e.key === 'Enter') {
				if (e.shiftKey) {
					// Allow new line with Shift+Enter and resize
					setTimeout(autoResizeTextarea, 0);
				} else {
					// Submit form on Enter without Shift
					e.preventDefault();
					form.dispatchEvent(new Event('submit'));
				}
			}
		});

		// API Key Form Functionality
		document.addEventListener('DOMContentLoaded', function () {
			// Check if API key is already stored
			const storedApiProvider = localStorage.getItem('probeApiProvider');
			const storedApiKey = localStorage.getItem('probeApiKey');
			const storedApiUrl = localStorage.getItem('probeApiUrl');

			const apiProviderSelect = document.getElementById('api-provider');
			const apiKeyInput = document.getElementById('api-key');
			const apiUrlInput = document.getElementById('api-url');
			const saveButton = document.getElementById('save-api-key');
			const headerResetButton = document.getElementById('header-reset-api-key');
			const statusDiv = document.getElementById('api-key-status');
			const apiKeySetupDiv = document.getElementById('api-key-setup');
			const inputForm = document.getElementById('input-form');

			// If API key is stored, show a success message and show the header reset button
			if (storedApiKey) {
				// Show the reset button in the header
				headerResetButton.style.display = 'inline-block';
				statusDiv.textContent = `API key for ${storedApiProvider} is configured`;
				statusDiv.className = 'api-key-status success';
				statusDiv.style.display = 'block';

				// Fill the form with stored values
				if (storedApiProvider) {
					apiProviderSelect.value = storedApiProvider;
				}
				if (storedApiKey) {
					apiKeyInput.value = '••••••••••••••••••••••••••';
				}
				if (storedApiUrl) {
					apiUrlInput.value = storedApiUrl;
				}

				// If we have an API key in local storage, always enable the chat interface
				// regardless of no API keys mode
				// Hide API key setup and show input form
				apiKeySetupDiv.style.display = 'none';
				inputForm.style.display = 'flex';

				// Remove API setup mode class
				document.body.classList.remove('api-setup-mode');
			}

			// Save API key to local storage
			saveButton.addEventListener('click', function () {
				const provider = apiProviderSelect.value;
				const key = apiKeyInput.value;
				const url = apiUrlInput.value;

				// Don't save if the key is masked
				if (key === '••••••••••••••••••••••••••') {
					statusDiv.textContent = 'No changes made to API key';
					statusDiv.className = 'api-key-status';
					statusDiv.style.display = 'block';
					return;
				}

				// Validate inputs
				if (!key) {
					statusDiv.textContent = 'Please enter an API key';
					statusDiv.className = 'api-key-status error';
					statusDiv.style.display = 'block';
					return;
				}

				// Save to local storage
				localStorage.setItem('probeApiProvider', provider);
				localStorage.setItem('probeApiKey', key);
				if (url) {
					localStorage.setItem('probeApiUrl', url);
				} else {
					localStorage.removeItem('probeApiUrl');
				}

				// Show success message
				statusDiv.textContent = `API key for ${provider} saved successfully`;
				statusDiv.className = 'api-key-status success';
				statusDiv.style.display = 'block';

				// Mask the API key for security
				apiKeyInput.value = '••••••••••••••••••••••••••';

				// If we're in no API keys mode, enable the chat interface
				if (document.body.getAttribute('data-no-api-keys') === 'true') {
					// Hide API key setup and show input form
					apiKeySetupDiv.style.display = 'none';
					inputForm.style.display = 'flex';

					// Refresh the page to apply changes
					setTimeout(() => {
						window.location.reload();
					}, 1000);
				}
			});

			// Reset API key from header button
			headerResetButton.addEventListener('click', function (e) {
				e.preventDefault();

				// Confirm before resetting
				if (confirm('Are you sure you want to reset your API key configuration?')) {
					// Remove from local storage
					localStorage.removeItem('probeApiProvider');
					localStorage.removeItem('probeApiKey');
					localStorage.removeItem('probeApiUrl');

					// Hide the reset button
					headerResetButton.style.display = 'none';

					// Show message
					alert('API key configuration has been reset.');

					// Reload the page
					window.location.reload();
				}
			});
		});
	</script>
</body>

</html>