{
  "version": 3,
  "sources": ["../tokenCounter.js", "../tokenUsageDisplay.js", "../fileSpanExporter.js", "../telemetry.js", "../appTracer.js", "../tools.js", "../implement/core/utils.js", "../implement/core/timeouts.js", "../implement/core/BackendManager.js", "../implement/backends/BaseBackend.js", "../implement/backends/AiderBackend.js", "../implement/backends/ClaudeCodeBackend.js", "../implement/backends/registry.js", "../implement/core/config.js", "../implement/core/ImplementTool.js", "../probeTool.js", "../probeChat.js", "../auth.js", "../cancelRequest.js", "../storage/JsonChatStorage.js", "../webServer.js", "../index.js"],
  "sourcesContent": ["import { get_encoding } from 'tiktoken';\n\n/**\n * TokenCounter class to track token usage in the chat\n */\nexport class TokenCounter {\n  constructor() {\n    // Initialize the tokenizer with cl100k_base encoding (works for both Claude and GPT models)\n    try {\n      // Initialize tokenizer\n      this.tokenizer = get_encoding('cl100k_base');\n\n      // Context window tracking\n      this.contextSize = 0; // Current size based on history\n      this.history = []; // Store message history for context calculation\n\n      // Token counters\n      this.requestTokens = 0; // Total prompt tokens over session\n      this.responseTokens = 0; // Total completion tokens over session\n      this.currentRequestTokens = 0; // Prompt tokens for the current LLM call\n      this.currentResponseTokens = 0; // Completion tokens for the current LLM call\n\n      // Cache token tracking\n      this.cacheCreationTokens = 0; // Total Anthropic cache creation tokens\n      this.cacheReadTokens = 0; // Total Anthropic cache read tokens\n      this.currentCacheCreationTokens = 0; // Anthropic cache creation for current call\n      this.currentCacheReadTokens = 0; // Anthropic cache read for current call\n      this.cachedPromptTokens = 0; // Total OpenAI cached prompt tokens\n      this.currentCachedPromptTokens = 0; // OpenAI cached prompt for current call\n\n    } catch (error) {\n      console.error('Error initializing tokenizer:', error);\n      // Fallback to a simple token counting method if tiktoken fails\n      this.tokenizer = null;\n      this.contextSize = 0;\n      this.requestTokens = 0;\n      this.responseTokens = 0;\n      this.currentRequestTokens = 0;\n      this.currentResponseTokens = 0;\n      this.cacheCreationTokens = 0;\n      this.cacheReadTokens = 0;\n      this.currentCacheCreationTokens = 0;\n      this.currentCacheReadTokens = 0;\n      this.cachedPromptTokens = 0;\n      this.currentCachedPromptTokens = 0;\n      this.history = [];\n    }\n    this.debug = process.env.DEBUG_CHAT === '1';\n  }\n\n  /**\n   * Count tokens in a string using tiktoken or fallback method\n   * @param {string} text - The text to count tokens for\n   * @returns {number} - The number of tokens\n   */\n  countTokens(text) {\n    if (typeof text !== 'string') {\n      text = String(text); // Ensure text is a string\n    }\n\n    if (this.tokenizer) {\n      try {\n        const tokens = this.tokenizer.encode(text);\n        return tokens.length;\n      } catch (error) {\n        // Log only once per session or use a flag? For now, log each time.\n        // console.warn('Error counting tokens with tiktoken, using fallback method:', error.message);\n        // Fallback to a simple approximation (1 token \u2248 4 characters)\n        return Math.ceil(text.length / 4);\n      }\n    } else {\n      // Fallback to a simple approximation (1 token \u2248 4 characters)\n      return Math.ceil(text.length / 4);\n    }\n  }\n\n  /**\n   * Add to request token count (manual counting, less used now with recordUsage)\n   * @param {string|number} input - The text to count tokens for or the token count directly\n   */\n  addRequestTokens(input) {\n    let tokenCount = 0;\n\n    if (typeof input === 'number') {\n      tokenCount = input;\n    } else if (typeof input === 'string') {\n      tokenCount = this.countTokens(input);\n    } else {\n      console.warn('[WARN] Invalid input type for addRequestTokens:', typeof input);\n      return;\n    }\n\n    // This method primarily updates the *total* count historically.\n    // `recordUsage` is preferred for setting current/total based on LLM response.\n    this.requestTokens += tokenCount;\n    // Setting `currentRequestTokens` here might be misleading if `recordUsage` is called later.\n    // Let's make this method mainly for historical accumulation if needed,\n    // or ensure it's only called when `recordUsage` isn't available.\n    // For now, we'll update current as well, assuming it's for the *start* of a turn.\n    this.currentRequestTokens = tokenCount;\n\n    if (this.debug) {\n      console.log(`[DEBUG] (Manual) Added ${tokenCount} request tokens. Total: ${this.requestTokens}, Current: ${this.currentRequestTokens}`);\n    }\n  }\n\n  /**\n   * Add to response token count (manual counting, less used now with recordUsage)\n   * @param {string|number} input - The text to count tokens for or the token count directly\n   */\n  addResponseTokens(input) {\n    let tokenCount = 0;\n\n    if (typeof input === 'number') {\n      tokenCount = input;\n    } else if (typeof input === 'string') {\n      tokenCount = this.countTokens(input);\n    } else {\n      console.warn('[WARN] Invalid input type for addResponseTokens:', typeof input);\n      return;\n    }\n\n    this.responseTokens += tokenCount;\n    // Update current response tokens, assuming this is called when usage info is missing.\n    this.currentResponseTokens = tokenCount;\n\n    if (this.debug) {\n      console.log(`[DEBUG] (Manual) Added ${tokenCount} response tokens. Total: ${this.responseTokens}, Current: ${this.currentResponseTokens}`);\n    }\n  }\n\n  /**\n   * Record token usage from the AI SDK's result for a single LLM call.\n   * This resets 'current' counters and updates totals.\n   * @param {Object} usage - The usage object { promptTokens, completionTokens, totalTokens }\n   * @param {Object} providerMetadata - Metadata possibly containing cache info\n   */\n  recordUsage(usage, providerMetadata) {\n    if (!usage) {\n      console.warn('[WARN] No usage information provided to recordUsage');\n      // If usage is missing, maybe fall back to manual counting?\n      // For now, just return and rely on manual calls if needed.\n      return;\n    }\n\n    // --- Reset CURRENT counters for this specific API call ---\n    this.currentRequestTokens = 0;\n    this.currentResponseTokens = 0;\n    this.currentCacheCreationTokens = 0;\n    this.currentCacheReadTokens = 0;\n    this.currentCachedPromptTokens = 0;\n\n    // --- Process usage data ---\n    const promptTokens = Number(usage.promptTokens) || 0;\n    const completionTokens = Number(usage.completionTokens) || 0;\n\n    // Update CURRENT tokens for this call\n    this.currentRequestTokens = promptTokens;\n    this.currentResponseTokens = completionTokens;\n\n    // Update TOTAL tokens accumulated over the session\n    this.requestTokens += promptTokens;\n    this.responseTokens += completionTokens;\n\n    // --- Process Provider Metadata for Cache Info ---\n    if (providerMetadata?.anthropic) {\n      const cacheCreation = Number(providerMetadata.anthropic.cacheCreationInputTokens) || 0;\n      const cacheRead = Number(providerMetadata.anthropic.cacheReadInputTokens) || 0;\n\n      this.currentCacheCreationTokens = cacheCreation;\n      this.currentCacheReadTokens = cacheRead;\n\n      this.cacheCreationTokens += cacheCreation;\n      this.cacheReadTokens += cacheRead;\n\n      if (this.debug) {\n        console.log(`[DEBUG] Anthropic cache tokens (current): creation=${cacheCreation}, read=${cacheRead}`);\n      }\n    }\n\n    if (providerMetadata?.openai) {\n      const cachedPrompt = Number(providerMetadata.openai.cachedPromptTokens) || 0;\n\n      this.currentCachedPromptTokens = cachedPrompt;\n      this.cachedPromptTokens += cachedPrompt;\n\n      if (this.debug) {\n        console.log(`[DEBUG] OpenAI cached prompt tokens (current): ${cachedPrompt}`);\n      }\n    }\n\n    // Note: We don't force context recalculation here.\n    // It should be done explicitly after history is updated.\n\n    if (this.debug) {\n      console.log(\n        `[DEBUG] Recorded usage: current(req=${this.currentRequestTokens}, resp=${this.currentResponseTokens}), total(req=${this.requestTokens}, resp=${this.responseTokens})`\n      );\n      // Log cache totals\n      console.log(`[DEBUG] Total cache tokens: Anthropic(create=${this.cacheCreationTokens}, read=${this.cacheReadTokens}), OpenAI(prompt=${this.cachedPromptTokens})`);\n    }\n  }\n\n  /**\n   * Calculate the current context window size based on provided messages or internal history.\n   * @param {Array|null} messages - Optional messages array to use for calculation. If null, uses internal this.history.\n   * @returns {number} - Total tokens estimated in the context window.\n   */\n  calculateContextSize(messages = null) {\n    const msgsToCount = messages !== null ? messages : this.history;\n    let totalTokens = 0;\n\n    if (this.debug && messages === null) {\n      // Log only when using internal history to avoid spamming during loops using local messages array\n      console.log(`[DEBUG] Calculating context size from internal history (${this.history.length} messages)`);\n    }\n\n    for (const msg of msgsToCount) {\n      let messageTokens = 0;\n      // Add tokens for role overhead (approximate)\n      // Vercel SDK adds ~4 tokens per message for role/structure.\n      // Anthropic might be slightly different. Let's stick with 4 as an estimate.\n      messageTokens += 4;\n\n      // Content tokens\n      if (typeof msg.content === 'string') {\n        messageTokens += this.countTokens(msg.content);\n      } else if (Array.isArray(msg.content)) {\n        // Handle array content (e.g., Vercel AI SDK tool usage format with images)\n        for (const item of msg.content) {\n          if (item.type === 'text' && typeof item.text === 'string') {\n            messageTokens += this.countTokens(item.text);\n          } else if (item.type === 'image' && item.image) {\n            // For images, estimate token cost based on Anthropic/OpenAI pricing\n            // Base64 images typically cost ~1000-2000 tokens depending on size\n            if (item.image.startsWith('data:image/')) {\n              // Estimate based on base64 length - very rough approximation\n              const base64Length = item.image.length;\n              const estimatedImageTokens = Math.min(Math.max(Math.floor(base64Length / 1000), 500), 2000);\n              messageTokens += estimatedImageTokens;\n            } else {\n              // URL images, estimate moderate token cost\n              messageTokens += 1000;\n            }\n          } else {\n            // Estimate tokens for other non-text parts (tool calls/results)\n            messageTokens += this.countTokens(JSON.stringify(item));\n          }\n        }\n      } else if (msg.content) {\n        // Fallback for other content types\n        messageTokens += this.countTokens(JSON.stringify(msg.content));\n      }\n\n      // --- Add tokens for tool calls/results if present (Vercel SDK format) ---\n      // These might exist in 'assistant' or 'tool' messages depending on SDK version/usage\n      if (msg.toolCalls) {\n        messageTokens += this.countTokens(JSON.stringify(msg.toolCalls));\n        messageTokens += 5; // Approx overhead for tool_calls structure\n      }\n      // For 'tool' role messages (results)\n      if (msg.role === 'tool' && msg.toolCallId) {\n        messageTokens += this.countTokens(msg.toolCallId); // Add tokens for the ID\n        messageTokens += 5; // Approx overhead for tool role structure\n        // Content is already counted above\n      }\n      // Deprecated? Check if toolCallResults is still used\n      if (msg.toolCallResults) {\n        messageTokens += this.countTokens(JSON.stringify(msg.toolCallResults));\n        messageTokens += 5; // Approx overhead\n      }\n      // --- End Vercel SDK specific ---\n\n\n      totalTokens += messageTokens;\n\n      //   if (this.debug) {\n      //      // This log can be very noisy, disable for now\n      //     // console.log(`[DEBUG]   Msg (${msg.role}): ~${messageTokens} tokens`);\n      //   }\n    }\n\n    // Update the instance property *only* if calculating based on internal history\n    if (messages === null) {\n      this.contextSize = totalTokens;\n      if (this.debug) {\n        console.log(`[DEBUG] Updated internal context size: ${this.contextSize} tokens`);\n      }\n    }\n\n\n    return totalTokens;\n  }\n\n  /**\n   * Update internal history and recalculate internal context window size.\n   * @param {Array} messages - New message history array.\n   */\n  updateHistory(messages) {\n    // Ensure messages is an array\n    if (!Array.isArray(messages)) {\n      console.warn(\"[WARN] updateHistory called with non-array:\", messages);\n      this.history = [];\n    } else {\n      // Create a shallow copy to avoid external modifications\n      this.history = [...messages];\n    }\n    // Recalculate context size based on the new internal history\n    this.calculateContextSize(); // This updates this.contextSize\n    if (this.debug) {\n      console.log(`[DEBUG] History updated (${this.history.length} messages). Recalculated context size: ${this.contextSize}`);\n    }\n  }\n\n  /**\n   * Clear all counters and internal history. Reset context size.\n   */\n  clear() {\n    // Reset counters\n    this.requestTokens = 0;\n    this.responseTokens = 0;\n    this.currentRequestTokens = 0;\n    this.currentResponseTokens = 0;\n    this.cacheCreationTokens = 0;\n    this.cacheReadTokens = 0;\n    this.currentCacheCreationTokens = 0;\n    this.currentCacheReadTokens = 0;\n    this.cachedPromptTokens = 0;\n    this.currentCachedPromptTokens = 0;\n\n    // Clear history and context\n    this.history = [];\n    this.contextSize = 0; // Reset calculated context size\n\n    if (this.debug) {\n      console.log('[DEBUG] TokenCounter cleared: usage, history, and context size reset.');\n    }\n  }\n\n  /**\n   * Start a new conversation turn - reset CURRENT token counters.\n   * Calculates context size based on history *before* the new turn.\n   */\n  startNewTurn() {\n    this.currentRequestTokens = 0;\n    this.currentResponseTokens = 0;\n    this.currentCacheCreationTokens = 0;\n    this.currentCacheReadTokens = 0;\n    this.currentCachedPromptTokens = 0;\n\n    // Calculate context size based on current history *before* new messages are added\n    this.calculateContextSize(); // Updates this.contextSize\n\n    if (this.debug) {\n      console.log('[DEBUG] TokenCounter: New turn started. Current counters reset.');\n      console.log(`[DEBUG] Context size at start of turn: ${this.contextSize} tokens`);\n    }\n  }\n\n\n  /**\n   * Get the current token usage state including context size.\n   * Recalculates context size from internal history before returning.\n   * @returns {Object} - Object containing current turn, total session, and context window usage.\n   */\n  getTokenUsage() {\n    // Always calculate context window size from internal history right before returning usage\n    const currentContextSize = this.calculateContextSize(); // Recalculates and updates this.contextSize\n\n    // Consolidate cache info for simpler reporting\n    const currentCacheRead = this.currentCacheReadTokens + this.currentCachedPromptTokens;\n    const currentCacheWrite = this.currentCacheCreationTokens;\n    const totalCacheRead = this.cacheReadTokens + this.cachedPromptTokens;\n    const totalCacheWrite = this.cacheCreationTokens;\n\n    const usageData = {\n      contextWindow: currentContextSize, // Use the freshly calculated value\n      current: { // Usage for the *last* LLM call recorded\n        request: this.currentRequestTokens,\n        response: this.currentResponseTokens,\n        total: this.currentRequestTokens + this.currentResponseTokens,\n        cacheRead: currentCacheRead,\n        cacheWrite: currentCacheWrite,\n        cacheTotal: currentCacheRead + currentCacheWrite,\n        // Keep detailed breakdown if needed\n        anthropic: {\n          cacheCreation: this.currentCacheCreationTokens,\n          cacheRead: this.currentCacheReadTokens,\n        },\n        openai: {\n          cachedPrompt: this.currentCachedPromptTokens\n        }\n      },\n      total: { // Accumulated usage over the session\n        request: this.requestTokens,\n        response: this.responseTokens,\n        total: this.requestTokens + this.responseTokens,\n        cacheRead: totalCacheRead,\n        cacheWrite: totalCacheWrite,\n        cacheTotal: totalCacheRead + totalCacheWrite,\n        // Keep detailed breakdown if needed\n        anthropic: {\n          cacheCreation: this.cacheCreationTokens,\n          cacheRead: this.cacheReadTokens,\n        },\n        openai: {\n          cachedPrompt: this.cachedPromptTokens\n        }\n      }\n    };\n\n    if (this.debug) {\n      // Log less frequently or only when values change significantly?\n      // console.log(`[DEBUG] getTokenUsage() called. Returning data:`, JSON.stringify(usageData, null, 2));\n    }\n\n    return usageData;\n  }\n}", "import chalk from 'chalk';\n\n/**\n * TokenUsageDisplay class to format token usage information\n */\nexport class TokenUsageDisplay {\n\t/**\n\t * Format a number with commas\n\t * @param {number} num Number to format\n\t * @returns {string} Formatted number\n\t */\n\tformatNumber(num) {\n\t\treturn num.toLocaleString();\n\t}\n\n\t/**\n\t * Format cache tokens\n\t * @param {Object} tokens Token data\n\t * @returns {Object} Formatted cache data\n\t */\n\tformatCacheTokens(tokens = {}) {\n\t\t// Calculate total cache tokens from all providers\n\t\tconst totalCacheRead = tokens.cacheRead !== undefined ? tokens.cacheRead : (((tokens.anthropic || {}).cacheRead || 0) + ((tokens.openai || {}).cachedPrompt || 0));\n\t\tconst totalCacheWrite = tokens.cacheWrite !== undefined ? tokens.cacheWrite : ((tokens.anthropic || {}).cacheCreation || 0);\n\t\tconst totalCache = tokens.cacheTotal !== undefined ? tokens.cacheTotal : (totalCacheRead + totalCacheWrite);\n\n\t\t// Return consolidated cache data\n\t\treturn {\n\t\t\tread: this.formatNumber(totalCacheRead),\n\t\t\twrite: this.formatNumber(totalCacheWrite),\n\t\t\ttotal: this.formatNumber(totalCache)\n\t\t};\n\t}\n\n\t/**\n\t * Format usage data for UI display\n\t * @param {Object} usage Token usage data\n\t * @returns {Object} Formatted usage data\n\t */\n\tformat(usage) {\n\t\t// Ensure we have a valid context window value\n\t\tconst contextWindow = usage.contextWindow || 100;\n\n\t\t// Ensure usage.current exists\n\t\tconst current = usage.current || {};\n\n\t\t// Format the usage data for display\n\t\tconst formatted = {\n\t\t\tcontextWindow: this.formatNumber(contextWindow),\n\t\t\tcurrent: {\n\t\t\t\trequest: this.formatNumber(current.request || 0),\n\t\t\t\tresponse: this.formatNumber(current.response || 0),\n\t\t\t\ttotal: this.formatNumber(current.total || 0),\n\t\t\t\tcacheRead: this.formatNumber(current.cacheRead || 0),\n\t\t\t\tcacheWrite: this.formatNumber(current.cacheWrite || 0),\n\t\t\t\tcache: this.formatCacheTokens(current)\n\t\t\t},\n\t\t\ttotal: {\n\t\t\t\trequest: this.formatNumber((usage.total || {}).request || 0),\n\t\t\t\tresponse: this.formatNumber((usage.total || {}).response || 0),\n\t\t\t\ttotal: this.formatNumber((usage.total || {}).total || 0),\n\t\t\t\tcacheRead: this.formatNumber((usage.total || {}).cacheRead || 0),\n\t\t\t\tcacheWrite: this.formatNumber((usage.total || {}).cacheWrite || 0),\n\t\t\t\tcache: this.formatCacheTokens(usage.total || {})\n\t\t\t}\n\t\t};\n\n\t\treturn formatted;\n\t}\n}", "import { createWriteStream } from 'fs';\nimport corePkg from '@opentelemetry/core';\n\nconst { ExportResultCode } = corePkg;\n\n/**\n * File exporter for OpenTelemetry spans\n * Exports spans to a file in JSON Lines format (one JSON object per line)\n * Following the OTLP JSON format specification\n */\nexport class FileSpanExporter {\n  constructor(filePath = './traces.jsonl') {\n    this.filePath = filePath;\n    this.stream = createWriteStream(filePath, { flags: 'a' });\n    this.stream.on('error', (error) => {\n      console.error(`[FileSpanExporter] Stream error: ${error.message}`);\n    });\n  }\n\n  /**\n   * Export spans to file\n   * @param {ReadableSpan[]} spans - Array of spans to export\n   * @param {function} resultCallback - Callback to call with the export result\n   */\n  export(spans, resultCallback) {\n    if (!spans || spans.length === 0) {\n      resultCallback({ code: ExportResultCode.SUCCESS });\n      return;\n    }\n\n    try {\n      const timestamp = Date.now();\n      \n      spans.forEach((span, index) => {\n        // Debug: Log first span's properties to understand structure\n        if (index === 0 && process.env.DEBUG_CHAT === '1') {\n          console.log('[FileSpanExporter] First span properties:');\n          const keys = Object.getOwnPropertyNames(span);\n          keys.forEach(key => {\n            if (key.toLowerCase().includes('parent') || key === '_spanContext' || key === 'parentContext') {\n              console.log(`  ${key}:`, span[key]);\n            }\n          });\n        }\n        \n        // Extract parent span ID - check various possible properties\n        let parentSpanId = undefined;\n        \n        // Check if there's a parent span context in the span\n        if (span.parentSpanContext) {\n          parentSpanId = span.parentSpanContext.spanId;\n        } else if (span._parentSpanContext) {\n          parentSpanId = span._parentSpanContext.spanId;\n        } else if (span.parent) {\n          parentSpanId = span.parent.spanId;\n        } else if (span._parent) {\n          parentSpanId = span._parent.spanId;\n        } else if (span._parentId) {\n          parentSpanId = span._parentId;\n        } else if (span.parentSpanId) {\n          parentSpanId = span.parentSpanId;\n        }\n        \n        // Convert span to OTLP JSON format\n        const spanData = {\n          traceId: span.spanContext().traceId,\n          spanId: span.spanContext().spanId,\n          parentSpanId: parentSpanId,\n          name: span.name,\n          kind: span.kind,\n          startTimeUnixNano: span.startTime[0] * 1_000_000_000 + span.startTime[1],\n          endTimeUnixNano: span.endTime[0] * 1_000_000_000 + span.endTime[1],\n          attributes: this.convertAttributes(span.attributes),\n          status: span.status,\n          events: span.events?.map(event => ({\n            timeUnixNano: event.time[0] * 1_000_000_000 + event.time[1],\n            name: event.name,\n            attributes: this.convertAttributes(event.attributes),\n          })) || [],\n          links: span.links?.map(link => ({\n            traceId: link.context.traceId,\n            spanId: link.context.spanId,\n            attributes: this.convertAttributes(link.attributes),\n          })) || [],\n          resource: {\n            attributes: this.convertAttributes(span.resource?.attributes || {}),\n          },\n          instrumentationLibrary: {\n            name: span.instrumentationLibrary?.name || 'unknown',\n            version: span.instrumentationLibrary?.version || 'unknown',\n          },\n          timestamp,\n        };\n\n        // Write as JSON Lines format (one JSON object per line)\n        this.stream.write(JSON.stringify(spanData) + '\\n');\n      });\n\n      resultCallback({ code: ExportResultCode.SUCCESS });\n    } catch (error) {\n      console.error(`[FileSpanExporter] Export error: ${error.message}`);\n      resultCallback({ \n        code: ExportResultCode.FAILED, \n        error: error \n      });\n    }\n  }\n\n  /**\n   * Convert OpenTelemetry attributes to plain object\n   * @param {Object} attributes - OpenTelemetry attributes\n   * @returns {Object} Plain object with string values\n   */\n  convertAttributes(attributes) {\n    if (!attributes) return {};\n    \n    const result = {};\n    for (const [key, value] of Object.entries(attributes)) {\n      // Convert all values to strings for JSON compatibility\n      if (typeof value === 'object' && value !== null) {\n        result[key] = JSON.stringify(value);\n      } else {\n        result[key] = String(value);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Shutdown the exporter\n   * @returns {Promise<void>}\n   */\n  async shutdown() {\n    return new Promise((resolve) => {\n      if (this.stream) {\n        this.stream.end(() => {\n          console.log(`[FileSpanExporter] File stream closed: ${this.filePath}`);\n          resolve();\n        });\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  /**\n   * Force flush any pending spans\n   * @returns {Promise<void>}\n   */\n  async forceFlush() {\n    return new Promise((resolve, reject) => {\n      if (this.stream) {\n        // CRITICAL FIX: Force the stream to flush all buffered data\n        // Use both drain event and explicit cork/uncork to ensure data is written\n        const flushTimeout = setTimeout(() => {\n          console.warn('[FileSpanExporter] Flush timeout after 5 seconds');\n          resolve();\n        }, 5000);\n        \n        // Uncork the stream to force buffered writes\n        if (this.stream.writableCorked) {\n          this.stream.uncork();\n        }\n        \n        // If there's buffered data, wait for drain event\n        if (this.stream.writableNeedDrain) {\n          this.stream.once('drain', () => {\n            clearTimeout(flushTimeout);\n            resolve();\n          });\n        } else {\n          // No buffered data, but still give it a moment to ensure writes complete\n          setImmediate(() => {\n            clearTimeout(flushTimeout);\n            resolve();\n          });\n        }\n      } else {\n        resolve();\n      }\n    });\n  }\n}", "import nodeSDKPkg from '@opentelemetry/sdk-node';\nimport resourcesPkg from '@opentelemetry/resources';\nimport semanticConventionsPkg from '@opentelemetry/semantic-conventions';\nimport { trace, context } from '@opentelemetry/api';\nimport otlpPkg from '@opentelemetry/exporter-trace-otlp-http';\nimport spanPkg from '@opentelemetry/sdk-trace-base';\nimport { existsSync, mkdirSync } from 'fs';\nimport { dirname } from 'path';\nimport { FileSpanExporter } from './fileSpanExporter.js';\n\nconst { NodeSDK } = nodeSDKPkg;\nconst { resourceFromAttributes } = resourcesPkg;\nconst { ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION } = semanticConventionsPkg;\nconst { OTLPTraceExporter } = otlpPkg;\nconst { BatchSpanProcessor, ConsoleSpanExporter } = spanPkg;\n\n/**\n * Custom OpenTelemetry configuration for probe-chat\n */\nexport class TelemetryConfig {\n  constructor(options = {}) {\n    this.serviceName = options.serviceName || 'probe-chat';\n    this.serviceVersion = options.serviceVersion || '1.0.0';\n    this.enableFile = options.enableFile || false;\n    this.enableRemote = options.enableRemote || false;\n    this.enableConsole = options.enableConsole || false;\n    this.filePath = options.filePath || './traces.jsonl';\n    this.remoteEndpoint = options.remoteEndpoint || 'http://localhost:4318/v1/traces';\n    this.sdk = null;\n    this.tracer = null;\n  }\n\n  /**\n   * Initialize OpenTelemetry SDK\n   */\n  initialize() {\n    if (this.sdk) {\n      if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n        console.warn('Telemetry already initialized');\n      }\n      return;\n    }\n\n    const resource = resourceFromAttributes({\n      [ATTR_SERVICE_NAME]: this.serviceName,\n      [ATTR_SERVICE_VERSION]: this.serviceVersion,\n    });\n\n    const spanProcessors = [];\n\n    // Add file exporter if enabled\n    if (this.enableFile) {\n      try {\n        // Ensure the directory exists\n        const dir = dirname(this.filePath);\n        if (!existsSync(dir)) {\n          mkdirSync(dir, { recursive: true });\n        }\n        \n        const fileExporter = new FileSpanExporter(this.filePath);\n        // CRITICAL FIX: Configure BatchSpanProcessor with shorter delays for better span export\n        spanProcessors.push(new BatchSpanProcessor(fileExporter, {\n          // The maximum queue size. After the size is reached spans are dropped.\n          maxQueueSize: 2048,\n          // The maximum batch size of every export. It must be smaller or equal to maxQueueSize.\n          maxExportBatchSize: 512,\n          // The interval between two consecutive exports\n          scheduledDelayMillis: 500, // Reduced from default 5000ms\n          // How long the export can run before it is cancelled\n          exportTimeoutMillis: 30000,\n        }));\n        if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n          console.log(`[Telemetry] File exporter enabled, writing to: ${this.filePath}`);\n        }\n      } catch (error) {\n        if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n          console.error(`[Telemetry] Failed to initialize file exporter: ${error.message}`);\n        }\n      }\n    }\n\n    // Add remote exporter if enabled\n    if (this.enableRemote) {\n      try {\n        const remoteExporter = new OTLPTraceExporter({\n          url: this.remoteEndpoint,\n        });\n        // Configure BatchSpanProcessor with shorter delays for better span export\n        spanProcessors.push(new BatchSpanProcessor(remoteExporter, {\n          maxQueueSize: 2048,\n          maxExportBatchSize: 512,\n          scheduledDelayMillis: 500, // Reduced from default 5000ms\n          exportTimeoutMillis: 30000,\n        }));\n        if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n          console.log(`[Telemetry] Remote exporter enabled, endpoint: ${this.remoteEndpoint}`);\n        }\n      } catch (error) {\n        if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n          console.error(`[Telemetry] Failed to initialize remote exporter: ${error.message}`);\n        }\n      }\n    }\n\n    // Add console exporter if enabled (useful for debugging)\n    if (this.enableConsole) {\n      const consoleExporter = new ConsoleSpanExporter();\n      // Configure BatchSpanProcessor with shorter delays for better span export\n      spanProcessors.push(new BatchSpanProcessor(consoleExporter, {\n        maxQueueSize: 2048,\n        maxExportBatchSize: 512,\n        scheduledDelayMillis: 500, // Reduced from default 5000ms\n        exportTimeoutMillis: 30000,\n      }));\n      if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n        console.log(`[Telemetry] Console exporter enabled`);\n      }\n    }\n\n    if (spanProcessors.length === 0) {\n      if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n        console.log('[Telemetry] No exporters configured, telemetry will not be collected');\n      }\n      return;\n    }\n\n    this.sdk = new NodeSDK({\n      resource,\n      spanProcessors,\n    });\n\n    try {\n      this.sdk.start();\n      this.tracer = trace.getTracer(this.serviceName, this.serviceVersion);\n      if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n        console.log(`[Telemetry] OpenTelemetry SDK initialized successfully`);\n      }\n    } catch (error) {\n      if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n        console.error(`[Telemetry] Failed to start OpenTelemetry SDK: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * Get the tracer instance\n   */\n  getTracer() {\n    return this.tracer;\n  }\n\n  /**\n   * Create a span with the given name and attributes\n   */\n  createSpan(name, attributes = {}) {\n    if (!this.tracer) {\n      return null;\n    }\n\n    return this.tracer.startSpan(name, {\n      attributes,\n    });\n  }\n\n  /**\n   * Wrap a function to automatically create spans\n   */\n  wrapFunction(name, fn, attributes = {}) {\n    if (!this.tracer) {\n      return fn;\n    }\n\n    return async (...args) => {\n      const span = this.createSpan(name, attributes);\n      if (!span) {\n        return fn(...args);\n      }\n\n      try {\n        const result = await context.with(trace.setSpan(context.active(), span), () => fn(...args));\n        span.setStatus({ code: trace.SpanStatusCode.OK });\n        return result;\n      } catch (error) {\n        span.setStatus({\n          code: trace.SpanStatusCode.ERROR,\n          message: error.message,\n        });\n        span.recordException(error);\n        throw error;\n      } finally {\n        span.end();\n      }\n    };\n  }\n\n  /**\n   * Force flush all pending spans\n   */\n  async forceFlush() {\n    if (this.sdk) {\n      try {\n        // Get the active tracer provider\n        const tracerProvider = trace.getTracerProvider();\n        \n        if (tracerProvider && typeof tracerProvider.forceFlush === 'function') {\n          // Call forceFlush on the tracer provider\n          await tracerProvider.forceFlush();\n          \n          if (process.env.DEBUG_CHAT === '1') {\n            console.log('[Telemetry] TracerProvider flushed successfully');\n          }\n        }\n        \n        // Also try to access registered span processors directly for better control\n        if (tracerProvider._registeredSpanProcessors) {\n          const flushPromises = [];\n          \n          for (const processor of tracerProvider._registeredSpanProcessors) {\n            if (typeof processor.forceFlush === 'function') {\n              flushPromises.push(processor.forceFlush());\n            }\n          }\n          \n          if (flushPromises.length > 0) {\n            await Promise.all(flushPromises);\n            \n            if (process.env.DEBUG_CHAT === '1') {\n              console.log(`[Telemetry] Directly flushed ${flushPromises.length} span processors`);\n            }\n          }\n        }\n        \n        // Add a small delay to ensure file writes complete\n        await new Promise(resolve => setTimeout(resolve, 100));\n        \n        if (process.env.DEBUG_CHAT === '1') {\n          console.log('[Telemetry] OpenTelemetry spans flushed successfully');\n        }\n      } catch (error) {\n        if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n          console.error(`[Telemetry] Failed to flush OpenTelemetry spans: ${error.message}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Shutdown telemetry\n   */\n  async shutdown() {\n    if (this.sdk) {\n      try {\n        await this.sdk.shutdown();\n        if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n          console.log('[Telemetry] OpenTelemetry SDK shutdown successfully');\n        }\n      } catch (error) {\n        if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n          console.error(`[Telemetry] Failed to shutdown OpenTelemetry SDK: ${error.message}`);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Default telemetry configuration\n */\nexport const defaultTelemetryConfig = new TelemetryConfig();\n\n/**\n * Initialize telemetry from environment variables\n */\nexport function initializeTelemetryFromEnv() {\n  const config = new TelemetryConfig({\n    serviceName: process.env.OTEL_SERVICE_NAME || 'probe-chat',\n    serviceVersion: process.env.OTEL_SERVICE_VERSION || '1.0.0',\n    enableFile: process.env.OTEL_ENABLE_FILE === 'true',\n    enableRemote: process.env.OTEL_ENABLE_REMOTE === 'true',\n    enableConsole: process.env.OTEL_ENABLE_CONSOLE === 'true',\n    filePath: process.env.OTEL_FILE_PATH || './traces.jsonl',\n    remoteEndpoint: process.env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT || 'http://localhost:4318/v1/traces',\n  });\n\n  config.initialize();\n  return config;\n}", "/**\n * Custom Application Tracing Layer for Probe Chat\n * \n * This module provides granular tracing that follows application logic closely,\n * replacing the generic Vercel AI SDK tracing with application-specific spans.\n */\n\nimport { trace, SpanStatusCode, SpanKind, context, TraceFlags } from '@opentelemetry/api';\nimport { randomUUID, createHash } from 'crypto';\n\n/**\n * Convert a session ID to a valid OpenTelemetry trace ID (32-char hex)\n */\nfunction sessionIdToTraceId(sessionId) {\n  // Create a hash of the session ID and take first 32 chars\n  const hash = createHash('sha256').update(sessionId).digest('hex');\n  return hash.substring(0, 32);\n}\n\n// OpenTelemetry semantic conventions and custom attributes\nconst OTEL_ATTRS = {\n  // Standard semantic conventions\n  SERVICE_NAME: 'service.name',\n  SERVICE_VERSION: 'service.version',\n  HTTP_METHOD: 'http.method',\n  HTTP_STATUS_CODE: 'http.status_code',\n  ERROR_TYPE: 'error.type',\n  ERROR_MESSAGE: 'error.message',\n  \n  // Custom application attributes following OpenTelemetry naming conventions\n  APP_SESSION_ID: 'app.session.id',\n  APP_MESSAGE_TYPE: 'app.message.type',\n  APP_MESSAGE_CONTENT: 'app.message.content',\n  APP_MESSAGE_LENGTH: 'app.message.length',\n  APP_MESSAGE_HASH: 'app.message.hash',\n  APP_AI_PROVIDER: 'app.ai.provider',\n  APP_AI_MODEL: 'app.ai.model',\n  APP_AI_TEMPERATURE: 'app.ai.temperature',\n  APP_AI_MAX_TOKENS: 'app.ai.max_tokens',\n  APP_AI_RESPONSE_CONTENT: 'app.ai.response.content',\n  APP_AI_RESPONSE_LENGTH: 'app.ai.response.length',\n  APP_AI_RESPONSE_HASH: 'app.ai.response.hash',\n  APP_AI_COMPLETION_TOKENS: 'app.ai.completion_tokens',\n  APP_AI_PROMPT_TOKENS: 'app.ai.prompt_tokens',\n  APP_AI_FINISH_REASON: 'app.ai.finish_reason',\n  APP_TOOL_NAME: 'app.tool.name',\n  APP_TOOL_PARAMS: 'app.tool.params',\n  APP_TOOL_RESULT: 'app.tool.result',\n  APP_TOOL_SUCCESS: 'app.tool.success',\n  APP_ITERATION_NUMBER: 'app.iteration.number'\n};\n\nclass AppTracer {\n  constructor() {\n    // Use consistent tracer name across the application\n    this.tracer = trace.getTracer('probe-chat', '1.0.0');\n    this.activeSpans = new Map();\n    this.sessionSpans = new Map();\n    this.sessionContexts = new Map(); // Store active context for each session\n  }\n\n  /**\n   * Get the shared tracer instance\n   */\n  getTracer() {\n    return this.tracer;\n  }\n\n  /**\n   * Hash a string for deduplication purposes\n   */\n  _hashString(str) {\n    let hash = 0;\n    if (str.length === 0) return hash;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash.toString();\n  }\n\n  /**\n   * Get the active context for a session, creating spans within the session trace\n   */\n  _getSessionContext(sessionId) {\n    return this.sessionContexts.get(sessionId) || context.active();\n  }\n\n  /**\n   * Start a chat session span with custom trace ID based on session ID\n   */\n  startChatSession(sessionId, userMessage, provider, model) {\n    if (process.env.DEBUG_CHAT === '1') {\n      console.log(`[DEBUG] AppTracer: Starting chat session span for ${sessionId}`);\n    }\n    \n    // Create a custom trace ID from the session ID\n    const traceId = sessionIdToTraceId(sessionId);\n    \n    // Generate a span ID for the root span\n    const spanId = randomUUID().replace(/-/g, '').substring(0, 16);\n    \n    // Create trace context with custom trace ID\n    const spanContext = {\n      traceId: traceId,\n      spanId: spanId,\n      traceFlags: TraceFlags.SAMPLED,\n      isRemote: false\n    };\n    \n    // Create a new context with our custom trace context\n    const activeContext = trace.setSpanContext(context.active(), spanContext);\n    \n    // Start the span within this custom context\n    const span = context.with(activeContext, () => {\n      return this.tracer.startSpan('messaging.process', {\n        kind: SpanKind.SERVER,\n        attributes: {\n          [OTEL_ATTRS.APP_SESSION_ID]: sessionId,\n          [OTEL_ATTRS.APP_MESSAGE_CONTENT]: userMessage.substring(0, 500), // Capture more message content\n          [OTEL_ATTRS.APP_MESSAGE_LENGTH]: userMessage.length,\n          [OTEL_ATTRS.APP_MESSAGE_HASH]: this._hashString(userMessage), // Add hash for deduplication\n          [OTEL_ATTRS.APP_AI_PROVIDER]: provider,\n          [OTEL_ATTRS.APP_AI_MODEL]: model,\n          'app.session.start_time': Date.now(),\n          'app.trace.custom_id': true // Mark that we're using custom trace ID\n        }\n      });\n    });\n\n    if (process.env.DEBUG_CHAT === '1') {\n      console.log(`[DEBUG] AppTracer: Created chat session span ${span.spanContext().spanId} in trace ${span.spanContext().traceId}`);\n    }\n\n    // Create session context with the span as the active span\n    const sessionContext = trace.setSpan(context.active(), span);\n    this.sessionContexts.set(sessionId, sessionContext);\n    this.sessionSpans.set(sessionId, span);\n    \n    if (process.env.DEBUG_CHAT === '1') {\n      console.log(`[DEBUG] AppTracer: Session context established for ${sessionId}`);\n    }\n    \n    return span;\n  }\n\n  /**\n   * Execute a function within the session context to ensure proper trace correlation\n   */\n  withSessionContext(sessionId, fn) {\n    const sessionContext = this._getSessionContext(sessionId);\n    return context.with(sessionContext, fn);\n  }\n\n  /**\n   * Get the trace ID for a session (derived from session ID)\n   */\n  getTraceIdForSession(sessionId) {\n    return sessionIdToTraceId(sessionId);\n  }\n\n  /**\n   * Start processing a user message\n   */\n  startUserMessageProcessing(sessionId, messageId, message, imageUrlsFound = 0) {\n    if (process.env.DEBUG_CHAT === '1') {\n      console.log(`[DEBUG] AppTracer: Starting user message processing span for ${sessionId}`);\n    }\n    \n    const sessionContext = this._getSessionContext(sessionId);\n    \n    return context.with(sessionContext, () => {\n      // Get the parent span (should be the session span) from the context\n      const parentSpan = trace.getActiveSpan();\n      const spanOptions = {\n        kind: SpanKind.INTERNAL,\n        attributes: {\n          [OTEL_ATTRS.APP_SESSION_ID]: sessionId,\n          'app.message.id': messageId,\n          [OTEL_ATTRS.APP_MESSAGE_TYPE]: 'user',\n          [OTEL_ATTRS.APP_MESSAGE_CONTENT]: message.substring(0, 1000), // Include actual message content\n          [OTEL_ATTRS.APP_MESSAGE_LENGTH]: message.length,\n          [OTEL_ATTRS.APP_MESSAGE_HASH]: this._hashString(message),\n          'app.message.image_urls_found': imageUrlsFound,\n          'app.processing.start_time': Date.now()\n        }\n      };\n      \n      // Explicitly set the parent if available\n      if (parentSpan) {\n        spanOptions.parent = parentSpan.spanContext();\n      }\n      \n      const span = this.tracer.startSpan('messaging.message.process', spanOptions);\n      \n      if (process.env.DEBUG_CHAT === '1') {\n        console.log(`[DEBUG] AppTracer: Created user message processing span ${span.spanContext().spanId} with parent ${parentSpan?.spanContext().spanId}`);\n      }\n      \n      this.activeSpans.set(`${sessionId}_user_processing`, span);\n      // DO NOT overwrite the session context - this breaks parent-child relationships\n      // Instead, create a temporary context for this message processing without storing it\n      const messageContext = trace.setSpan(sessionContext, span);\n      // Store the message context temporarily for child operations, but keep session context intact\n      this.sessionContexts.set(`${sessionId}_message_processing`, messageContext);\n      return span;\n    });\n  }\n\n  /**\n   * Execute a function within the context of user message processing span\n   */\n  withUserProcessingContext(sessionId, fn) {\n    const span = this.activeSpans.get(`${sessionId}_user_processing`);\n    if (span) {\n      return context.with(trace.setSpan(context.active(), span), fn);\n    }\n    return fn();\n  }\n\n  /**\n   * Start the agent loop\n   */\n  startAgentLoop(sessionId, maxIterations) {\n    const sessionContext = this._getSessionContext(sessionId);\n    \n    return context.with(sessionContext, () => {\n      // Get the parent span from the context\n      const parentSpan = trace.getActiveSpan();\n      const spanOptions = {\n        kind: SpanKind.INTERNAL,\n        attributes: {\n          'app.session.id': sessionId,\n          'app.loop.max_iterations': maxIterations,\n          'app.loop.start_time': Date.now()\n        }\n      };\n      \n      // Explicitly set the parent if available\n      if (parentSpan) {\n        spanOptions.parent = parentSpan.spanContext();\n      }\n      \n      const span = this.tracer.startSpan('agent.loop.start', spanOptions);\n      \n      this.activeSpans.set(`${sessionId}_agent_loop`, span);\n      // DO NOT overwrite the session context - store agent loop context separately\n      const agentLoopContext = trace.setSpan(sessionContext, span);\n      this.sessionContexts.set(`${sessionId}_agent_loop`, agentLoopContext);\n      return span;\n    });\n  }\n\n  /**\n   * Execute a function within the context of agent loop span\n   */\n  withAgentLoopContext(sessionId, fn) {\n    const span = this.activeSpans.get(`${sessionId}_agent_loop`);\n    if (span) {\n      return context.with(trace.setSpan(context.active(), span), fn);\n    }\n    return fn();\n  }\n\n  /**\n   * Start a single iteration of the agent loop\n   */\n  startAgentIteration(sessionId, iterationNumber, messagesCount, contextTokens) {\n    const sessionContext = this._getSessionContext(sessionId);\n    \n    return context.with(sessionContext, () => {\n      const span = this.tracer.startSpan('agent.loop.iteration', {\n        kind: SpanKind.INTERNAL,\n        attributes: {\n          'app.session.id': sessionId,\n          'app.iteration.number': iterationNumber,\n          'app.iteration.messages_count': messagesCount,\n          'app.iteration.context_tokens': contextTokens,\n          'app.iteration.start_time': Date.now()\n        }\n      });\n      \n      this.activeSpans.set(`${sessionId}_iteration_${iterationNumber}`, span);\n      // DO NOT overwrite the session context - store iteration context separately\n      const iterationContext = trace.setSpan(sessionContext, span);\n      this.sessionContexts.set(`${sessionId}_iteration_${iterationNumber}`, iterationContext);\n      return span;\n    });\n  }\n\n  /**\n   * Execute a function within the context of agent iteration span\n   */\n  withIterationContext(sessionId, iterationNumber, fn) {\n    const span = this.activeSpans.get(`${sessionId}_iteration_${iterationNumber}`);\n    if (span) {\n      return context.with(trace.setSpan(context.active(), span), fn);\n    }\n    return fn();\n  }\n\n  /**\n   * Start an AI generation request\n   */\n  startAiGenerationRequest(sessionId, iterationNumber, model, provider, settings = {}, messagesContext = []) {\n    if (process.env.DEBUG_CHAT === '1') {\n      console.log(`[DEBUG] AppTracer: Starting AI generation request span for session ${sessionId}, iteration ${iterationNumber}`);\n    }\n    \n    // Get the most appropriate context - prefer iteration context over session context\n    const iterationContext = this.sessionContexts.get(`${sessionId}_iteration_${iterationNumber}`);\n    const sessionContext = iterationContext || this._getSessionContext(sessionId);\n    \n    return context.with(sessionContext, () => {\n      const span = this.tracer.startSpan('ai.generation.request', {\n        kind: SpanKind.CLIENT,\n        attributes: {\n          [OTEL_ATTRS.APP_SESSION_ID]: sessionId,\n          [OTEL_ATTRS.APP_ITERATION_NUMBER]: iterationNumber,\n          [OTEL_ATTRS.APP_AI_MODEL]: model,\n          [OTEL_ATTRS.APP_AI_PROVIDER]: provider,\n          [OTEL_ATTRS.APP_AI_TEMPERATURE]: settings.temperature || 0,\n          [OTEL_ATTRS.APP_AI_MAX_TOKENS]: settings.maxTokens || 0,\n          'app.ai.max_retries': settings.maxRetries || 0,\n          'app.ai.messages_count': messagesContext.length,\n          'app.ai.request_start_time': Date.now()\n        }\n      });\n      \n      if (process.env.DEBUG_CHAT === '1') {\n        console.log(`[DEBUG] AppTracer: Created AI generation span ${span.spanContext().spanId}`);\n      }\n      \n      this.activeSpans.set(`${sessionId}_ai_request_${iterationNumber}`, span);\n      // Store AI request context separately, don't overwrite session context\n      const aiRequestContext = trace.setSpan(sessionContext, span);\n      this.sessionContexts.set(`${sessionId}_ai_request_${iterationNumber}`, aiRequestContext);\n      return span;\n    });\n  }\n\n  /**\n   * Record AI response received\n   */\n  recordAiResponse(sessionId, iterationNumber, responseData) {\n    const sessionContext = this._getSessionContext(sessionId);\n    \n    return context.with(sessionContext, () => {\n      const span = this.tracer.startSpan('ai.generation.response', {\n        kind: SpanKind.INTERNAL,\n        attributes: {\n          [OTEL_ATTRS.APP_SESSION_ID]: sessionId,\n          [OTEL_ATTRS.APP_ITERATION_NUMBER]: iterationNumber,\n          [OTEL_ATTRS.APP_AI_RESPONSE_CONTENT]: responseData.response ? responseData.response.substring(0, 2000) : '', // Include actual response content\n          [OTEL_ATTRS.APP_AI_RESPONSE_LENGTH]: responseData.responseLength || (responseData.response ? responseData.response.length : 0),\n          [OTEL_ATTRS.APP_AI_RESPONSE_HASH]: responseData.response ? this._hashString(responseData.response) : '',\n          [OTEL_ATTRS.APP_AI_COMPLETION_TOKENS]: responseData.completionTokens || 0,\n          [OTEL_ATTRS.APP_AI_PROMPT_TOKENS]: responseData.promptTokens || 0,\n          [OTEL_ATTRS.APP_AI_FINISH_REASON]: responseData.finishReason || 'unknown',\n          'app.ai.response.time_to_first_chunk_ms': responseData.timeToFirstChunk || 0,\n          'app.ai.response.time_to_finish_ms': responseData.timeToFinish || 0,\n          'app.ai.response.received_time': Date.now()\n        }\n      });\n      \n      // End the span immediately since this is just recording the response\n      span.setStatus({ code: SpanStatusCode.OK });\n      span.end();\n      return span;\n    });\n  }\n\n  /**\n   * Record a parsed tool call\n   */\n  recordToolCallParsed(sessionId, iterationNumber, toolName, toolParams) {\n    const aiRequestSpan = this.activeSpans.get(`${sessionId}_ai_request_${iterationNumber}`);\n    const spanOptions = {\n      kind: SpanKind.INTERNAL,\n      attributes: {\n        'app.session.id': sessionId,\n        'app.tool.name': toolName,\n        'app.tool.params': JSON.stringify(toolParams).substring(0, 500), // Truncate large params\n        'app.tool.parsed_time': Date.now()\n      }\n    };\n\n    if (aiRequestSpan) {\n      spanOptions.parent = aiRequestSpan.spanContext();\n    }\n\n    const span = this.tracer.startSpan('tool.call.parse', spanOptions);\n    \n    // End immediately since this is just recording the parsing\n    span.setStatus({ code: SpanStatusCode.OK });\n    span.end();\n\n    return span;\n  }\n\n  /**\n   * Start tool execution\n   */\n  startToolExecution(sessionId, iterationNumber, toolName, toolParams) {\n    // Get the most appropriate context - prefer AI request context over session context  \n    const aiRequestContext = this.sessionContexts.get(`${sessionId}_ai_request_${iterationNumber}`);\n    const sessionContext = aiRequestContext || this._getSessionContext(sessionId);\n    \n    return context.with(sessionContext, () => {\n      const span = this.tracer.startSpan('tool.call', {\n        kind: SpanKind.INTERNAL,\n        attributes: {\n          [OTEL_ATTRS.APP_SESSION_ID]: sessionId,\n          [OTEL_ATTRS.APP_ITERATION_NUMBER]: iterationNumber,\n          [OTEL_ATTRS.APP_TOOL_NAME]: toolName,\n          [OTEL_ATTRS.APP_TOOL_PARAMS]: JSON.stringify(toolParams).substring(0, 1000), // Include actual tool parameters\n          'app.tool.params.hash': this._hashString(JSON.stringify(toolParams)),\n          'app.tool.execution_start_time': Date.now(),\n          // Add specific attributes based on tool type\n          ...(toolName === 'search' && toolParams.query ? { 'app.tool.search.query': toolParams.query } : {}),\n          ...(toolName === 'extract' && toolParams.file_path ? { 'app.tool.extract.file_path': toolParams.file_path } : {}),\n          ...(toolName === 'query' && toolParams.pattern ? { 'app.tool.query.pattern': toolParams.pattern } : {}),\n        }\n      });\n      \n      this.activeSpans.set(`${sessionId}_tool_execution_${iterationNumber}`, span);\n      // Store tool execution context separately, don't overwrite session context\n      const toolExecutionContext = trace.setSpan(sessionContext, span);\n      this.sessionContexts.set(`${sessionId}_tool_execution_${iterationNumber}`, toolExecutionContext);\n      return span;\n    });\n  }\n\n  /**\n   * End tool execution with results\n   */\n  endToolExecution(sessionId, iterationNumber, success, resultLength = 0, errorMessage = null, result = null) {\n    const span = this.activeSpans.get(`${sessionId}_tool_execution_${iterationNumber}`);\n    if (!span) return;\n\n    const attributes = {\n      [OTEL_ATTRS.APP_TOOL_SUCCESS]: success,\n      'app.tool.result_length': resultLength,\n      'app.tool.execution_end_time': Date.now(),\n      ...(errorMessage ? { [OTEL_ATTRS.ERROR_MESSAGE]: errorMessage } : {}),\n      ...(result ? { \n        [OTEL_ATTRS.APP_TOOL_RESULT]: typeof result === 'string' ? result.substring(0, 2000) : JSON.stringify(result).substring(0, 2000),\n        'app.tool.result.hash': this._hashString(typeof result === 'string' ? result : JSON.stringify(result))\n      } : {})\n    };\n\n    span.setAttributes(attributes);\n\n    span.setStatus({\n      code: success ? SpanStatusCode.OK : SpanStatusCode.ERROR,\n      message: errorMessage\n    });\n\n    span.end();\n    this.activeSpans.delete(`${sessionId}_tool_execution_${iterationNumber}`);\n  }\n\n  /**\n   * End an iteration\n   */\n  endIteration(sessionId, iterationNumber, success = true, completedAction = null) {\n    const span = this.activeSpans.get(`${sessionId}_iteration_${iterationNumber}`);\n    if (!span) return;\n\n    span.setAttributes({\n      'app.iteration.success': success,\n      'app.iteration.end_time': Date.now(),\n      ...(completedAction ? { 'app.iteration.completed_action': completedAction } : {})\n    });\n\n    span.setStatus({ code: success ? SpanStatusCode.OK : SpanStatusCode.ERROR });\n    span.end();\n    this.activeSpans.delete(`${sessionId}_iteration_${iterationNumber}`);\n  }\n\n  /**\n   * End the agent loop\n   */\n  endAgentLoop(sessionId, totalIterations, success = true, completionReason = null) {\n    const span = this.activeSpans.get(`${sessionId}_agent_loop`);\n    if (!span) return;\n\n    span.setAttributes({\n      'app.loop.total_iterations': totalIterations,\n      'app.loop.success': success,\n      'app.loop.end_time': Date.now(),\n      ...(completionReason ? { 'app.loop.completion_reason': completionReason } : {})\n    });\n\n    span.setStatus({ code: success ? SpanStatusCode.OK : SpanStatusCode.ERROR });\n    span.end();\n    this.activeSpans.delete(`${sessionId}_agent_loop`);\n  }\n\n  /**\n   * End user message processing\n   */\n  endUserMessageProcessing(sessionId, success = true) {\n    const span = this.activeSpans.get(`${sessionId}_user_processing`);\n    if (!span) {\n      if (process.env.DEBUG_CHAT === '1') {\n        console.log(`[DEBUG] AppTracer: No user message processing span found for ${sessionId}`);\n      }\n      return;\n    }\n\n    if (process.env.DEBUG_CHAT === '1') {\n      console.log(`[DEBUG] AppTracer: Ending user message processing span ${span.spanContext().spanId} for ${sessionId}`);\n    }\n\n    span.setAttributes({\n      'app.processing.success': success,\n      'app.processing.end_time': Date.now()\n    });\n\n    span.setStatus({ code: success ? SpanStatusCode.OK : SpanStatusCode.ERROR });\n    span.end();\n    \n    this.activeSpans.delete(`${sessionId}_user_processing`);\n    // Clean up the message processing context\n    this.sessionContexts.delete(`${sessionId}_message_processing`);\n  }\n\n  /**\n   * End the chat session\n   */\n  endChatSession(sessionId, success = true, totalTokensUsed = 0) {\n    const span = this.sessionSpans.get(sessionId);\n    if (!span) {\n      if (process.env.DEBUG_CHAT === '1') {\n        console.log(`[DEBUG] AppTracer: No chat session span found for ${sessionId}`);\n      }\n      return;\n    }\n\n    if (process.env.DEBUG_CHAT === '1') {\n      console.log(`[DEBUG] AppTracer: Ending chat session span ${span.spanContext().spanId} for ${sessionId}`);\n    }\n\n    span.setAttributes({\n      'app.session.success': success,\n      'app.session.total_tokens_used': totalTokensUsed,\n      'app.session.end_time': Date.now()\n    });\n\n    span.setStatus({ code: success ? SpanStatusCode.OK : SpanStatusCode.ERROR });\n    span.end();\n    \n    this.sessionSpans.delete(sessionId);\n    // Clean up the session context after ending the span\n    this.sessionContexts.delete(sessionId);\n  }\n\n  /**\n   * End AI request span\n   */\n  endAiRequest(sessionId, iterationNumber, success = true) {\n    const span = this.activeSpans.get(`${sessionId}_ai_request_${iterationNumber}`);\n    if (!span) {\n      if (process.env.DEBUG_CHAT === '1') {\n        console.log(`[DEBUG] AppTracer: No AI request span found for ${sessionId}_ai_request_${iterationNumber}`);\n      }\n      return;\n    }\n\n    if (process.env.DEBUG_CHAT === '1') {\n      console.log(`[DEBUG] AppTracer: Ending AI request span ${span.spanContext().spanId} for ${sessionId}, iteration ${iterationNumber}`);\n    }\n\n    span.setAttributes({\n      'app.ai.request_success': success,\n      'app.ai.request_end_time': Date.now()\n    });\n\n    span.setStatus({ code: success ? SpanStatusCode.OK : SpanStatusCode.ERROR });\n    span.end();\n    this.activeSpans.delete(`${sessionId}_ai_request_${iterationNumber}`);\n  }\n\n  /**\n   * Record a completion attempt\n   */\n  recordCompletionAttempt(sessionId, success = true, finalResult = null) {\n    const sessionSpan = this.sessionSpans.get(sessionId);\n    const spanOptions = {\n      kind: SpanKind.INTERNAL,\n      attributes: {\n        'app.session.id': sessionId,\n        'app.completion.success': success,\n        'app.completion.result_length': finalResult ? finalResult.length : 0,\n        'app.completion.attempt_time': Date.now()\n      }\n    };\n\n    if (sessionSpan) {\n      spanOptions.parent = sessionSpan.spanContext();\n    }\n\n    const span = this.tracer.startSpan('agent.completion.attempt', spanOptions);\n    \n    span.setStatus({ code: success ? SpanStatusCode.OK : SpanStatusCode.ERROR });\n    span.end();\n\n    return span;\n  }\n\n  /**\n   * Start image URL processing\n   */\n  startImageProcessing(sessionId, messageId, imageUrls = [], cleanedMessageLength = 0) {\n    const userProcessingSpan = this.activeSpans.get(`${sessionId}_user_processing`);\n    const spanOptions = {\n      kind: SpanKind.INTERNAL,\n      attributes: {\n        'app.session.id': sessionId,\n        'app.message.id': messageId,\n        'app.image.urls_found': imageUrls.length,\n        'app.image.message_cleaned_length': cleanedMessageLength,\n        'app.image.processing_start_time': Date.now(),\n        'app.image.urls_list': JSON.stringify(imageUrls).substring(0, 500)\n      }\n    };\n\n    if (userProcessingSpan) {\n      spanOptions.parent = userProcessingSpan.spanContext();\n    }\n\n    const span = this.tracer.startSpan('content.image.processing', spanOptions);\n    this.activeSpans.set(`${sessionId}_image_processing`, span);\n    return span;\n  }\n\n  /**\n   * Record image URL validation results\n   */\n  recordImageValidation(sessionId, validationResults) {\n    const imageProcessingSpan = this.activeSpans.get(`${sessionId}_image_processing`);\n    const spanOptions = {\n      kind: SpanKind.INTERNAL,\n      attributes: {\n        'app.session.id': sessionId,\n        'app.image.validation.total_urls': validationResults.totalUrls || 0,\n        'app.image.validation.valid_urls': validationResults.validUrls || 0,\n        'app.image.validation.invalid_urls': validationResults.invalidUrls || 0,\n        'app.image.validation.redirected_urls': validationResults.redirectedUrls || 0,\n        'app.image.validation.timeout_urls': validationResults.timeoutUrls || 0,\n        'app.image.validation.network_errors': validationResults.networkErrors || 0,\n        'app.image.validation.duration_ms': validationResults.durationMs || 0,\n        'app.image.validation_time': Date.now()\n      }\n    };\n\n    if (imageProcessingSpan) {\n      spanOptions.parent = imageProcessingSpan.spanContext();\n    }\n\n    const span = this.tracer.startSpan('content.image.validation', spanOptions);\n    span.setStatus({ \n      code: validationResults.validUrls > 0 ? SpanStatusCode.OK : SpanStatusCode.ERROR,\n      message: `${validationResults.validUrls}/${validationResults.totalUrls} URLs validated successfully`\n    });\n    span.end();\n    return span;\n  }\n\n  /**\n   * End image processing\n   */\n  endImageProcessing(sessionId, success = true, finalValidUrls = 0) {\n    const span = this.activeSpans.get(`${sessionId}_image_processing`);\n    if (!span) return;\n\n    span.setAttributes({\n      'app.image.processing_success': success,\n      'app.image.final_valid_urls': finalValidUrls,\n      'app.image.processing_end_time': Date.now()\n    });\n\n    span.setStatus({ code: success ? SpanStatusCode.OK : SpanStatusCode.ERROR });\n    span.end();\n    this.activeSpans.delete(`${sessionId}_image_processing`);\n  }\n\n  /**\n   * Record AI model errors\n   */\n  recordAiModelError(sessionId, iterationNumber, errorDetails) {\n    const aiRequestSpan = this.activeSpans.get(`${sessionId}_ai_request_${iterationNumber}`);\n    const spanOptions = {\n      kind: SpanKind.INTERNAL,\n      attributes: {\n        'app.session.id': sessionId,\n        'app.error.type': 'ai_model_error',\n        'app.error.category': errorDetails.category || 'unknown', // timeout, api_limit, network, etc.\n        'app.error.message': errorDetails.message?.substring(0, 500) || '',\n        'app.error.model': errorDetails.model || '',\n        'app.error.provider': errorDetails.provider || '',\n        'app.error.status_code': errorDetails.statusCode || 0,\n        'app.error.retry_attempt': errorDetails.retryAttempt || 0,\n        'app.error.timestamp': Date.now()\n      }\n    };\n\n    if (aiRequestSpan) {\n      spanOptions.parent = aiRequestSpan.spanContext();\n    }\n\n    const span = this.tracer.startSpan('ai.generation.error', spanOptions);\n    span.setStatus({ code: SpanStatusCode.ERROR, message: errorDetails.message });\n    span.end();\n    return span;\n  }\n\n  /**\n   * Record tool execution errors\n   */\n  recordToolError(sessionId, iterationNumber, toolName, errorDetails) {\n    const toolExecutionSpan = this.activeSpans.get(`${sessionId}_tool_execution_${iterationNumber}`);\n    const spanOptions = {\n      kind: SpanKind.INTERNAL,\n      attributes: {\n        'app.session.id': sessionId,\n        'app.error.type': 'tool_execution_error',\n        'app.error.tool_name': toolName,\n        'app.error.category': errorDetails.category || 'unknown', // validation, execution, network, filesystem\n        'app.error.message': errorDetails.message?.substring(0, 500) || '',\n        'app.error.exit_code': errorDetails.exitCode || 0,\n        'app.error.signal': errorDetails.signal || '',\n        'app.error.params': JSON.stringify(errorDetails.params || {}).substring(0, 300),\n        'app.error.timestamp': Date.now()\n      }\n    };\n\n    if (toolExecutionSpan) {\n      spanOptions.parent = toolExecutionSpan.spanContext();\n    }\n\n    const span = this.tracer.startSpan('tool.call.error', spanOptions);\n    span.setStatus({ code: SpanStatusCode.ERROR, message: errorDetails.message });\n    span.end();\n    return span;\n  }\n\n  /**\n   * Record session cancellation\n   */\n  recordSessionCancellation(sessionId, reason = 'user_request', context = {}) {\n    const sessionSpan = this.sessionSpans.get(sessionId);\n    const spanOptions = {\n      kind: SpanKind.INTERNAL,\n      attributes: {\n        'app.session.id': sessionId,\n        'app.cancellation.reason': reason, // user_request, timeout, error, signal\n        'app.cancellation.context': JSON.stringify(context).substring(0, 300),\n        'app.cancellation.current_iteration': context.currentIteration || 0,\n        'app.cancellation.active_tool': context.activeTool || '',\n        'app.cancellation.timestamp': Date.now()\n      }\n    };\n\n    if (sessionSpan) {\n      spanOptions.parent = sessionSpan.spanContext();\n    }\n\n    const span = this.tracer.startSpan('messaging.session.cancel', spanOptions);\n    span.setStatus({ code: SpanStatusCode.ERROR, message: `Session cancelled: ${reason}` });\n    span.end();\n    return span;\n  }\n\n  /**\n   * Record token management metrics\n   */\n  recordTokenMetrics(sessionId, tokenData) {\n    const sessionSpan = this.sessionSpans.get(sessionId);\n    const spanOptions = {\n      kind: SpanKind.INTERNAL,\n      attributes: {\n        'app.session.id': sessionId,\n        'app.tokens.context_window': tokenData.contextWindow || 0,\n        'app.tokens.current_total': tokenData.currentTotal || 0,\n        'app.tokens.request_tokens': tokenData.requestTokens || 0,\n        'app.tokens.response_tokens': tokenData.responseTokens || 0,\n        'app.tokens.cache_read': tokenData.cacheRead || 0,\n        'app.tokens.cache_write': tokenData.cacheWrite || 0,\n        'app.tokens.utilization_percent': tokenData.contextWindow ? \n          Math.round((tokenData.currentTotal / tokenData.contextWindow) * 100) : 0,\n        'app.tokens.measurement_time': Date.now()\n      }\n    };\n\n    if (sessionSpan) {\n      spanOptions.parent = sessionSpan.spanContext();\n    }\n\n    const span = this.tracer.startSpan('ai.token.metrics', spanOptions);\n    span.setStatus({ code: SpanStatusCode.OK });\n    span.end();\n    return span;\n  }\n\n  /**\n   * Record history management operations\n   */\n  recordHistoryOperation(sessionId, operation, details = {}) {\n    const sessionSpan = this.sessionSpans.get(sessionId);\n    const spanOptions = {\n      kind: SpanKind.INTERNAL,\n      attributes: {\n        'app.session.id': sessionId,\n        'app.history.operation': operation, // trim, update, clear, save\n        'app.history.messages_before': details.messagesBefore || 0,\n        'app.history.messages_after': details.messagesAfter || 0,\n        'app.history.messages_removed': details.messagesRemoved || 0,\n        'app.history.reason': details.reason || '', // max_length, memory_limit, session_reset\n        'app.history.operation_time': Date.now()\n      }\n    };\n\n    if (sessionSpan) {\n      spanOptions.parent = sessionSpan.spanContext();\n    }\n\n    const span = this.tracer.startSpan('messaging.history.manage', spanOptions);\n    span.setStatus({ code: SpanStatusCode.OK });\n    span.end();\n    return span;\n  }\n\n  /**\n   * Record system prompt generation metrics\n   */\n  recordSystemPromptGeneration(sessionId, promptData) {\n    const sessionSpan = this.sessionSpans.get(sessionId);\n    const spanOptions = {\n      kind: SpanKind.INTERNAL,\n      attributes: {\n        'app.session.id': sessionId,\n        'app.prompt.base_length': promptData.baseLength || 0,\n        'app.prompt.final_length': promptData.finalLength || 0,\n        'app.prompt.files_added': promptData.filesAdded || 0,\n        'app.prompt.generation_duration_ms': promptData.generationDurationMs || 0,\n        'app.prompt.type': promptData.promptType || 'default',\n        'app.prompt.estimated_tokens': promptData.estimatedTokens || 0,\n        'app.prompt.generation_time': Date.now()\n      }\n    };\n\n    if (sessionSpan) {\n      spanOptions.parent = sessionSpan.spanContext();\n    }\n\n    const span = this.tracer.startSpan('ai.prompt.generate', spanOptions);\n    span.setStatus({ code: SpanStatusCode.OK });\n    span.end();\n    return span;\n  }\n\n  /**\n   * Record file system operations\n   */\n  recordFileSystemOperation(sessionId, operation, details = {}) {\n    const activeSpan = this.activeSpans.get(`${sessionId}_tool_execution_${details.iterationNumber}`) || \n                      this.sessionSpans.get(sessionId);\n    const spanOptions = {\n      kind: SpanKind.INTERNAL,\n      attributes: {\n        'app.session.id': sessionId,\n        'app.fs.operation': operation, // read, write, create_temp, delete, mkdir\n        'app.fs.path': details.path?.substring(0, 200) || '',\n        'app.fs.size_bytes': details.sizeBytes || 0,\n        'app.fs.duration_ms': details.durationMs || 0,\n        'app.fs.success': details.success !== false,\n        'app.fs.error_code': details.errorCode || '',\n        'app.fs.operation_time': Date.now()\n      }\n    };\n\n    if (activeSpan) {\n      spanOptions.parent = activeSpan.spanContext();\n    }\n\n    const span = this.tracer.startSpan('fs.operation', spanOptions);\n    span.setStatus({ \n      code: details.success !== false ? SpanStatusCode.OK : SpanStatusCode.ERROR,\n      message: details.errorMessage\n    });\n    span.end();\n    return span;\n  }\n\n  /**\n   * Clean up any remaining active spans for a session\n   */\n  cleanup(sessionId) {\n    if (process.env.DEBUG_CHAT === '1') {\n      console.log(`[DEBUG] AppTracer: Cleaning up session ${sessionId}`);\n    }\n    \n    // End any remaining active spans\n    const keysToDelete = [];\n    for (const [key, span] of this.activeSpans.entries()) {\n      if (key.includes(sessionId)) {\n        if (process.env.DEBUG_CHAT === '1') {\n          console.log(`[DEBUG] AppTracer: Cleaning up active span ${key}`);\n        }\n        span.setStatus({ code: SpanStatusCode.ERROR, message: 'Session cleanup' });\n        span.end();\n        keysToDelete.push(key);\n      }\n    }\n    keysToDelete.forEach(key => this.activeSpans.delete(key));\n\n    // Only clean up session span if it still exists (wasn't properly ended by endChatSession)\n    const sessionSpan = this.sessionSpans.get(sessionId);\n    if (sessionSpan) {\n      if (process.env.DEBUG_CHAT === '1') {\n        console.log(`[DEBUG] AppTracer: Cleaning up orphaned session span for ${sessionId}`);\n      }\n      sessionSpan.setStatus({ code: SpanStatusCode.ERROR, message: 'Session cleanup - orphaned span' });\n      sessionSpan.end();\n      this.sessionSpans.delete(sessionId);\n    }\n\n    // Clean up all session-related contexts (session, message processing, iterations, AI requests, tool executions)\n    const contextKeysToDelete = [];\n    for (const [key] of this.sessionContexts.entries()) {\n      if (key.includes(sessionId)) {\n        contextKeysToDelete.push(key);\n      }\n    }\n    contextKeysToDelete.forEach(key => this.sessionContexts.delete(key));\n    \n    if (process.env.DEBUG_CHAT === '1') {\n      console.log(`[DEBUG] AppTracer: Session cleanup completed for ${sessionId}, cleaned ${contextKeysToDelete.length} contexts`);\n    }\n  }\n}\n\n// Export a singleton instance\nexport const appTracer = new AppTracer();", "// This file might become obsolete or significantly simplified if tools\n// are only defined/described in the system prompt and not passed to Vercel AI SDK.\n\n// Let's comment it out for now, assuming it's not directly used in the new flow.\n// If specific exports are needed elsewhere (like DEFAULT_SYSTEM_MESSAGE), they\n// should be moved or imported directly from @buger/probe.\n\n\n// Import tool generators and schemas from @buger/probe package\nimport {\n  searchTool,\n  queryTool,\n  extractTool,\n  DEFAULT_SYSTEM_MESSAGE,\n  attemptCompletionSchema,\n  attemptCompletionToolDefinition,\n  searchSchema,\n  querySchema,\n  extractSchema,\n  searchToolDefinition,\n  queryToolDefinition,\n  extractToolDefinition,\n  // Add the implement tool definition import if it exists in @buger/probe\n  // If not, we define it here. Assuming it's not in the package yet:\n} from '@buger/probe';\nimport { randomUUID } from 'crypto';\n\n// Generate a session ID\nconst sessionId = process.env.PROBE_SESSION_ID || randomUUID();\nconsole.error(`Generated session ID for search caching: ${sessionId}`);\n\n// Debug mode\nconst debug = process.env.DEBUG_CHAT === '1';\n\n// Configure tools with the session ID\nconst configOptions = {\n  sessionId,\n  debug\n};\n\n// Create configured tool instances\nexport const tools = {\n  searchTool: searchTool(configOptions),\n  queryTool: queryTool(configOptions),\n  extractTool: extractTool(configOptions),\n  // Note: The actual implement tool *instance* comes from probeTool.js\n  // This file primarily deals with definitions for the system prompt.\n};\n\n// Export individual tools for direct use\nexport const { searchTool: searchToolInstance, queryTool: queryToolInstance, extractTool: extractToolInstance } = tools;\n\n// For backward compatibility, export the original tool objects\nexport {\n  searchToolInstance as searchTool,\n  queryToolInstance as queryTool,\n  extractToolInstance as extractTool,\n  DEFAULT_SYSTEM_MESSAGE,\n  // Export schemas\n  searchSchema,\n  querySchema,\n  extractSchema,\n  attemptCompletionSchema,\n  // Export tool definitions\n  searchToolDefinition,\n  queryToolDefinition,\n  extractToolDefinition,\n  attemptCompletionToolDefinition,\n};\n\n// Define the implement tool XML definition\nexport const implementToolDefinition = `\n## implement\nDescription: Implement a given task. Can modify files. Can be used ONLY if task explicitly stated that something requires modification or implementation.\n\nParameters:\n- task: (required) The task description. Should be as detailed as possible, ideally pointing to exact files which needs be modified or created.\n- autoCommits: (optional) Whether to enable auto-commits in aider. Default is false.\n\nUsage Example:\n\n<examples>\n\nUser: Can you implement a function to calculate Fibonacci numbers in main.js?\n<implement>\n<task>Implement a recursive function to calculate the nth Fibonacci number in main.js</task>\n</implement>\n\nUser: Can you implement a function to calculate Fibonacci numbers in main.js with auto-commits?\n<implement>\n<task>Implement a recursive function to calculate the nth Fibonacci number in main.js</task>\n<autoCommits>true</autoCommits>\n</implement>\n\n</examples>\n`;\n\n// Define the listFiles tool XML definition\nexport const listFilesToolDefinition = `\n## listFiles\nDescription: List files and directories in a specified location.\n\nParameters:\n- directory: (optional) The directory path to list files from. Defaults to current directory if not specified.\n\nUsage Example:\n\n<examples>\n\nUser: Can you list the files in the src directory?\n<listFiles>\n<directory>src</directory>\n</listFiles>\n\nUser: What files are in the current directory?\n<listFiles>\n</listFiles>\n\n</examples>\n`;\n\n// Define the searchFiles tool XML definition\nexport const searchFilesToolDefinition = `\n## searchFiles\nDescription: Find files with name matching a glob pattern with recursive search capability.\n\nParameters:\n- pattern: (required) The glob pattern to search for (e.g., \"**/*.js\", \"*.md\").\n- directory: (optional) The directory to search in. Defaults to current directory if not specified.\n- recursive: (optional) Whether to search recursively. Defaults to true.\n\nUsage Example:\n\n<examples>\n\nUser: Can you find all JavaScript files in the project?\n<searchFiles>\n<pattern>**/*.js</pattern>\n</searchFiles>\n\nUser: Find all markdown files in the docs directory, but only at the top level.\n<searchFiles>\n<pattern>*.md</pattern>\n<directory>docs</directory>\n<recursive>false</recursive>\n</searchFiles>\n\n</examples>\n`;\n\n\n// Import the XML parser function from @buger/probe\nimport { parseXmlToolCall } from '@buger/probe';\n\n// Re-export the original parseXmlToolCall\nexport { parseXmlToolCall };\n\n/**\n * Enhanced XML parser that handles thinking tags\n * This function removes any <thinking></thinking> tags from the input string\n * before passing it to the original parseXmlToolCall function\n * @param {string} xmlString - The XML string to parse\n * @returns {Object|null} - The parsed tool call or null if no valid tool call found\n */\nexport function parseXmlToolCallWithThinking(xmlString) {\n  // Extract thinking content if present (for potential logging or analysis)\n  const thinkingMatch = xmlString.match(/<thinking>([\\s\\S]*?)<\\/thinking>/);\n  const thinkingContent = thinkingMatch ? thinkingMatch[1].trim() : null;\n\n  // Remove thinking tags and their content from the XML string\n  const cleanedXmlString = xmlString.replace(/<thinking>[\\s\\S]*?<\\/thinking>/g, '').trim();\n\n  // Use the original parseXmlToolCall function to parse the cleaned XML string\n  const parsedTool = parseXmlToolCall(cleanedXmlString);\n\n  // If debugging is enabled, log the thinking content\n  if (process.env.DEBUG_CHAT === '1' && thinkingContent) {\n    console.log(`[DEBUG] AI Thinking Process:\\n${thinkingContent}`);\n  }\n\n  return parsedTool;\n}\n\n// If tool instances are needed directly (e.g., for API endpoints bypassing the LLM loop),\n// they are now created and exported from probeTool.js.\n// We should ensure those are imported where needed.", "/**\n * Utility functions and classes for the implement tool\n * @module utils\n */\n\n/**\n * Error types for backend operations\n * @enum {string}\n */\nconst ErrorTypes = {\n  INITIALIZATION_FAILED: 'initialization_failed',\n  DEPENDENCY_MISSING: 'dependency_missing',\n  CONFIGURATION_INVALID: 'configuration_invalid',\n  EXECUTION_FAILED: 'execution_failed',\n  TIMEOUT: 'timeout',\n  CANCELLATION: 'cancellation',\n  NETWORK_ERROR: 'network_error',\n  API_ERROR: 'api_error',\n  AUTHENTICATION: 'authentication',\n  FILE_ACCESS_ERROR: 'file_access_error',\n  VALIDATION_ERROR: 'validation_error',\n  BACKEND_NOT_FOUND: 'backend_not_found',\n  SESSION_NOT_FOUND: 'session_not_found',\n  QUOTA_EXCEEDED: 'quota_exceeded'\n};\n\n/**\n * Standardized error class for backend operations\n * @class\n * @extends Error\n */\nclass BackendError extends Error {\n  /**\n   * @param {string} message - Error message\n   * @param {string} type - Error type from ErrorTypes\n   * @param {string} [code] - Error code\n   * @param {Object} [details] - Additional error details\n   */\n  constructor(message, type, code = null, details = {}) {\n    super(message);\n    this.name = 'BackendError';\n    this.type = type;\n    this.code = code;\n    this.details = details;\n    this.timestamp = new Date().toISOString();\n    \n    // Capture stack trace\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, BackendError);\n    }\n  }\n\n  /**\n   * Convert error to JSON representation\n   * @returns {Object}\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      type: this.type,\n      code: this.code,\n      details: this.details,\n      timestamp: this.timestamp,\n      stack: this.stack\n    };\n  }\n}\n\n/**\n * Error handling utilities\n * @class\n */\nclass ErrorHandler {\n  /**\n   * Create a new BackendError\n   * @param {string} type - Error type\n   * @param {string} message - Error message\n   * @param {string} [code] - Error code\n   * @param {Object} [details] - Additional details\n   * @returns {BackendError}\n   */\n  static createError(type, message, code = null, details = {}) {\n    return new BackendError(message, type, code, details);\n  }\n\n  /**\n   * Check if an error is retryable\n   * @param {Error|BackendError} error - Error to check\n   * @returns {boolean}\n   */\n  static isRetryable(error) {\n    if (error instanceof BackendError) {\n      const retryableTypes = [\n        ErrorTypes.NETWORK_ERROR,\n        ErrorTypes.TIMEOUT,\n        ErrorTypes.API_ERROR\n      ];\n      return retryableTypes.includes(error.type);\n    }\n    \n    // Check for common retryable error patterns\n    const message = error.message.toLowerCase();\n    return message.includes('timeout') || \n           message.includes('network') || \n           message.includes('connection');\n  }\n\n  /**\n   * Get recovery strategy for an error\n   * @param {Error|BackendError} error - Error to analyze\n   * @returns {string} Recovery strategy\n   */\n  static getRecoveryStrategy(error) {\n    if (!(error instanceof BackendError)) {\n      return 'manual_intervention';\n    }\n    \n    switch (error.type) {\n      case ErrorTypes.DEPENDENCY_MISSING:\n        return 'install_dependencies';\n      case ErrorTypes.CONFIGURATION_INVALID:\n        return 'fix_configuration';\n      case ErrorTypes.TIMEOUT:\n        return 'retry_with_longer_timeout';\n      case ErrorTypes.AUTHENTICATION:\n        return 'check_api_credentials';\n      case ErrorTypes.NETWORK_ERROR:\n        return 'retry_with_backoff';\n      case ErrorTypes.QUOTA_EXCEEDED:\n        return 'wait_or_upgrade';\n      case ErrorTypes.API_ERROR:\n        return 'check_api_key';\n      default:\n        return 'manual_intervention';\n    }\n  }\n\n  /**\n   * Format error for user display\n   * @param {Error|BackendError} error - Error to format\n   * @returns {string}\n   */\n  static formatForDisplay(error) {\n    if (error instanceof BackendError) {\n      let message = `${error.message}`;\n      \n      if (error.code) {\n        message += ` (${error.code})`;\n      }\n      \n      // Add helpful context for specific error types\n      const strategy = this.getRecoveryStrategy(error);\n      switch (strategy) {\n        case 'install_dependencies':\n          message += '\\n\uD83D\uDCA1 Try installing missing dependencies';\n          break;\n        case 'fix_configuration':\n          message += '\\n\uD83D\uDCA1 Check your configuration settings';\n          break;\n        case 'retry_with_longer_timeout':\n          message += '\\n\uD83D\uDCA1 Consider increasing the timeout value';\n          break;\n        case 'check_api_credentials':\n          message += '\\n\uD83D\uDCA1 Check your API key and authentication settings';\n          break;\n        case 'check_api_key':\n          message += '\\n\uD83D\uDCA1 Verify your API key is valid';\n          break;\n      }\n      \n      return message;\n    }\n    \n    return error.message;\n  }\n}\n\n/**\n * Retry utility for handling transient failures\n * @class\n */\nclass RetryHandler {\n  /**\n   * Execute a function with retry logic\n   * @param {Function} fn - Function to execute\n   * @param {Object} [options] - Retry options\n   * @param {number} [options.maxAttempts=3] - Maximum retry attempts\n   * @param {number} [options.initialDelay=1000] - Initial delay in ms\n   * @param {number} [options.maxDelay=30000] - Maximum delay in ms\n   * @param {number} [options.backoffFactor=2] - Backoff multiplier\n   * @param {Function} [options.shouldRetry] - Custom retry predicate\n   * @returns {Promise<*>}\n   */\n  static async withRetry(fn, options = {}) {\n    const {\n      maxAttempts = 3,\n      initialDelay = 1000,\n      maxDelay = 30000,\n      backoffFactor = 2,\n      shouldRetry = ErrorHandler.isRetryable\n    } = options;\n    \n    let lastError;\n    let delay = initialDelay;\n    \n    for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n      try {\n        return await fn();\n      } catch (error) {\n        lastError = error;\n        \n        if (attempt === maxAttempts || !shouldRetry(error)) {\n          throw error;\n        }\n        \n        console.error(`[ERROR] ========================================`);\n        console.error(`[ERROR] Attempt ${attempt} failed, retrying in ${delay}ms...`);\n        console.error(`[ERROR] Error message: ${error.message}`);\n        console.error(`[ERROR] Error type: ${error.type || 'unknown'}`);\n        console.error(`[ERROR] Error code: ${error.code || 'unknown'}`);\n        if (error.metadata) {\n          console.error(`[ERROR] Error metadata:`, JSON.stringify(error.metadata, null, 2));\n        }\n        console.error(`[ERROR] ========================================`);\n        await this.sleep(delay);\n        \n        // Calculate next delay with exponential backoff\n        delay = Math.min(delay * backoffFactor, maxDelay);\n      }\n    }\n    \n    throw lastError;\n  }\n\n  /**\n   * Sleep for specified milliseconds\n   * @param {number} ms - Milliseconds to sleep\n   * @returns {Promise<void>}\n   */\n  static sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n/**\n * Progress tracking utility\n * @class\n */\nclass ProgressTracker {\n  /**\n   * @param {string} sessionId - Session ID\n   * @param {Function} [onProgress] - Progress callback\n   */\n  constructor(sessionId, onProgress = null) {\n    this.sessionId = sessionId;\n    this.onProgress = onProgress;\n    this.startTime = Date.now();\n    this.steps = [];\n    this.currentStep = null;\n  }\n\n  /**\n   * Start a new step\n   * @param {string} name - Step name\n   * @param {string} [message] - Step message\n   */\n  startStep(name, message = null) {\n    if (this.currentStep) {\n      this.endStep();\n    }\n    \n    this.currentStep = {\n      name,\n      message,\n      startTime: Date.now()\n    };\n    \n    this.reportProgress({\n      type: 'step_start',\n      step: name,\n      message\n    });\n  }\n\n  /**\n   * End the current step\n   * @param {string} [result] - Step result\n   */\n  endStep(result = 'completed') {\n    if (!this.currentStep) return;\n    \n    const duration = Date.now() - this.currentStep.startTime;\n    this.currentStep.duration = duration;\n    this.currentStep.result = result;\n    \n    this.steps.push(this.currentStep);\n    \n    this.reportProgress({\n      type: 'step_end',\n      step: this.currentStep.name,\n      result,\n      duration\n    });\n    \n    this.currentStep = null;\n  }\n\n  /**\n   * Report progress update\n   * @param {Object} update - Progress update\n   */\n  reportProgress(update) {\n    if (!this.onProgress) return;\n    \n    const progress = {\n      sessionId: this.sessionId,\n      timestamp: Date.now(),\n      elapsed: Date.now() - this.startTime,\n      ...update\n    };\n    \n    try {\n      this.onProgress(progress);\n    } catch (error) {\n      console.error('Progress callback error:', error);\n    }\n  }\n\n  /**\n   * Report a message\n   * @param {string} message - Message to report\n   * @param {string} [type='info'] - Message type\n   */\n  reportMessage(message, type = 'info') {\n    this.reportProgress({\n      type: 'message',\n      messageType: type,\n      message\n    });\n  }\n\n  /**\n   * Get execution summary\n   * @returns {Object}\n   */\n  getSummary() {\n    return {\n      sessionId: this.sessionId,\n      totalDuration: Date.now() - this.startTime,\n      steps: this.steps,\n      currentStep: this.currentStep\n    };\n  }\n}\n\n/**\n * Utility for parsing and extracting file changes from output\n * @class\n */\nclass FileChangeParser {\n  /**\n   * Parse file changes from command output\n   * @param {string} output - Command output\n   * @param {string} [workingDir] - Working directory\n   * @returns {import('../types/BackendTypes').FileChange[]}\n   */\n  static parseChanges(output, workingDir = process.cwd()) {\n    const changes = [];\n    const patterns = {\n      created: /(?:created?|new file|added?):?\\s+(.+)/gi,\n      modified: /(?:modified?|changed?|updated?):?\\s+(.+)/gi,\n      deleted: /(?:deleted?|removed?):?\\s+(.+)/gi,\n      diff: /^[-+]{3}\\s+(.+)$/gm\n    };\n    \n    // Extract file changes\n    for (const [type, pattern] of Object.entries(patterns)) {\n      if (type === 'diff') continue;\n      \n      let match;\n      while ((match = pattern.exec(output)) !== null) {\n        const filePath = match[1].trim();\n        if (filePath && !changes.some(c => c.path === filePath)) {\n          changes.push({\n            path: filePath,\n            type,\n            description: `File ${filePath} was ${type}`\n          });\n        }\n      }\n    }\n    \n    // Git status parsing\n    const gitStatusPattern = /^([AMD])\\s+(.+)$/gm;\n    let match;\n    while ((match = gitStatusPattern.exec(output)) !== null) {\n      const status = match[1];\n      const filePath = match[2];\n      \n      const typeMap = {\n        'A': 'created',\n        'M': 'modified',\n        'D': 'deleted'\n      };\n      \n      if (typeMap[status] && !changes.some(c => c.path === filePath)) {\n        changes.push({\n          path: filePath,\n          type: typeMap[status],\n          description: `File ${filePath} was ${typeMap[status]}`\n        });\n      }\n    }\n    \n    return changes;\n  }\n\n  /**\n   * Extract diff statistics from output\n   * @param {string} output - Command output\n   * @returns {Object}\n   */\n  static extractDiffStats(output) {\n    const stats = {\n      filesChanged: 0,\n      insertions: 0,\n      deletions: 0\n    };\n    \n    // Git diff stat pattern\n    const statPattern = /(\\d+)\\s+files?\\s+changed(?:,\\s+(\\d+)\\s+insertions?)?(?:,\\s+(\\d+)\\s+deletions?)?/;\n    const match = output.match(statPattern);\n    \n    if (match) {\n      stats.filesChanged = parseInt(match[1], 10);\n      stats.insertions = match[2] ? parseInt(match[2], 10) : 0;\n      stats.deletions = match[3] ? parseInt(match[3], 10) : 0;\n    }\n    \n    return stats;\n  }\n}\n\n/**\n * Simple token estimation utility\n * @class\n */\nclass TokenEstimator {\n  /**\n   * Estimate token count for text\n   * @param {string} text - Text to estimate\n   * @returns {number} Estimated token count\n   */\n  static estimate(text) {\n    // Simple estimation: ~4 characters per token\n    // This is a rough approximation; real tokenizers are more complex\n    return Math.ceil(text.length / 4);\n  }\n\n  /**\n   * Check if text exceeds token limit\n   * @param {string} text - Text to check\n   * @param {number} limit - Token limit\n   * @returns {boolean}\n   */\n  static exceedsLimit(text, limit) {\n    return this.estimate(text) > limit;\n  }\n\n  /**\n   * Truncate text to fit within token limit\n   * @param {string} text - Text to truncate\n   * @param {number} limit - Token limit\n   * @param {string} [suffix='...'] - Suffix to add\n   * @returns {string}\n   */\n  static truncate(text, limit, suffix = '...') {\n    const estimatedChars = limit * 4;\n    if (text.length <= estimatedChars) {\n      return text;\n    }\n    \n    return text.substring(0, estimatedChars - suffix.length) + suffix;\n  }\n}\n\nexport {\n  ErrorTypes,\n  BackendError,\n  ErrorHandler,\n  RetryHandler,\n  ProgressTracker,\n  FileChangeParser,\n  TokenEstimator\n};", "/**\n * Centralized timeout configuration for the implementation system\n * \n * This file defines all timeout values used across the implementation pipeline\n * to ensure consistency and maintainability.\n */\n\nexport const TIMEOUTS = {\n  // Main implementation timeouts (in seconds - user-friendly)\n  IMPLEMENT_DEFAULT: 1200,        // 20 minutes - default for Claude Code/Aider execution\n  IMPLEMENT_MINIMUM: 60,          // 1 minute - minimum allowed timeout\n  IMPLEMENT_MAXIMUM: 3600,        // 1 hour - maximum allowed timeout\n\n  // Quick verification checks (in milliseconds)\n  VERSION_CHECK: 5000,            // 5 seconds - claude --version, aider --version\n  PATH_CHECK: 2000,               // 2 seconds - command existence checks\n  NPM_CHECK: 5000,                // 5 seconds - npm operations\n  WSL_CHECK: 2000,                // 2 seconds - WSL availability checks\n  \n  // Network operations (in milliseconds) \n  HTTP_REQUEST: 10000,            // 10 seconds - GitHub URLs, remote requests\n  FILE_FLUSH: 5000,               // 5 seconds - file operations and flushing\n};\n\n/**\n * Convert seconds to milliseconds for internal use\n * @param {number} seconds - Timeout in seconds\n * @returns {number} Timeout in milliseconds\n */\nexport function secondsToMs(seconds) {\n  return seconds * 1000;\n}\n\n/**\n * Convert milliseconds to seconds for user display\n * @param {number} milliseconds - Timeout in milliseconds\n * @returns {number} Timeout in seconds\n */\nexport function msToSeconds(milliseconds) {\n  return Math.floor(milliseconds / 1000);\n}\n\n/**\n * Validate timeout value is within acceptable bounds\n * @param {number} seconds - Timeout in seconds\n * @returns {boolean} True if valid\n */\nexport function isValidTimeout(seconds) {\n  return seconds >= TIMEOUTS.IMPLEMENT_MINIMUM && seconds <= TIMEOUTS.IMPLEMENT_MAXIMUM;\n}\n\n/**\n * Get default timeout in milliseconds for internal use\n * @returns {number} Default timeout in milliseconds\n */\nexport function getDefaultTimeoutMs() {\n  return secondsToMs(TIMEOUTS.IMPLEMENT_DEFAULT);\n}", "/**\n * Backend manager for handling multiple implementation backends\n * @module BackendManager\n */\n\nimport { BackendError, ErrorTypes, ErrorHandler, RetryHandler } from './utils.js';\nimport { getDefaultTimeoutMs } from './timeouts.js';\n\n/**\n * Manages registration, selection, and execution of implementation backends\n * @class\n */\nclass BackendManager {\n  /**\n   * @param {Object} config - Backend manager configuration\n   * @param {string} config.defaultBackend - Default backend name\n   * @param {string[]} [config.fallbackBackends] - Fallback backend names\n   * @param {string} [config.selectionStrategy='auto'] - Backend selection strategy\n   * @param {number} [config.maxConcurrentSessions=3] - Maximum concurrent sessions\n   * @param {number} [config.timeout=300000] - Default timeout in milliseconds\n   * @param {number} [config.retryAttempts=2] - Number of retry attempts\n   */\n  constructor(config) {\n    this.config = {\n      defaultBackend: config.defaultBackend || 'aider',\n      selectionStrategy: config.selectionStrategy || 'auto',\n      maxConcurrentSessions: config.maxConcurrentSessions || 3,\n      timeout: config.timeout || getDefaultTimeoutMs(), // Use centralized default (20 minutes)\n      retryAttempts: config.retryAttempts || 2,\n      ...config\n    };\n    \n    this.backends = new Map();\n    this.activeSessionCount = 0;\n    this.sessionBackendMap = new Map();\n    this.initialized = false;\n  }\n\n  /**\n   * Initialize the backend manager\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    if (this.initialized) return;\n    \n    // Initialize any pre-registered backends\n    for (const [name, backend] of this.backends) {\n      try {\n        if (!backend.initialized) {\n          await backend.initialize(this.config.backends?.[name] || {});\n        }\n      } catch (error) {\n        console.warn(`Failed to initialize backend '${name}':`, error.message);\n      }\n    }\n    \n    this.initialized = true;\n  }\n\n  /**\n   * Register a new backend\n   * @param {import('../backends/BaseBackend')} backend - Backend instance\n   * @returns {Promise<void>}\n   */\n  async registerBackend(backend) {\n    if (!backend || !backend.name) {\n      throw new Error('Invalid backend: must have a name property');\n    }\n    \n    // Check if backend already registered\n    if (this.backends.has(backend.name)) {\n      console.warn(`Backend '${backend.name}' is already registered, replacing...`);\n    }\n    \n    this.backends.set(backend.name, backend);\n    \n    // Initialize if manager is already initialized\n    if (this.initialized && !backend.initialized) {\n      try {\n        await backend.initialize(this.config.backends?.[backend.name] || {});\n      } catch (error) {\n        console.warn(`Failed to initialize backend '${backend.name}':`, error.message);\n      }\n    }\n  }\n\n  /**\n   * Unregister a backend\n   * @param {string} name - Backend name\n   * @returns {Promise<void>}\n   */\n  async unregisterBackend(name) {\n    const backend = this.backends.get(name);\n    if (backend) {\n      await backend.cleanup();\n      this.backends.delete(name);\n    }\n  }\n\n  /**\n   * Get list of available backend names\n   * @returns {string[]}\n   */\n  getAvailableBackends() {\n    return Array.from(this.backends.keys());\n  }\n\n  /**\n   * Get backend instance by name\n   * @param {string} name - Backend name\n   * @returns {import('../backends/BaseBackend')|null}\n   */\n  getBackend(name) {\n    return this.backends.get(name) || null;\n  }\n\n  /**\n   * Get backend information\n   * @param {string} name - Backend name\n   * @returns {import('../types/BackendTypes').BackendInfo|null}\n   */\n  async getBackendInfo(name) {\n    const backend = this.backends.get(name);\n    if (!backend) return null;\n    \n    const info = backend.getInfo();\n    info.available = await backend.isAvailable();\n    \n    return info;\n  }\n\n  /**\n   * Select appropriate backend for request\n   * @param {import('../types/BackendTypes').ImplementRequest} request - Implementation request\n   * @returns {Promise<string>} Selected backend name\n   */\n  async selectBackend(request) {\n    switch (this.config.selectionStrategy) {\n      case 'preference':\n        return this.selectByPreference(request);\n      case 'capability':\n        return this.selectByCapability(request);\n      case 'auto':\n      default:\n        return this.selectAuto(request);\n    }\n  }\n\n  /**\n   * Select backend using auto strategy\n   * @param {import('../types/BackendTypes').ImplementRequest} request - Implementation request\n   * @returns {Promise<string>}\n   * @private\n   */\n  async selectAuto(request) {\n    console.error('[BackendManager] Starting backend selection with strategy: auto');\n    console.error(`[BackendManager] Default backend: ${this.config.defaultBackend}`);\n    console.error(`[BackendManager] Available backends: ${Array.from(this.backends.keys()).join(', ')}`);\n    \n    // First try explicit backend if specified\n    if (request.options?.backend && this.backends.has(request.options.backend)) {\n      console.error(`[BackendManager] Checking explicit backend: ${request.options.backend}`);\n      const backend = this.backends.get(request.options.backend);\n      if (await backend.isAvailable()) {\n        console.error(`[BackendManager] Selected explicit backend: ${request.options.backend}`);\n        return request.options.backend;\n      } else {\n        // If explicit backend is not available, fail immediately (no fallbacks)\n        console.error(`[BackendManager] Explicit backend ${request.options.backend} is not available`);\n        throw new BackendError(\n          `Requested backend '${request.options.backend}' is not available`,\n          ErrorTypes.BACKEND_NOT_FOUND,\n          'BACKEND_NOT_AVAILABLE'\n        );\n      }\n    }\n    \n    // Try default backend\n    if (this.backends.has(this.config.defaultBackend)) {\n      console.error(`[BackendManager] Checking default backend: ${this.config.defaultBackend}`);\n      const backend = this.backends.get(this.config.defaultBackend);\n      const isAvailable = await backend.isAvailable();\n      console.error(`[BackendManager] Default backend ${this.config.defaultBackend} available: ${isAvailable}`);\n      if (isAvailable) {\n        console.error(`[BackendManager] Selected default backend: ${this.config.defaultBackend}`);\n        return this.config.defaultBackend;\n      }\n    }\n    \n    // No fallbacks - if default backend is not available, fail\n    console.error('[BackendManager] No available backends found!');\n    throw new BackendError(\n      `Default backend '${this.config.defaultBackend}' is not available`,\n      ErrorTypes.BACKEND_NOT_FOUND,\n      'NO_AVAILABLE_BACKENDS'\n    );\n  }\n\n  /**\n   * Select backend by user preference\n   * @param {import('../types/BackendTypes').ImplementRequest} request - Implementation request\n   * @returns {Promise<string>}\n   * @private\n   */\n  async selectByPreference(request) {\n    const preference = request.options?.backend || this.config.defaultBackend;\n    \n    if (!this.backends.has(preference)) {\n      throw new BackendError(\n        `Preferred backend '${preference}' not found`,\n        ErrorTypes.BACKEND_NOT_FOUND,\n        'PREFERRED_BACKEND_NOT_FOUND'\n      );\n    }\n    \n    const backend = this.backends.get(preference);\n    if (!(await backend.isAvailable())) {\n      throw new BackendError(\n        `Preferred backend '${preference}' is not available`,\n        ErrorTypes.BACKEND_NOT_FOUND,\n        'PREFERRED_BACKEND_UNAVAILABLE'\n      );\n    }\n    \n    return preference;\n  }\n\n  /**\n   * Select backend by capability matching\n   * @param {import('../types/BackendTypes').ImplementRequest} request - Implementation request\n   * @returns {Promise<string>}\n   * @private\n   */\n  async selectByCapability(request) {\n    const candidates = [];\n    \n    for (const [name, backend] of this.backends) {\n      if (!(await backend.isAvailable())) continue;\n      \n      const capabilities = backend.getCapabilities();\n      let score = 0;\n      \n      // Score based on language support\n      if (request.context?.language) {\n        if (capabilities.supportsLanguages.includes(request.context.language)) {\n          score += 10;\n        } else if (capabilities.supportsLanguages.includes('all')) {\n          score += 5;\n        }\n      }\n      \n      // Score based on requested features\n      if (request.options?.generateTests && capabilities.supportsTestGeneration) {\n        score += 5;\n      }\n      \n      if (request.options?.streaming && capabilities.supportsStreaming) {\n        score += 3;\n      }\n      \n      // Prefer backends with higher concurrent session limits\n      score += Math.min(capabilities.maxConcurrentSessions, 5);\n      \n      candidates.push({ name, score });\n    }\n    \n    if (candidates.length === 0) {\n      throw new BackendError(\n        'No capable backends found',\n        ErrorTypes.BACKEND_NOT_FOUND,\n        'NO_CAPABLE_BACKENDS'\n      );\n    }\n    \n    // Sort by score and return highest\n    candidates.sort((a, b) => b.score - a.score);\n    return candidates[0].name;\n  }\n\n  /**\n   * Execute implementation request\n   * @param {import('../types/BackendTypes').ImplementRequest} request - Implementation request\n   * @returns {Promise<import('../types/BackendTypes').ImplementResult>}\n   */\n  async executeImplementation(request) {\n    // Ensure manager is initialized\n    await this.initialize();\n    \n    // Check concurrent session limit\n    if (this.activeSessionCount >= this.config.maxConcurrentSessions) {\n      throw new BackendError(\n        'Maximum concurrent sessions reached',\n        ErrorTypes.QUOTA_EXCEEDED,\n        'MAX_SESSIONS_REACHED',\n        { limit: this.config.maxConcurrentSessions, current: this.activeSessionCount }\n      );\n    }\n    \n    // Select backend\n    console.error(`[BackendManager] Selecting backend for request ${request.sessionId}`);\n    const backendName = await this.selectBackend(request);\n    console.error(`[BackendManager] Selected backend: ${backendName}`);\n    const backend = this.backends.get(backendName);\n    \n    if (!backend) {\n      throw new BackendError(\n        `Backend '${backendName}' not found`,\n        ErrorTypes.BACKEND_NOT_FOUND,\n        'BACKEND_NOT_FOUND'\n      );\n    }\n    \n    // Track session\n    this.activeSessionCount++;\n    this.sessionBackendMap.set(request.sessionId, backendName);\n    \n    try {\n      // Apply timeout if not specified\n      if (!request.options?.timeout) {\n        request.options = request.options || {};\n        request.options.timeout = this.config.timeout;\n      }\n      \n      // Execute with retry logic\n      const result = await RetryHandler.withRetry(\n        () => backend.execute(request),\n        {\n          maxAttempts: this.config.retryAttempts + 1,\n          shouldRetry: (error) => {\n            // Don't retry user cancellations or validation errors\n            if (error instanceof BackendError) {\n              if (error.type === ErrorTypes.CANCELLATION || \n                  error.type === ErrorTypes.VALIDATION_ERROR) {\n                return false;\n              }\n            }\n            return ErrorHandler.isRetryable(error);\n          }\n        }\n      );\n      \n      // Add backend information to result\n      result.backend = backendName;\n      \n      return result;\n      \n    } catch (error) {\n      // Try fallback backends if configured\n      if (this.config.fallbackBackends.length > 0) {\n        console.warn(`Backend '${backendName}' failed, trying fallbacks...`);\n        \n        for (const fallbackName of this.config.fallbackBackends) {\n          if (fallbackName === backendName) continue;\n          \n          const fallbackBackend = this.backends.get(fallbackName);\n          if (!fallbackBackend || !(await fallbackBackend.isAvailable())) {\n            continue;\n          }\n          \n          try {\n            console.log(`Trying fallback backend: ${fallbackName}`);\n            this.sessionBackendMap.set(request.sessionId, fallbackName);\n            \n            const result = await fallbackBackend.execute(request);\n            result.backend = fallbackName;\n            result.fallback = true;\n            \n            return result;\n          } catch (fallbackError) {\n            console.warn(`Fallback backend '${fallbackName}' also failed:`, fallbackError.message);\n          }\n        }\n      }\n      \n      // All backends failed\n      throw error;\n      \n    } finally {\n      this.activeSessionCount--;\n      this.sessionBackendMap.delete(request.sessionId);\n    }\n  }\n\n  /**\n   * Cancel an implementation session\n   * @param {string} sessionId - Session ID\n   * @returns {Promise<void>}\n   */\n  async cancelImplementation(sessionId) {\n    const backendName = this.sessionBackendMap.get(sessionId);\n    if (!backendName) {\n      throw new BackendError(\n        `Session '${sessionId}' not found`,\n        ErrorTypes.SESSION_NOT_FOUND,\n        'SESSION_NOT_FOUND'\n      );\n    }\n    \n    const backend = this.backends.get(backendName);\n    if (backend) {\n      await backend.cancel(sessionId);\n    }\n    \n    this.sessionBackendMap.delete(sessionId);\n    this.activeSessionCount = Math.max(0, this.activeSessionCount - 1);\n  }\n\n  /**\n   * Get session status\n   * @param {string} sessionId - Session ID\n   * @returns {Promise<import('../types/BackendTypes').BackendStatus>}\n   */\n  async getSessionStatus(sessionId) {\n    const backendName = this.sessionBackendMap.get(sessionId);\n    if (!backendName) {\n      return {\n        status: 'unknown',\n        message: 'Session not found'\n      };\n    }\n    \n    const backend = this.backends.get(backendName);\n    if (!backend) {\n      return {\n        status: 'error',\n        message: 'Backend not found'\n      };\n    }\n    \n    const status = await backend.getStatus(sessionId);\n    status.backend = backendName;\n    \n    return status;\n  }\n\n  /**\n   * Validate configuration\n   * @returns {Promise<import('../types/BackendTypes').ValidationResult>}\n   */\n  async validateConfiguration() {\n    const errors = [];\n    const warnings = [];\n    \n    // Check default backend exists\n    if (!this.backends.has(this.config.defaultBackend)) {\n      errors.push(`Default backend '${this.config.defaultBackend}' not registered`);\n    }\n    \n    // Fallback backends removed - no longer checking them\n    \n    // Check at least one backend is available\n    let hasAvailable = false;\n    for (const [name, backend] of this.backends) {\n      if (await backend.isAvailable()) {\n        hasAvailable = true;\n        break;\n      }\n    }\n    \n    if (!hasAvailable) {\n      errors.push('No backends are available');\n    }\n    \n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Check health of all backends\n   * @param {string} [name] - Specific backend to check, or all if not specified\n   * @returns {Promise<Object>}\n   */\n  async checkBackendHealth(name = null) {\n    const results = {};\n    \n    const backendsToCheck = name \n      ? [name]\n      : Array.from(this.backends.keys());\n    \n    for (const backendName of backendsToCheck) {\n      const backend = this.backends.get(backendName);\n      if (!backend) continue;\n      \n      try {\n        const available = await backend.isAvailable();\n        const info = backend.getInfo();\n        \n        results[backendName] = {\n          status: available ? 'healthy' : 'unavailable',\n          available,\n          version: info.version,\n          capabilities: info.capabilities,\n          dependencies: info.dependencies\n        };\n      } catch (error) {\n        results[backendName] = {\n          status: 'error',\n          available: false,\n          error: error.message\n        };\n      }\n    }\n    \n    return results;\n  }\n\n  /**\n   * Get recommended backend for a given context\n   * @param {Object} context - Request context\n   * @returns {string|null}\n   */\n  getRecommendedBackend(context) {\n    // Simple recommendation logic\n    if (context.language) {\n      for (const [name, backend] of this.backends) {\n        const capabilities = backend.getCapabilities();\n        if (capabilities.supportsLanguages.includes(context.language)) {\n          return name;\n        }\n      }\n    }\n    \n    return this.config.defaultBackend;\n  }\n\n  /**\n   * Check if a backend can handle a request\n   * @param {string} backendName - Backend name\n   * @param {import('../types/BackendTypes').ImplementRequest} request - Request to check\n   * @returns {boolean}\n   */\n  canHandleRequest(backendName, request) {\n    const backend = this.backends.get(backendName);\n    if (!backend) return false;\n    \n    const validation = backend.validateRequest(request);\n    return validation.valid;\n  }\n\n  /**\n   * Clean up all backends\n   * @returns {Promise<void>}\n   */\n  async cleanup() {\n    const cleanupPromises = [];\n    \n    for (const [name, backend] of this.backends) {\n      cleanupPromises.push(\n        backend.cleanup().catch(error => {\n          console.error(`Error cleaning up backend '${name}':`, error);\n        })\n      );\n    }\n    \n    await Promise.all(cleanupPromises);\n    \n    this.backends.clear();\n    this.sessionBackendMap.clear();\n    this.activeSessionCount = 0;\n    this.initialized = false;\n  }\n}\n\nexport default BackendManager;", "/**\n * Abstract base class for all implementation backends\n * @module BaseBackend\n */\n\nimport { BackendError, ErrorTypes } from '../core/utils.js';\n\n/**\n * Base class that all implementation backends must extend\n * @class\n */\nclass BaseBackend {\n  /**\n   * @param {string} name - Backend name\n   * @param {string} version - Backend version\n   */\n  constructor(name, version) {\n    if (new.target === BaseBackend) {\n      throw new Error('BaseBackend is an abstract class and cannot be instantiated directly');\n    }\n    \n    this.name = name;\n    this.version = version;\n    this.initialized = false;\n    this.activeSessions = new Map();\n  }\n\n  /**\n   * Initialize the backend with configuration\n   * @param {import('../types/BackendTypes').BackendConfig} config - Backend-specific configuration\n   * @returns {Promise<void>}\n   * @abstract\n   */\n  async initialize(config) {\n    throw new Error('initialize() must be implemented by subclass');\n  }\n\n  /**\n   * Check if backend is available and properly configured\n   * @returns {Promise<boolean>}\n   * @abstract\n   */\n  async isAvailable() {\n    throw new Error('isAvailable() must be implemented by subclass');\n  }\n\n  /**\n   * Get required dependencies for this backend\n   * @returns {import('../types/BackendTypes').Dependency[]}\n   * @abstract\n   */\n  getRequiredDependencies() {\n    throw new Error('getRequiredDependencies() must be implemented by subclass');\n  }\n\n  /**\n   * Execute implementation task\n   * @param {import('../types/BackendTypes').ImplementRequest} request - Implementation request\n   * @returns {Promise<import('../types/BackendTypes').ImplementResult>}\n   * @abstract\n   */\n  async execute(request) {\n    throw new Error('execute() must be implemented by subclass');\n  }\n\n  /**\n   * Cancel an active implementation session\n   * @param {string} sessionId - Session to cancel\n   * @returns {Promise<void>}\n   */\n  async cancel(sessionId) {\n    const session = this.activeSessions.get(sessionId);\n    if (session && session.cancel) {\n      await session.cancel();\n    }\n    this.activeSessions.delete(sessionId);\n  }\n\n  /**\n   * Get status of an implementation session\n   * @param {string} sessionId - Session ID\n   * @returns {Promise<import('../types/BackendTypes').BackendStatus>}\n   */\n  async getStatus(sessionId) {\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      return { \n        status: 'unknown',\n        message: 'Session not found'\n      };\n    }\n    \n    return {\n      status: session.status || 'running',\n      progress: session.progress,\n      message: session.message,\n      details: session.details\n    };\n  }\n\n  /**\n   * Clean up backend resources\n   * @returns {Promise<void>}\n   */\n  async cleanup() {\n    // Cancel all active sessions\n    const sessionIds = Array.from(this.activeSessions.keys());\n    await Promise.all(sessionIds.map(id => this.cancel(id)));\n    \n    this.activeSessions.clear();\n    this.initialized = false;\n  }\n\n  /**\n   * Get backend capabilities\n   * @returns {import('../types/BackendTypes').BackendCapabilities}\n   */\n  getCapabilities() {\n    return {\n      supportsLanguages: [],\n      supportsStreaming: false,\n      supportsRollback: false,\n      supportsDirectFileEdit: false,\n      supportsPlanGeneration: false,\n      supportsTestGeneration: false,\n      maxConcurrentSessions: 1\n    };\n  }\n\n  /**\n   * Get backend information\n   * @returns {import('../types/BackendTypes').BackendInfo}\n   */\n  getInfo() {\n    return {\n      name: this.name,\n      version: this.version,\n      description: this.getDescription(),\n      available: false,\n      capabilities: this.getCapabilities(),\n      dependencies: this.getRequiredDependencies()\n    };\n  }\n\n  /**\n   * Get backend description\n   * @returns {string}\n   */\n  getDescription() {\n    return 'Implementation backend';\n  }\n\n  /**\n   * Validate implementation request\n   * @param {import('../types/BackendTypes').ImplementRequest} request - Request to validate\n   * @returns {import('../types/BackendTypes').ValidationResult}\n   */\n  validateRequest(request) {\n    const errors = [];\n    const warnings = [];\n    \n    // Required fields\n    if (!request.sessionId) {\n      errors.push('sessionId is required');\n    }\n    \n    if (!request.task || request.task.trim().length === 0) {\n      errors.push('task description is required');\n    }\n    \n    // Check for active sessions limit\n    if (this.activeSessions.size >= this.getCapabilities().maxConcurrentSessions) {\n      errors.push(`Maximum concurrent sessions (${this.getCapabilities().maxConcurrentSessions}) reached`);\n    }\n    \n    // Language support check\n    if (request.context?.language) {\n      const supportedLanguages = this.getCapabilities().supportsLanguages;\n      if (supportedLanguages.length > 0 && !supportedLanguages.includes(request.context.language)) {\n        warnings.push(`Language '${request.context.language}' may not be fully supported`);\n      }\n    }\n    \n    // Option validation\n    if (request.options?.generateTests && !this.getCapabilities().supportsTestGeneration) {\n      warnings.push('Test generation requested but not supported by this backend');\n    }\n    \n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Create a session info object\n   * @param {string} sessionId - Session ID\n   * @returns {Object}\n   * @protected\n   */\n  createSessionInfo(sessionId) {\n    return {\n      sessionId,\n      startTime: Date.now(),\n      status: 'pending',\n      progress: 0,\n      message: 'Initializing',\n      cancel: null,\n      details: {}\n    };\n  }\n\n  /**\n   * Update session status\n   * @param {string} sessionId - Session ID\n   * @param {Partial<import('../types/BackendTypes').BackendStatus>} update - Status update\n   * @protected\n   */\n  updateSessionStatus(sessionId, update) {\n    const session = this.activeSessions.get(sessionId);\n    if (session) {\n      Object.assign(session, update);\n    }\n  }\n\n  /**\n   * Check if backend is initialized\n   * @throws {Error} If backend is not initialized\n   * @protected\n   */\n  checkInitialized() {\n    if (!this.initialized) {\n      throw new BackendError(\n        `Backend '${this.name}' is not initialized`,\n        ErrorTypes.INITIALIZATION_FAILED,\n        'BACKEND_NOT_INITIALIZED'\n      );\n    }\n  }\n\n  /**\n   * Log message with backend context\n   * @param {string} level - Log level\n   * @param {string} message - Log message\n   * @param {Object} [data] - Additional data\n   * @protected\n   */\n  log(level, message, data = {}) {\n    const logMessage = `[${this.name}] ${message}`;\n    const logData = { backend: this.name, ...data };\n    \n    switch (level) {\n      case 'debug':\n        // Only output debug logs if DEBUG environment variable is set\n        if (process.env.DEBUG) {\n          console.debug(logMessage, logData);\n        }\n        break;\n      case 'info':\n        // Send info logs to stderr to avoid mixing with stdout output\n        console.error(logMessage, logData);\n        break;\n      case 'warn':\n        console.warn(logMessage, logData);\n        break;\n      case 'error':\n        console.error(logMessage, logData);\n        break;\n      default:\n        console.error(logMessage, logData);\n    }\n  }\n}\n\nexport default BaseBackend;", "/**\n * Aider backend implementation for code implementation tasks\n * @module AiderBackend\n */\n\nimport BaseBackend from './BaseBackend.js';\nimport { BackendError, ErrorTypes, ProgressTracker, FileChangeParser, TokenEstimator } from '../core/utils.js';\nimport { spawn, exec } from 'child_process';\nimport { promisify } from 'util';\nimport { promises as fsPromises } from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { TIMEOUTS, getDefaultTimeoutMs } from '../core/timeouts.js';\n\nconst execPromise = promisify(exec);\n\n/**\n * Aider implementation backend\n * @class\n * @extends BaseBackend\n */\nclass AiderBackend extends BaseBackend {\n  constructor() {\n    super('aider', '1.0.0');\n    this.config = null;\n    this.aiderVersion = null;\n  }\n\n  /**\n   * @override\n   */\n  async initialize(config) {\n    this.config = {\n      command: 'aider',\n      timeout: getDefaultTimeoutMs(), // Use centralized default (20 minutes)\n      maxOutputSize: 10 * 1024 * 1024, // 10MB\n      additionalArgs: [],\n      environment: {},\n      autoCommit: false,\n      modelSelection: 'auto',\n      ...config\n    };\n    \n    // Test aider availability\n    const available = await this.isAvailable();\n    if (!available) {\n      throw new BackendError(\n        'Aider command not found or not accessible. Please install aider with: pip install aider-chat',\n        ErrorTypes.DEPENDENCY_MISSING,\n        'AIDER_NOT_FOUND'\n      );\n    }\n    \n    // Get aider version\n    try {\n      const { stdout } = await execPromise('aider --version', { timeout: TIMEOUTS.VERSION_CHECK });\n      this.aiderVersion = stdout.trim();\n      this.log('info', `Initialized with aider version: ${this.aiderVersion}`);\n    } catch (error) {\n      this.log('warn', 'Could not determine aider version', { error: error.message });\n    }\n    \n    this.initialized = true;\n  }\n\n  /**\n   * @override\n   */\n  async isAvailable() {\n    try {\n      // Test if aider command exists\n      await execPromise('which aider', { timeout: TIMEOUTS.VERSION_CHECK });\n      \n      // Check if API key is available\n      const hasApiKey = !!(\n        process.env.ANTHROPIC_API_KEY ||\n        process.env.OPENAI_API_KEY ||\n        process.env.GOOGLE_API_KEY ||\n        process.env.GEMINI_API_KEY\n      );\n      \n      if (!hasApiKey) {\n        this.log('warn', 'No API key found. Aider requires ANTHROPIC_API_KEY, OPENAI_API_KEY, or GOOGLE_API_KEY');\n        return false;\n      }\n      \n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * @override\n   */\n  getRequiredDependencies() {\n    return [\n      {\n        name: 'aider-chat',\n        type: 'pip',\n        version: '>=0.20.0',\n        installCommand: 'pip install aider-chat',\n        description: 'AI pair programming tool'\n      },\n      {\n        name: 'API Key',\n        type: 'environment',\n        description: 'One of: ANTHROPIC_API_KEY, OPENAI_API_KEY, GOOGLE_API_KEY, or GEMINI_API_KEY'\n      }\n    ];\n  }\n\n  /**\n   * @override\n   */\n  getCapabilities() {\n    return {\n      supportsLanguages: ['python', 'javascript', 'typescript', 'go', 'rust', 'java', 'cpp', 'c', 'csharp', 'ruby', 'php', 'swift'],\n      supportsStreaming: true,\n      supportsRollback: true,\n      supportsDirectFileEdit: true,\n      supportsPlanGeneration: false,\n      supportsTestGeneration: false,\n      maxConcurrentSessions: 3\n    };\n  }\n\n  /**\n   * @override\n   */\n  getDescription() {\n    return 'Aider - AI pair programming in your terminal';\n  }\n\n  /**\n   * @override\n   */\n  async execute(request) {\n    this.checkInitialized();\n    \n    const validation = this.validateRequest(request);\n    if (!validation.valid) {\n      throw new BackendError(\n        `Invalid request: ${validation.errors.join(', ')}`,\n        ErrorTypes.VALIDATION_ERROR,\n        'INVALID_REQUEST'\n      );\n    }\n    \n    const sessionInfo = this.createSessionInfo(request.sessionId);\n    const progressTracker = new ProgressTracker(request.sessionId, request.callbacks?.onProgress);\n    \n    this.activeSessions.set(request.sessionId, sessionInfo);\n    \n    try {\n      progressTracker.startStep('prepare', 'Preparing aider execution');\n      \n      // Create temporary file for task\n      const tempDir = os.tmpdir();\n      const tempFileName = `aider-task-${request.sessionId}-${Date.now()}.txt`;\n      const tempFilePath = path.join(tempDir, tempFileName);\n      \n      await fsPromises.writeFile(tempFilePath, request.task, 'utf8');\n      sessionInfo.tempFile = tempFilePath;\n      \n      this.log('debug', 'Created temporary task file', { path: tempFilePath });\n      \n      progressTracker.endStep();\n      progressTracker.startStep('execute', 'Executing aider');\n      \n      // Validate working directory\n      const workingDir = this.validateWorkingDirectory(request.context?.workingDirectory || process.cwd());\n      \n      this.updateSessionStatus(request.sessionId, {\n        status: 'running',\n        progress: 25,\n        message: 'Aider is processing your request'\n      });\n      \n      // Execute aider\n      const result = await this.executeCommand(workingDir, request, sessionInfo, progressTracker);\n      \n      progressTracker.endStep();\n      \n      // Clean up temp file\n      try {\n        await fsPromises.unlink(tempFilePath);\n      } catch (error) {\n        this.log('warn', 'Failed to clean up temp file', { path: tempFilePath, error: error.message });\n      }\n      \n      this.updateSessionStatus(request.sessionId, {\n        status: 'completed',\n        progress: 100,\n        message: 'Implementation completed successfully'\n      });\n      \n      return result;\n      \n    } catch (error) {\n      // Clean up temp file on error\n      if (sessionInfo.tempFile) {\n        try {\n          await fsPromises.unlink(sessionInfo.tempFile);\n        } catch (cleanupError) {\n          this.log('warn', 'Failed to clean up temp file on error', { error: cleanupError.message });\n        }\n      }\n      \n      this.updateSessionStatus(request.sessionId, {\n        status: 'failed',\n        message: error.message\n      });\n      \n      if (error instanceof BackendError) {\n        throw error;\n      }\n      \n      throw new BackendError(\n        `Aider execution failed: ${error.message}`,\n        ErrorTypes.EXECUTION_FAILED,\n        'AIDER_EXECUTION_FAILED',\n        { originalError: error, sessionId: request.sessionId }\n      );\n    } finally {\n      this.activeSessions.delete(request.sessionId);\n    }\n  }\n\n  /**\n   * Build aider command arguments\n   * @param {import('../types/BackendTypes').ImplementRequest} request - Implementation request\n   * @param {string} tempFilePath - Path to temporary file with task\n   * @returns {Array<string>} Command arguments array for secure execution\n   * @private\n   */\n  buildCommandArgs(request, tempFilePath) {\n    // Validate tempFilePath to prevent injection\n    if (!tempFilePath || typeof tempFilePath !== 'string') {\n      throw new BackendError(\n        'Invalid temporary file path',\n        ErrorTypes.VALIDATION_ERROR,\n        'INVALID_TEMP_FILE_PATH'\n      );\n    }\n    \n    const args = [\n      '--yes',\n      '--no-check-update',\n      '--no-analytics',\n      '--message-file',\n      tempFilePath // Separate argument to prevent injection\n    ];\n    \n    // Handle auto-commit option\n    if (!request.options?.autoCommit && !this.config.autoCommit) {\n      args.push('--no-auto-commits');\n    }\n    \n    // Add model selection\n    const model = this.selectModel(request);\n    if (model) {\n      // Validate model name to prevent injection\n      if (this.isValidModelName(model)) {\n        args.push('--model');\n        args.push(model);\n      } else {\n        this.log('warn', `Invalid model name ignored: ${model}`);\n      }\n    }\n    \n    // Add timeout if specified\n    if (request.options?.timeout || this.config.timeout) {\n      const timeoutSeconds = Math.floor((request.options?.timeout || this.config.timeout) / 1000);\n      // Note: aider doesn't have a built-in timeout, this would need to be handled at process level\n    }\n    \n    // Add additional arguments from config with validation\n    if (this.config.additionalArgs && this.config.additionalArgs.length > 0) {\n      const validatedArgs = this.validateAdditionalArgs(this.config.additionalArgs);\n      args.push(...validatedArgs);\n    }\n    \n    // Add any custom arguments from request with validation\n    if (request.options?.additionalArgs) {\n      const validatedArgs = this.validateAdditionalArgs(request.options.additionalArgs);\n      args.push(...validatedArgs);\n    }\n    \n    return args;\n  }\n\n  /**\n   * Select the appropriate model based on configuration and environment\n   * @param {import('../types/BackendTypes').ImplementRequest} request - Implementation request\n   * @returns {string|null} Model identifier or null\n   * @private\n   */\n  selectModel(request) {\n    // Priority: request option > config > environment-based auto-selection\n    if (request.options?.model) {\n      return request.options.model;\n    }\n    \n    if (this.config.model) {\n      return this.config.model;\n    }\n    \n    if (this.config.modelSelection === 'auto') {\n      // Auto-select based on available API keys\n      const geminiApiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_API_KEY;\n      const anthropicApiKey = process.env.ANTHROPIC_API_KEY;\n      const openaiApiKey = process.env.OPENAI_API_KEY;\n      \n      if (geminiApiKey) {\n        return 'gemini/gemini-2.5-pro';\n      } else if (anthropicApiKey) {\n        return 'claude-3-5-sonnet-20241022';\n      } else if (openaiApiKey) {\n        return 'gpt-4';\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Validate model name to prevent command injection\n   * @param {string} model - Model name to validate\n   * @returns {boolean} True if valid, false otherwise\n   * @private\n   */\n  isValidModelName(model) {\n    // Just check if it's a non-empty string\n    // Model names change frequently and formats vary\n    return model && typeof model === 'string' && model.trim().length > 0;\n  }\n\n  /**\n   * Validate additional arguments to prevent command injection\n   * @param {Array<string>} args - Arguments to validate\n   * @returns {Array<string>} Validated arguments\n   * @private\n   */\n  validateAdditionalArgs(args) {\n    if (!Array.isArray(args)) {\n      this.log('warn', 'additionalArgs must be an array, ignoring');\n      return [];\n    }\n    \n    const validatedArgs = [];\n    const maxArgLength = 500; // Reasonable limit for individual arguments\n    \n    for (const arg of args) {\n      if (typeof arg !== 'string') {\n        this.log('warn', `Skipping non-string argument: ${typeof arg}`);\n        continue;\n      }\n      \n      if (arg.length > maxArgLength) {\n        this.log('warn', `Skipping overly long argument (${arg.length} chars)`);\n        continue;\n      }\n      \n      // Check for dangerous patterns\n      if (this.containsShellMetacharacters(arg)) {\n        this.log('warn', `Skipping argument with shell metacharacters: ${arg.substring(0, 50)}`);\n        continue;\n      }\n      \n      // Validate common aider flags\n      if (this.isValidAiderArgument(arg)) {\n        validatedArgs.push(arg);\n      } else {\n        this.log('warn', `Skipping potentially unsafe argument: ${arg.substring(0, 50)}`);\n      }\n    }\n    \n    return validatedArgs;\n  }\n\n  /**\n   * Check if string contains shell metacharacters\n   * @param {string} str - String to check\n   * @returns {boolean} True if contains metacharacters\n   * @private\n   */\n  containsShellMetacharacters(str) {\n    // Common shell metacharacters that could be used for injection\n    const shellMetacharacters = /[;&|`$(){}[\\]<>*?'\"\\\\]/;\n    const controlChars = /[\\x00-\\x1f\\x7f]/; // Control characters\n    \n    return shellMetacharacters.test(str) || controlChars.test(str);\n  }\n\n  /**\n   * Validate if argument is a known safe aider argument\n   * @param {string} arg - Argument to validate\n   * @returns {boolean} True if valid aider argument\n   * @private\n   */\n  isValidAiderArgument(arg) {\n    // Whitelist of known safe aider arguments\n    const safeAiderFlags = [\n      '--yes', '--no-check-update', '--no-analytics', '--no-auto-commits',\n      '--model', '--message-file', '--dry-run', '--map-tokens', '--show-model-warnings',\n      '--no-show-model-warnings', '--edit-format', '--architect', '--weak-model',\n      '--cache-prompts', '--no-cache-prompts', '--map-refresh', '--restore-chat-history',\n      '--encoding', '--config'\n    ];\n    \n    // Check if it's a known flag\n    if (safeAiderFlags.includes(arg)) {\n      return true;\n    }\n    \n    // Check if it's a flag with equals sign (like --model=value)\n    for (const flag of safeAiderFlags) {\n      if (arg.startsWith(flag + '=')) {\n        const value = arg.substring(flag.length + 1);\n        return !this.containsShellMetacharacters(value) && value.length <= 100;\n      }\n    }\n    \n    // Allow simple values that don't look like flags if they're safe\n    if (!arg.startsWith('-') && !this.containsShellMetacharacters(arg) && arg.length <= 100) {\n      return true;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Validate command path to prevent command injection\n   * @param {string} command - Command to validate\n   * @returns {boolean} True if valid\n   * @private\n   */\n  isValidCommand(command) {\n    if (!command || typeof command !== 'string') {\n      return false;\n    }\n    \n    // Only allow alphanumeric, hyphens, underscores, and forward slashes for paths\n    const validCommandPattern = /^[a-zA-Z0-9._/-]+$/;\n    const maxLength = 200; // Reasonable limit for command paths\n    \n    return validCommandPattern.test(command) && \n           command.length <= maxLength && \n           !this.containsShellMetacharacters(command);\n  }\n\n  /**\n   * Validate working directory path\n   * @param {string} dir - Directory path to validate\n   * @returns {string} Validated directory path\n   * @private\n   */\n  validateWorkingDirectory(dir) {\n    if (!dir || typeof dir !== 'string') {\n      throw new BackendError(\n        'Invalid working directory',\n        ErrorTypes.VALIDATION_ERROR,\n        'INVALID_WORKING_DIRECTORY'\n      );\n    }\n    \n    // Resolve path to prevent directory traversal\n    const resolvedPath = path.resolve(dir);\n    \n    // Basic validation - ensure it doesn't contain obvious injection attempts\n    if (this.containsShellMetacharacters(resolvedPath)) {\n      throw new BackendError(\n        'Working directory contains unsafe characters',\n        ErrorTypes.VALIDATION_ERROR,\n        'UNSAFE_WORKING_DIRECTORY'\n      );\n    }\n    \n    return resolvedPath;\n  }\n\n  /**\n   * Validate environment variables\n   * @param {Object} env - Environment variables to validate\n   * @returns {Object} Validated environment variables\n   * @private\n   */\n  validateEnvironment(env) {\n    if (!env || typeof env !== 'object') {\n      return {};\n    }\n    \n    const validatedEnv = {};\n    const maxValueLength = 1000; // Reasonable limit for env values\n    \n    for (const [key, value] of Object.entries(env)) {\n      // Validate key\n      if (typeof key !== 'string' || !/^[A-Z_][A-Z0-9_]*$/i.test(key)) {\n        this.log('warn', `Skipping invalid environment variable key: ${key}`);\n        continue;\n      }\n      \n      // Validate value\n      if (typeof value !== 'string') {\n        this.log('warn', `Skipping non-string environment variable value for: ${key}`);\n        continue;\n      }\n      \n      if (value.length > maxValueLength) {\n        this.log('warn', `Skipping overly long environment variable value for: ${key}`);\n        continue;\n      }\n      \n      // Don't allow control characters in environment variables\n      if (/[\\x00-\\x1f\\x7f]/.test(value)) {\n        this.log('warn', `Skipping environment variable with control characters: ${key}`);\n        continue;\n      }\n      \n      validatedEnv[key] = value;\n    }\n    \n    return validatedEnv;\n  }\n\n  /**\n   * Execute aider command\n   * @param {string} workingDir - Working directory\n   * @param {import('../types/BackendTypes').ImplementRequest} request - Implementation request\n   * @param {Object} sessionInfo - Session information\n   * @param {ProgressTracker} progressTracker - Progress tracker\n   * @returns {Promise<import('../types/BackendTypes').ImplementResult>}\n   * @private\n   */\n  async executeCommand(workingDir, request, sessionInfo, progressTracker) {\n    return new Promise((resolve, reject) => {\n      const startTime = Date.now();\n      \n      // Build command arguments securely\n      const commandArgs = this.buildCommandArgs(request, sessionInfo.tempFile);\n      const commandPath = this.config.command || 'aider';\n      \n      this.log('info', 'Executing aider command', {\n        command: commandPath,\n        args: commandArgs.slice(0, 5), // Log first few args only for security\n        workingDir\n      });\n      \n      // Validate command exists and is safe\n      if (!this.isValidCommand(commandPath)) {\n        throw new BackendError(\n          'Invalid or unsafe command path',\n          ErrorTypes.VALIDATION_ERROR,\n          'INVALID_COMMAND_PATH'\n        );\n      }\n      \n      // Spawn the process directly (no shell interpretation)\n      const childProcess = spawn(commandPath, commandArgs, {\n        cwd: workingDir,\n        env: { ...process.env, ...this.validateEnvironment(this.config.environment) }\n      });\n      \n      sessionInfo.childProcess = childProcess;\n      sessionInfo.cancel = () => {\n        if (childProcess && !childProcess.killed) {\n          this.log('info', 'Cancelling aider process', { sessionId: request.sessionId });\n          childProcess.kill('SIGTERM');\n          setTimeout(() => {\n            if (!childProcess.killed) {\n              childProcess.kill('SIGKILL');\n            }\n          }, 5000);\n        }\n      };\n      \n      let stdoutData = '';\n      let stderrData = '';\n      let outputSize = 0;\n      let lastProgressUpdate = Date.now();\n      \n      // Handle stdout\n      childProcess.stdout.on('data', (data) => {\n        const output = data.toString();\n        outputSize += output.length;\n        \n        // Check output size limit\n        if (outputSize > this.config.maxOutputSize) {\n          childProcess.kill('SIGTERM');\n          reject(new BackendError(\n            'Output size exceeded maximum limit',\n            ErrorTypes.EXECUTION_FAILED,\n            'OUTPUT_TOO_LARGE',\n            { limit: this.config.maxOutputSize, actual: outputSize }\n          ));\n          return;\n        }\n        \n        stdoutData += output;\n        \n        // Stream output to stderr for real-time visibility\n        process.stderr.write(output);\n        \n        // Send progress updates (throttled)\n        const now = Date.now();\n        if (now - lastProgressUpdate > 1000) { // Update every second\n          progressTracker.reportMessage(output.trim(), 'stdout');\n          lastProgressUpdate = now;\n          \n          // Update session progress\n          const elapsedSeconds = Math.floor((now - startTime) / 1000);\n          const estimatedProgress = Math.min(25 + (elapsedSeconds * 2), 90); // Cap at 90%\n          this.updateSessionStatus(request.sessionId, {\n            progress: estimatedProgress\n          });\n        }\n      });\n      \n      // Handle stderr\n      childProcess.stderr.on('data', (data) => {\n        const output = data.toString();\n        stderrData += output;\n        \n        // Stream to stderr\n        process.stderr.write(output);\n        \n        // Report warnings\n        if (output.toLowerCase().includes('warning') || output.toLowerCase().includes('error')) {\n          progressTracker.reportMessage(output.trim(), 'stderr');\n        }\n      });\n      \n      // Handle process completion\n      childProcess.on('close', (code) => {\n        const executionTime = Date.now() - startTime;\n        \n        // Clear timeout\n        clearTimeout(timeoutId);\n        \n        this.log('info', `Aider process exited`, {\n          code,\n          executionTime,\n          outputSize: stdoutData.length\n        });\n        \n        // Parse file changes from output\n        const changes = FileChangeParser.parseChanges(stdoutData + stderrData, workingDir);\n        const diffStats = FileChangeParser.extractDiffStats(stdoutData + stderrData);\n        \n        if (code === 0) {\n          // Check for errors in output even if exit code is 0\n          const combinedOutput = stdoutData + stderrData;\n          const hasAuthError = /AuthenticationError|Invalid API key|insufficient permissions|not able to authenticate/i.test(combinedOutput);\n          const hasOtherErrors = /Error:|Exception:|Failed:|fatal:/i.test(combinedOutput);\n          const hasChanges = changes.length > 0;\n          \n          // Only consider it successful if:\n          // 1. No authentication/critical errors found in output\n          // 2. Either changes were made OR this was an informational command\n          const isActualSuccess = !hasAuthError && !hasOtherErrors && (hasChanges || !request.requiresChanges);\n          \n          if (isActualSuccess) {\n            resolve({\n              success: true,\n              sessionId: request.sessionId,\n              output: stdoutData,\n              changes,\n              metrics: {\n                executionTime,\n                filesModified: changes.length,\n                linesChanged: diffStats.insertions + diffStats.deletions,\n                tokensUsed: TokenEstimator.estimate(request.task + stdoutData),\n                exitCode: code\n              },\n              metadata: {\n                command: commandPath,\n                args: commandArgs.slice(0, 5), // Limited args for security\n                workingDirectory: workingDir,\n                aiderVersion: this.aiderVersion\n              }\n            });\n          } else {\n            // Exit code 0 but actual failure detected\n            const errorType = hasAuthError ? 'AUTHENTICATION_ERROR' : 'EXECUTION_FAILED';\n            const errorMessage = hasAuthError \n              ? 'Authentication failed - check API key and permissions'\n              : `Aider completed but encountered errors: ${combinedOutput.substring(0, 200)}...`;\n            \n            reject(new BackendError(\n              errorMessage,\n              hasAuthError ? ErrorTypes.AUTHENTICATION : ErrorTypes.EXECUTION_FAILED,\n              errorType,\n              {\n                exitCode: code,\n                hasChanges,\n                hasAuthError,\n                hasOtherErrors,\n                stdout: stdoutData.substring(0, 1000),\n                stderr: stderrData.substring(0, 1000)\n              }\n            ));\n          }\n        } else {\n          reject(new BackendError(\n            `Aider process exited with code ${code}`,\n            ErrorTypes.EXECUTION_FAILED,\n            'AIDER_PROCESS_FAILED',\n            {\n              exitCode: code,\n              stdout: stdoutData.substring(0, 1000),\n              stderr: stderrData.substring(0, 1000)\n            }\n          ));\n        }\n      });\n      \n      // Handle process errors\n      childProcess.on('error', (error) => {\n        // Clear timeout\n        clearTimeout(timeoutId);\n        \n        this.log('error', 'Failed to spawn aider process', { error: error.message });\n        reject(new BackendError(\n          `Failed to spawn aider process: ${error.message}`,\n          ErrorTypes.EXECUTION_FAILED,\n          'AIDER_SPAWN_FAILED',\n          { originalError: error }\n        ));\n      });\n      \n      // Set timeout\n      const timeout = request.options?.timeout || this.config.timeout;\n      const timeoutId = setTimeout(() => {\n        if (!childProcess.killed) {\n          this.log('warn', 'Aider execution timed out', { timeout });\n          childProcess.kill('SIGTERM');\n          reject(new BackendError(\n            `Aider execution timed out after ${timeout}ms`,\n            ErrorTypes.TIMEOUT,\n            'AIDER_TIMEOUT',\n            { timeout }\n          ));\n        }\n      }, timeout);\n    });\n  }\n}\n\nexport default AiderBackend;", "/**\n * Claude Code SDK backend implementation\n * @module ClaudeCodeBackend\n */\n\nimport BaseBackend from './BaseBackend.js';\nimport { BackendError, ErrorTypes, ProgressTracker, FileChangeParser, TokenEstimator } from '../core/utils.js';\nimport { exec, spawn } from 'child_process';\nimport { promisify } from 'util';\nimport path from 'path';\nimport { TIMEOUTS, getDefaultTimeoutMs } from '../core/timeouts.js';\n\nconst execPromise = promisify(exec);\n\n/**\n * Claude Code SDK implementation backend\n * @class\n * @extends BaseBackend\n */\nclass ClaudeCodeBackend extends BaseBackend {\n  constructor() {\n    super('claude-code', '1.0.0');\n    this.config = null;\n  }\n\n  /**\n   * @override\n   */\n  async initialize(config) {\n    this.config = {\n      apiKey: config.apiKey || process.env.ANTHROPIC_API_KEY,\n      model: config.model || 'claude-3-5-sonnet-20241022',\n      baseUrl: config.baseUrl,\n      timeout: config.timeout || getDefaultTimeoutMs(), // Use centralized default (20 minutes)\n      maxTokens: config.maxTokens || 8000,\n      temperature: config.temperature || 0.3,\n      systemPrompt: config.systemPrompt,\n      tools: config.tools || ['edit', 'search', 'bash'],\n      maxTurns: config.maxTurns || 100,\n      ...config\n    };\n    \n    try {\n      // Claude Code backend only uses CLI interface\n      this.log('debug', 'Using Claude Code CLI interface');\n      \n      // Validate configuration\n      await this.validateConfiguration();\n      \n      // Test connection/availability\n      const available = await this.isAvailable();\n      if (!available) {\n        throw new Error('Claude Code is not available');\n      }\n      \n      this.initialized = true;\n      \n    } catch (error) {\n      throw new BackendError(\n        `Failed to initialize Claude Code backend: ${error.message}`,\n        ErrorTypes.INITIALIZATION_FAILED,\n        'CLAUDE_CODE_INIT_FAILED',\n        { originalError: error }\n      );\n    }\n  }\n\n  /**\n   * @override\n   */\n  async isAvailable() {\n    if (!this.config.apiKey) {\n      this.log('warn', 'No API key configured');\n      return false;\n    }\n    \n    try {\n      let claudeCommand = null;\n      \n      // Method 1: Try direct execution with claude --version\n      try {\n        await execPromise('claude --version', { timeout: TIMEOUTS.VERSION_CHECK });\n        claudeCommand = 'claude';\n        this.log('debug', 'Claude found in PATH via direct execution');\n      } catch (directError) {\n        this.log('debug', 'Claude not directly executable from PATH', { error: directError.message });\n      }\n      \n      // Method 2: Check npm global installation and find the binary\n      if (!claudeCommand) {\n        try {\n          const { stdout } = await execPromise('npm list -g @anthropic-ai/claude-code --depth=0', { timeout: TIMEOUTS.VERSION_CHECK });\n          if (stdout.includes('@anthropic-ai/claude-code')) {\n            // Get npm global bin directory\n            const { stdout: binPath } = await execPromise('npm bin -g', { timeout: TIMEOUTS.VERSION_CHECK });\n            const npmBinDir = binPath.trim();\n            \n            // Build the claude command path\n            const isWindows = process.platform === 'win32';\n            const claudeBinary = isWindows ? 'claude.cmd' : 'claude';\n            const claudePath = path.join(npmBinDir, claudeBinary);\n            \n            // Test if we can execute it\n            try {\n              await execPromise(`\"${claudePath}\" --version`, { timeout: TIMEOUTS.VERSION_CHECK });\n              claudeCommand = claudePath;\n              \n              // Update PATH for this process to include npm global bin\n              const pathSeparator = isWindows ? ';' : ':';\n              process.env.PATH = `${npmBinDir}${pathSeparator}${process.env.PATH}`;\n              \n              this.log('debug', `Claude found at ${claudePath}, added ${npmBinDir} to PATH`);\n            } catch (execError) {\n              this.log('debug', `Failed to execute claude at ${claudePath}`, { error: execError.message });\n            }\n          }\n        } catch (npmError) {\n          this.log('debug', 'Failed to check npm global packages', { error: npmError.message });\n        }\n      }\n      \n      // Method 3: Try WSL on Windows\n      if (!claudeCommand && process.platform === 'win32') {\n        try {\n          // Check if WSL is available and claude is installed there\n          const { stdout: wslCheck } = await execPromise('wsl --list', { timeout: TIMEOUTS.WSL_CHECK });\n          if (wslCheck) {\n            this.log('debug', 'WSL detected, checking for claude in WSL');\n            try {\n              // Try to run claude through WSL\n              await execPromise('wsl claude --version', { timeout: TIMEOUTS.VERSION_CHECK });\n              claudeCommand = 'wsl claude';\n              this.log('debug', 'Claude found in WSL');\n            } catch (wslClaudeError) {\n              this.log('debug', 'Claude not found in WSL', { error: wslClaudeError.message });\n              \n              // Try common WSL paths\n              const wslPaths = [\n                'wsl /usr/local/bin/claude',\n                'wsl ~/.npm-global/bin/claude',\n                'wsl ~/.local/bin/claude',\n                'wsl ~/node_modules/.bin/claude'\n              ];\n              \n              for (const wslPath of wslPaths) {\n                try {\n                  await execPromise(`${wslPath} --version`, { timeout: TIMEOUTS.WSL_CHECK });\n                  claudeCommand = wslPath;\n                  this.log('debug', `Claude found in WSL at: ${wslPath}`);\n                  break;\n                } catch (e) {\n                  // Continue searching\n                }\n              }\n            }\n          }\n        } catch (wslError) {\n          this.log('debug', 'WSL not available or accessible', { error: wslError.message });\n        }\n      }\n      \n      // Method 4: Try to find claude in common locations\n      if (!claudeCommand) {\n        const isWindows = process.platform === 'win32';\n        const homeDir = process.env[isWindows ? 'USERPROFILE' : 'HOME'];\n        const claudeBinary = isWindows ? 'claude.cmd' : 'claude';\n        \n        // Common npm global locations\n        const commonPaths = [\n          // Windows paths\n          isWindows && path.join(process.env.APPDATA || '', 'npm', claudeBinary),\n          isWindows && path.join('C:', 'Program Files', 'nodejs', claudeBinary),\n          // Unix-like paths\n          !isWindows && path.join('/usr/local/bin', claudeBinary),\n          !isWindows && path.join(homeDir, '.npm-global', 'bin', claudeBinary),\n          !isWindows && path.join(homeDir, '.local', 'bin', claudeBinary),\n          // Cross-platform home directory paths\n          path.join(homeDir, 'node_modules', '.bin', claudeBinary),\n        ].filter(Boolean);\n        \n        for (const claudePath of commonPaths) {\n          try {\n            await execPromise(`\"${claudePath}\" --version`, { timeout: TIMEOUTS.WSL_CHECK });\n            claudeCommand = claudePath;\n            this.log('debug', `Claude found at ${claudePath}`);\n            break;\n          } catch (e) {\n            // Continue searching\n          }\n        }\n      }\n      \n      if (!claudeCommand) {\n        this.log('warn', 'Claude Code CLI not found. Please install with: npm install -g @anthropic-ai/claude-code (or in WSL on Windows)');\n        return false;\n      }\n      \n      // Store the command for later use\n      this.claudeCommand = claudeCommand;\n      \n      // Just verify the API key exists (non-empty)\n      // Don't validate format as it can vary\n      if (!this.config.apiKey || this.config.apiKey.trim() === '') {\n        this.log('warn', 'API key is not configured');\n        return false;\n      }\n      \n      return true;\n    } catch (error) {\n      this.log('debug', 'Availability check failed', { error: error.message });\n      return false;\n    }\n  }\n\n  /**\n   * @override\n   */\n  getRequiredDependencies() {\n    return [\n      {\n        name: 'claude-code',\n        type: 'cli',\n        installCommand: 'npm install -g @anthropic-ai/claude-code',\n        description: 'Claude Code CLI tool'\n      },\n      {\n        name: 'ANTHROPIC_API_KEY',\n        type: 'environment',\n        description: 'Anthropic API key for Claude Code'\n      }\n    ];\n  }\n\n  /**\n   * @override\n   */\n  getCapabilities() {\n    return {\n      supportsLanguages: ['javascript', 'typescript', 'python', 'rust', 'go', 'java', 'c++', 'c#', 'ruby', 'php', 'swift'],\n      supportsStreaming: true,\n      supportsRollback: false,\n      supportsDirectFileEdit: true,\n      supportsPlanGeneration: true,\n      supportsTestGeneration: true,\n      maxConcurrentSessions: 5\n    };\n  }\n\n  /**\n   * @override\n   */\n  getDescription() {\n    return 'Claude Code CLI - Advanced AI coding assistant powered by Claude';\n  }\n\n  /**\n   * @override\n   */\n  async execute(request) {\n    this.checkInitialized();\n    \n    const validation = this.validateRequest(request);\n    if (!validation.valid) {\n      throw new BackendError(\n        `Invalid request: ${validation.errors.join(', ')}`,\n        ErrorTypes.VALIDATION_ERROR,\n        'INVALID_REQUEST'\n      );\n    }\n    \n    const sessionInfo = this.createSessionInfo(request.sessionId);\n    const progressTracker = new ProgressTracker(request.sessionId, request.callbacks?.onProgress);\n    \n    this.activeSessions.set(request.sessionId, sessionInfo);\n    \n    try {\n      progressTracker.startStep('prepare', 'Preparing Claude Code execution');\n      \n      // Build the prompt\n      const prompt = this.buildPrompt(request);\n      const workingDir = request.context?.workingDirectory || process.cwd();\n      \n      this.updateSessionStatus(request.sessionId, {\n        status: 'running',\n        progress: 25,\n        message: 'Claude Code is processing your request'\n      });\n      \n      progressTracker.endStep();\n      progressTracker.startStep('execute', 'Executing with Claude Code');\n      \n      // Always use CLI interface\n      const result = await this.executeWithCLI(prompt, workingDir, request, sessionInfo, progressTracker);\n      \n      progressTracker.endStep();\n      \n      this.updateSessionStatus(request.sessionId, {\n        status: 'completed',\n        progress: 100,\n        message: 'Implementation completed successfully'\n      });\n      \n      return result;\n      \n    } catch (error) {\n      this.updateSessionStatus(request.sessionId, {\n        status: 'failed',\n        message: error.message\n      });\n      \n      if (error instanceof BackendError) {\n        throw error;\n      }\n      \n      throw new BackendError(\n        `Claude Code execution failed: ${error.message}`,\n        ErrorTypes.EXECUTION_FAILED,\n        'CLAUDE_CODE_EXECUTION_FAILED',\n        { originalError: error, sessionId: request.sessionId }\n      );\n    } finally {\n      this.activeSessions.delete(request.sessionId);\n    }\n  }\n\n  /**\n   * Validate configuration\n   * @private\n   */\n  async validateConfiguration() {\n    if (!this.config.apiKey) {\n      throw new Error('API key is required. Set ANTHROPIC_API_KEY environment variable or provide apiKey in config');\n    }\n    \n    // No format validation - API key formats can vary\n    // Model validation removed - model names change frequently\n    \n    // Tools validation not needed since we always use --dangerously-skip-permissions\n  }\n\n  /**\n   * Build prompt for Claude Code\n   * @param {import('../types/BackendTypes').ImplementRequest} request - Implementation request\n   * @returns {string} Formatted prompt\n   * @private\n   */\n  buildPrompt(request) {\n    let prompt = '';\n    \n    // Add context if provided\n    if (request.context?.additionalContext) {\n      prompt += `Context:\\n${request.context.additionalContext}\\n\\n`;\n    }\n    \n    // Add main task\n    prompt += `Task:\\n${request.task}\\n`;\n    \n    // Add constraints\n    if (request.context?.allowedFiles && request.context.allowedFiles.length > 0) {\n      prompt += `\\nOnly modify these files: ${request.context.allowedFiles.join(', ')}\\n`;\n    }\n    \n    if (request.context?.language) {\n      prompt += `\\nPrimary language: ${request.context.language}\\n`;\n    }\n    \n    // Add options\n    if (request.options?.generateTests) {\n      prompt += '\\nAlso generate appropriate tests for the implemented functionality.\\n';\n    }\n    \n    if (request.options?.dryRun) {\n      prompt += '\\nThis is a dry run - describe what changes would be made without actually implementing them.\\n';\n    }\n    \n    return prompt.trim();\n  }\n\n  /**\n   * Build system prompt for Claude Code\n   * @param {import('../types/BackendTypes').ImplementRequest} request - Implementation request\n   * @returns {string} System prompt\n   * @private\n   */\n  buildSystemPrompt(request) {\n    if (this.config.systemPrompt) {\n      return this.config.systemPrompt;\n    }\n    \n    return `You are an expert software developer assistant using Claude Code. Your task is to implement code changes based on user requirements.\n\nKey guidelines:\n- Follow best practices for the detected programming language\n- Write clean, maintainable, and well-documented code\n- Include error handling where appropriate\n- Consider edge cases and potential issues\n- Generate tests when requested or when it would be beneficial\n- Make minimal, focused changes that achieve the requested functionality\n- Preserve existing code style and conventions\n\nWorking directory: ${request.context?.workingDirectory || process.cwd()}\n${request.context?.allowedFiles ? `Allowed files: ${request.context.allowedFiles.join(', ')}` : ''}\n${request.context?.language ? `Primary language: ${request.context.language}` : ''}`;\n  }\n\n\n  /**\n   * Execute using CLI interface\n   * @private\n   */\n  async executeWithCLI(prompt, workingDir, request, sessionInfo, progressTracker) {\n    const startTime = Date.now();\n    \n    // Build Claude Code CLI arguments securely\n    const args = this.buildSecureCommandArgs(request);\n    \n    // Add the prompt using -p flag (multiline strings are handled safely by spawn)\n    const validatedPrompt = this.validatePrompt(prompt);\n    args.unshift('-p', validatedPrompt);\n    \n    this.log('debug', 'Executing Claude Code CLI', {\n      command: 'claude',\n      args: args.slice(0, 5), // Log first few args only for security\n      workingDir\n    });\n    \n    // Always log command info to stderr for debugging (visible in all modes)\n    console.error(`[INFO] Claude Code execution details:`);\n    console.error(`[INFO] Working directory: ${workingDir}`);\n    console.error(`[INFO] Environment: ANTHROPIC_API_KEY=${this.config.apiKey ? '***set***' : '***not set***'}`);\n    console.error(`[INFO] Prompt length: ${validatedPrompt.length} characters`);\n    \n    return new Promise(async (resolve, reject) => {\n      // Use spawn instead of exec for better security\n      // Use the command we found during isAvailable() check\n      let claudeCommand = this.claudeCommand || 'claude';\n      \n      // If we don't have a stored command, try to find it again\n      if (!this.claudeCommand) {\n        try {\n          // Try direct execution first\n          await execPromise('claude --version', { timeout: TIMEOUTS.PATH_CHECK });\n          claudeCommand = 'claude';\n        } catch (e) {\n          const isWindows = process.platform === 'win32';\n          \n          // Try WSL on Windows\n          if (isWindows) {\n            try {\n              await execPromise('wsl claude --version', { timeout: TIMEOUTS.WSL_CHECK });\n              claudeCommand = 'wsl claude';\n              this.log('debug', 'Using claude from WSL');\n            } catch (wslError) {\n              // Continue to npm global check\n            }\n          }\n          \n          // Try to find it in npm global bin\n          if (claudeCommand === 'claude') {\n            try {\n              const { stdout: binPath } = await execPromise('npm bin -g', { timeout: TIMEOUTS.PATH_CHECK });\n              const claudeBinary = isWindows ? 'claude.cmd' : 'claude';\n              const potentialClaudePath = path.join(binPath.trim(), claudeBinary);\n              \n              // Test if we can execute it\n              await execPromise(`\"${potentialClaudePath}\" --version`, { timeout: TIMEOUTS.PATH_CHECK });\n              claudeCommand = potentialClaudePath;\n              this.log('debug', `Using claude from npm global: ${claudeCommand}`);\n            } catch (npmError) {\n              // Fall back to 'claude' and let it fail with a clear error\n              this.log('warn', 'Could not find claude in npm global bin or WSL, attempting direct execution');\n            }\n          }\n        }\n      }\n      \n      // Special handling for WSL commands\n      let spawnCommand = claudeCommand;\n      let spawnArgs = args;\n      \n      if (claudeCommand.startsWith('wsl ')) {\n        // Split WSL command properly\n        const wslParts = claudeCommand.split(' ');\n        spawnCommand = wslParts[0]; // 'wsl'\n        spawnArgs = [...wslParts.slice(1), ...args]; // claude path + original args\n      }\n      \n      // Log the exact spawn command to stderr (always visible)\n      console.error(`[INFO] Executing command: ${spawnCommand} ${spawnArgs.join(' ')}`);\n      console.error(`[INFO] Shell mode: ${process.platform === 'win32'}`);\n      \n      const child = spawn(spawnCommand, spawnArgs, {\n        cwd: workingDir,\n        env: this.buildSecureEnvironment(),\n        stdio: ['pipe', 'pipe', 'pipe'],\n        shell: process.platform === 'win32' // Use shell on Windows for .cmd files\n      });\n      \n      sessionInfo.childProcess = child;\n      sessionInfo.cancel = () => {\n        if (child && !child.killed) {\n          child.kill('SIGTERM');\n        }\n      };\n      \n      let output = '';\n      let errorOutput = '';\n      \n      // No need to send prompt to stdin - it's passed via -p argument\n      if (child.stdin) {\n        child.stdin.end();\n      }\n      \n      // Handle stdout\n      if (child.stdout) {\n        child.stdout.on('data', (data) => {\n          const chunk = data.toString();\n          output += chunk;\n          \n          // Stream to stderr for visibility\n          process.stderr.write(chunk);\n          \n          // Report progress\n          progressTracker.reportMessage(chunk.trim(), 'stdout');\n        });\n      }\n      \n      // Handle stderr\n      if (child.stderr) {\n        child.stderr.on('data', (data) => {\n          const chunk = data.toString();\n          errorOutput += chunk;\n          \n          // Stream to stderr\n          process.stderr.write(chunk);\n          \n          // Check for errors\n          if (chunk.toLowerCase().includes('error')) {\n            progressTracker.reportMessage(chunk.trim(), 'stderr');\n          }\n        });\n      }\n      \n      // Handle completion\n      child.on('close', (code) => {\n        const executionTime = Date.now() - startTime;\n        \n        // Clear timeout\n        clearTimeout(timeoutId);\n        \n        if (code === 0) {\n          // Parse changes from output\n          const changes = FileChangeParser.parseChanges(output, workingDir);\n          \n          resolve({\n            success: true,\n            sessionId: request.sessionId,\n            output,\n            changes,\n            metrics: {\n              executionTime,\n              tokensUsed: TokenEstimator.estimate(prompt + output),\n              filesModified: changes.length,\n              linesChanged: 0,\n              exitCode: code\n            },\n            metadata: {\n              command: 'claude',\n              args: args.slice(0, 5), // Limited args for security\n              model: this.config.model\n            }\n          });\n        } else {\n          // Log full error details to stderr\n          console.error(`[ERROR] Claude Code CLI failed with exit code: ${code}`);\n          console.error(`[ERROR] Full command: ${claudeCommand} ${args.join(' ')}`);\n          console.error(`[ERROR] Working directory: ${workingDir}`);\n          console.error(`[ERROR] Full stdout output:`);\n          console.error(output || '(no stdout)');\n          console.error(`[ERROR] Full stderr output:`);\n          console.error(errorOutput || '(no stderr)');\n          console.error(`[ERROR] Execution time: ${Date.now() - startTime}ms`);\n          \n          reject(new BackendError(\n            `Claude Code CLI exited with code ${code}`,\n            ErrorTypes.EXECUTION_FAILED,\n            'CLI_EXECUTION_FAILED',\n            {\n              exitCode: code,\n              stdout: output.substring(0, 1000),\n              stderr: errorOutput.substring(0, 1000)\n            }\n          ));\n        }\n      });\n      \n      // Handle errors\n      child.on('error', (error) => {\n        // Clear timeout\n        clearTimeout(timeoutId);\n        \n        // Log full error details to stderr\n        console.error(`[ERROR] Failed to spawn Claude Code CLI process:`);\n        console.error(`[ERROR] Command: ${spawnCommand}`);\n        console.error(`[ERROR] Args: ${spawnArgs.join(' ')}`);\n        console.error(`[ERROR] Working directory: ${workingDir}`);\n        console.error(`[ERROR] Error message: ${error.message}`);\n        console.error(`[ERROR] Error code: ${error.code || 'unknown'}`);\n        console.error(`[ERROR] Error signal: ${error.signal || 'none'}`);\n        console.error(`[ERROR] Full error:`, error);\n        \n        reject(new BackendError(\n          `Failed to execute Claude Code CLI: ${error.message}`,\n          ErrorTypes.EXECUTION_FAILED,\n          'CLI_SPAWN_FAILED',\n          { originalError: error }\n        ));\n      });\n      \n      // Set timeout\n      const timeout = request.options?.timeout || this.config.timeout;\n      const timeoutId = setTimeout(() => {\n        if (!child.killed) {\n          // Log timeout details to stderr\n          console.error(`[ERROR] Claude Code CLI timed out after ${timeout}ms`);\n          console.error(`[ERROR] Command: ${spawnCommand} ${spawnArgs.join(' ')}`);\n          console.error(`[ERROR] Working directory: ${workingDir}`);\n          console.error(`[ERROR] Partial stdout output:`);\n          console.error(output || '(no stdout)');\n          console.error(`[ERROR] Partial stderr output:`);\n          console.error(errorOutput || '(no stderr)');\n          \n          child.kill('SIGTERM');\n          reject(new BackendError(\n            `Claude Code execution timed out after ${timeout}ms`,\n            ErrorTypes.TIMEOUT,\n            'CLAUDE_CODE_TIMEOUT',\n            { timeout }\n          ));\n        }\n      }, timeout);\n    });\n  }\n\n\n  /**\n   * Build secure command arguments\n   * @param {import('../types/BackendTypes').ImplementRequest} request - Implementation request\n   * @returns {Array<string>} Secure command arguments\n   * @private\n   */\n  buildSecureCommandArgs(request) {\n    const args = [];\n\n    // Add max turns with validation\n    const maxTurns = this.validateMaxTurns(request.options?.maxTurns || this.config.maxTurns);\n    if (process.env.DEBUG) {\n      this.log('debug', 'Max turns check', { \n        requestMaxTurns: request.options?.maxTurns, \n        configMaxTurns: this.config.maxTurns, \n        validatedMaxTurns: maxTurns\n      });\n    }\n    args.push('--max-turns', maxTurns.toString());\n\n    // Model and temperature are not supported by Claude CLI\n    // Claude CLI uses default model and temperature settings\n\n    // Always use --dangerously-skip-permissions to avoid tool permission complexity\n    args.push('--dangerously-skip-permissions');\n\n    if (process.env.DEBUG) {\n      this.log('debug', 'Final args constructed', { args });\n    }\n    return args;\n  }\n\n  /**\n   * Build secure environment variables\n   * @returns {Object} Secure environment variables\n   * @private\n   */\n  buildSecureEnvironment() {\n    const env = { ...process.env };\n    \n    if (this.config.apiKey && this.isValidApiKey(this.config.apiKey)) {\n      env.ANTHROPIC_API_KEY = this.config.apiKey;\n    }\n\n    return env;\n  }\n\n  /**\n   * Validate API key format\n   * @param {string} apiKey - API key to validate\n   * @returns {boolean} True if valid format\n   * @private\n   */\n  isValidApiKey(apiKey) {\n    // Just check if it's a non-empty string\n    // API key formats can vary between providers and versions\n    return apiKey && typeof apiKey === 'string' && apiKey.trim().length > 0;\n  }\n\n\n  /**\n   * Validate max turns value\n   * @param {number} maxTurns - Max turns to validate\n   * @returns {number} Validated max turns value\n   * @private\n   */\n  validateMaxTurns(maxTurns) {\n    if (typeof maxTurns !== 'number' || isNaN(maxTurns) || maxTurns < 1) {\n      return 100; // Default value\n    }\n    \n    return Math.min(Math.max(Math.floor(maxTurns), 1), 1000); // Clamp between 1 and 1000\n  }\n\n\n  /**\n   * Validate prompt content\n   * @param {string} prompt - Prompt to validate\n   * @returns {string} Validated prompt\n   * @private\n   */\n  validatePrompt(prompt) {\n    if (!prompt || typeof prompt !== 'string') {\n      throw new BackendError(\n        'Invalid prompt content',\n        ErrorTypes.VALIDATION_ERROR,\n        'INVALID_PROMPT'\n      );\n    }\n\n    const maxPromptLength = 100000; // 100KB limit for prompts\n    \n    if (prompt.length > maxPromptLength) {\n      throw new BackendError(\n        `Prompt too long (${prompt.length} chars, max: ${maxPromptLength})`,\n        ErrorTypes.VALIDATION_ERROR,\n        'PROMPT_TOO_LONG'\n      );\n    }\n\n    // Check for control characters that could cause issues\n    if (this.containsControlCharacters(prompt)) {\n      this.log('warn', 'Prompt contains control characters, they will be filtered');\n      return prompt.replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, ''); // Remove most control chars but keep newlines/tabs\n    }\n\n    return prompt;\n  }\n\n  /**\n   * Check if string contains problematic control characters\n   * @param {string} str - String to check\n   * @returns {boolean} True if contains control characters\n   * @private\n   */\n  containsControlCharacters(str) {\n    // Check for control characters excluding newlines and tabs\n    return /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/.test(str);\n  }\n}\n\nexport default ClaudeCodeBackend;", "/**\n * Backend registry for automatic discovery and registration\n * @module registry\n */\n\nimport AiderBackend from './AiderBackend.js';\nimport ClaudeCodeBackend from './ClaudeCodeBackend.js';\n\n/**\n * Available backend classes\n */\nconst AVAILABLE_BACKENDS = {\n  aider: AiderBackend,\n  'claude-code': ClaudeCodeBackend\n};\n\n/**\n * Get all available backend classes\n * @returns {Object<string, typeof BaseBackend>}\n */\nfunction getAvailableBackends() {\n  return { ...AVAILABLE_BACKENDS };\n}\n\n/**\n * Create a backend instance by name\n * @param {string} name - Backend name\n * @returns {BaseBackend|null}\n */\nfunction createBackend(name) {\n  const BackendClass = AVAILABLE_BACKENDS[name];\n  if (!BackendClass) {\n    return null;\n  }\n  \n  return new BackendClass();\n}\n\n/**\n * Register a custom backend class\n * @param {string} name - Backend name\n * @param {typeof BaseBackend} BackendClass - Backend class\n */\nfunction registerBackend(name, BackendClass) {\n  AVAILABLE_BACKENDS[name] = BackendClass;\n}\n\n/**\n * Get backend metadata\n * @param {string} name - Backend name\n * @returns {Object|null}\n */\nfunction getBackendMetadata(name) {\n  const backend = createBackend(name);\n  if (!backend) {\n    return null;\n  }\n  \n  return {\n    name: backend.name,\n    version: backend.version,\n    description: backend.getDescription(),\n    capabilities: backend.getCapabilities(),\n    dependencies: backend.getRequiredDependencies()\n  };\n}\n\n/**\n * List all registered backend names\n * @returns {string[]}\n */\nfunction listBackendNames() {\n  return Object.keys(AVAILABLE_BACKENDS);\n}\n\nexport {\n  getAvailableBackends,\n  createBackend,\n  registerBackend,\n  getBackendMetadata,\n  listBackendNames,\n  // Export backend classes for direct use\n  AiderBackend,\n  ClaudeCodeBackend\n};", "/**\n * Configuration management for the implementation tool\n * @module config\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport { promisify } from 'util';\nimport { fileURLToPath } from 'url';\nimport { TIMEOUTS, getDefaultTimeoutMs, secondsToMs, isValidTimeout } from './timeouts.js';\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\nconst exists = promisify(fs.exists);\n\n/**\n * Configuration manager for implementation backends\n * @class\n */\nclass ConfigManager {\n  constructor() {\n    this.config = null;\n    this.configPath = null;\n    this.watchers = new Map();\n    this.changeCallbacks = [];\n  }\n\n  /**\n   * Initialize configuration\n   * @param {string} [configPath] - Path to configuration file\n   * @returns {Promise<void>}\n   */\n  async initialize(configPath = null) {\n    // Determine config path\n    this.configPath = this.resolveConfigPath(configPath);\n    \n    // Load configuration\n    await this.loadConfig();\n    \n    // Apply environment overrides\n    this.applyEnvironmentOverrides();\n    \n    // Set up file watching\n    if (this.configPath && fs.existsSync(this.configPath)) {\n      this.setupWatcher();\n    }\n  }\n\n  /**\n   * Resolve configuration file path\n   * @param {string} [providedPath] - User-provided path\n   * @returns {string|null}\n   * @private\n   */\n  resolveConfigPath(providedPath) {\n    // Priority order:\n    // 1. Provided path\n    // 2. Environment variable\n    // 3. Local config file\n    // 4. Default config file\n    \n    if (providedPath && fs.existsSync(providedPath)) {\n      return providedPath;\n    }\n    \n    if (process.env.IMPLEMENT_TOOL_CONFIG_PATH) {\n      const envPath = process.env.IMPLEMENT_TOOL_CONFIG_PATH;\n      if (fs.existsSync(envPath)) {\n        return envPath;\n      }\n    }\n    \n    // Check for local config in current directory\n    const localConfig = path.join(process.cwd(), 'implement-config.json');\n    if (fs.existsSync(localConfig)) {\n      return localConfig;\n    }\n    \n    // Fall back to default config\n    const defaultConfig = path.join(__dirname, '..', 'config', 'default.json');\n    if (fs.existsSync(defaultConfig)) {\n      return defaultConfig;\n    }\n    \n    return null;\n  }\n\n  /**\n   * Load configuration from file\n   * @returns {Promise<void>}\n   * @private\n   */\n  async loadConfig() {\n    if (this.configPath && fs.existsSync(this.configPath)) {\n      try {\n        const configData = await readFile(this.configPath, 'utf8');\n        this.config = JSON.parse(configData);\n        console.error(`Loaded configuration from: ${this.configPath}`);\n      } catch (error) {\n        console.error(`Failed to load configuration from ${this.configPath}:`, error.message);\n        this.config = this.getDefaultConfig();\n      }\n    } else {\n      console.error('Using default configuration');\n      this.config = this.getDefaultConfig();\n    }\n  }\n\n  /**\n   * Get default configuration\n   * @returns {Object}\n   * @private\n   */\n  getDefaultConfig() {\n    return {\n      implement: {\n        defaultBackend: 'aider',\n        selectionStrategy: 'auto', \n        maxConcurrentSessions: 3,\n        timeout: getDefaultTimeoutMs(), // Use centralized default (20 minutes)\n        retryAttempts: 2,\n        retryDelay: 5000\n      },\n      backends: {\n        aider: {\n          command: 'aider',\n          timeout: getDefaultTimeoutMs(), // Use centralized default (20 minutes)\n          maxOutputSize: 10485760,\n          additionalArgs: [],\n          environment: {},\n          autoCommit: false,\n          modelSelection: 'auto'\n        },\n        'claude-code': {\n          timeout: getDefaultTimeoutMs(), // Use centralized default (20 minutes)\n          maxTokens: 8000,\n          temperature: 0.3,\n          model: 'claude-3-5-sonnet-20241022',\n          systemPrompt: null,\n          tools: ['edit', 'search', 'bash'],\n          maxTurns: 100\n        }\n      }\n    };\n  }\n\n  /**\n   * Apply environment variable overrides\n   * @private\n   */\n  applyEnvironmentOverrides() {\n    // Backend selection\n    if (process.env.IMPLEMENT_TOOL_BACKEND) {\n      this.config.implement.defaultBackend = process.env.IMPLEMENT_TOOL_BACKEND;\n      console.error(`[ImplementConfig] Setting default backend from env: ${process.env.IMPLEMENT_TOOL_BACKEND}`);\n    }\n    \n    if (process.env.IMPLEMENT_TOOL_FALLBACKS) {\n      this.config.implement.fallbackBackends = process.env.IMPLEMENT_TOOL_FALLBACKS\n        .split(',')\n        .map(s => s.trim())\n        .filter(Boolean);\n    }\n    \n    if (process.env.IMPLEMENT_TOOL_SELECTION_STRATEGY) {\n      this.config.implement.selectionStrategy = process.env.IMPLEMENT_TOOL_SELECTION_STRATEGY;\n    }\n    \n    if (process.env.IMPLEMENT_TOOL_TIMEOUT) {\n      // Convert seconds to milliseconds for backend compatibility\n      const timeoutSeconds = parseInt(process.env.IMPLEMENT_TOOL_TIMEOUT, 10);\n      \n      if (isNaN(timeoutSeconds)) {\n        console.warn(`[Config] Invalid IMPLEMENT_TOOL_TIMEOUT value: ${process.env.IMPLEMENT_TOOL_TIMEOUT}. Using default: ${TIMEOUTS.IMPLEMENT_DEFAULT}s`);\n      } else if (!isValidTimeout(timeoutSeconds)) {\n        console.warn(`[Config] IMPLEMENT_TOOL_TIMEOUT ${timeoutSeconds}s outside valid range ${TIMEOUTS.IMPLEMENT_MINIMUM}-${TIMEOUTS.IMPLEMENT_MAXIMUM}s. Using default: ${TIMEOUTS.IMPLEMENT_DEFAULT}s`);\n      } else {\n        this.config.implement.timeout = secondsToMs(timeoutSeconds);\n        // Log message removed to prevent stdout pollution\n      }\n    }\n    \n    // Aider backend configuration\n    if (process.env.AIDER_MODEL) {\n      this.config.backends.aider = this.config.backends.aider || {};\n      this.config.backends.aider.model = process.env.AIDER_MODEL;\n    }\n    \n    if (process.env.AIDER_TIMEOUT) {\n      this.config.backends.aider = this.config.backends.aider || {};\n      this.config.backends.aider.timeout = parseInt(process.env.AIDER_TIMEOUT, 10);\n    }\n    \n    if (process.env.AIDER_AUTO_COMMIT) {\n      this.config.backends.aider = this.config.backends.aider || {};\n      this.config.backends.aider.autoCommit = process.env.AIDER_AUTO_COMMIT === 'true';\n    }\n    \n    if (process.env.AIDER_ADDITIONAL_ARGS) {\n      this.config.backends.aider = this.config.backends.aider || {};\n      this.config.backends.aider.additionalArgs = process.env.AIDER_ADDITIONAL_ARGS\n        .split(',')\n        .map(s => s.trim())\n        .filter(Boolean);\n    }\n    \n    // Claude Code backend configuration\n    if (process.env.CLAUDE_CODE_MODEL) {\n      this.config.backends['claude-code'] = this.config.backends['claude-code'] || {};\n      this.config.backends['claude-code'].model = process.env.CLAUDE_CODE_MODEL;\n    }\n    \n    if (process.env.CLAUDE_CODE_MAX_TOKENS) {\n      this.config.backends['claude-code'] = this.config.backends['claude-code'] || {};\n      this.config.backends['claude-code'].maxTokens = parseInt(process.env.CLAUDE_CODE_MAX_TOKENS, 10);\n    }\n    \n    if (process.env.CLAUDE_CODE_TEMPERATURE) {\n      this.config.backends['claude-code'] = this.config.backends['claude-code'] || {};\n      this.config.backends['claude-code'].temperature = parseFloat(process.env.CLAUDE_CODE_TEMPERATURE);\n    }\n    \n    if (process.env.CLAUDE_CODE_MAX_TURNS) {\n      this.config.backends['claude-code'] = this.config.backends['claude-code'] || {};\n      this.config.backends['claude-code'].maxTurns = parseInt(process.env.CLAUDE_CODE_MAX_TURNS, 10);\n    }\n  }\n\n  /**\n   * Set up file watcher for configuration changes\n   * @private\n   */\n  setupWatcher() {\n    if (!this.configPath) return;\n    \n    fs.watchFile(this.configPath, { interval: 2000 }, async (curr, prev) => {\n      if (curr.mtime !== prev.mtime) {\n        console.error('Configuration file changed, reloading...');\n        await this.reloadConfig();\n      }\n    });\n  }\n\n  /**\n   * Reload configuration from file\n   * @returns {Promise<void>}\n   */\n  async reloadConfig() {\n    try {\n      const oldConfig = JSON.stringify(this.config);\n      await this.loadConfig();\n      this.applyEnvironmentOverrides();\n      \n      const newConfig = JSON.stringify(this.config);\n      if (oldConfig !== newConfig) {\n        this.notifyChangeCallbacks();\n      }\n    } catch (error) {\n      console.error('Failed to reload configuration:', error);\n    }\n  }\n\n  /**\n   * Register a callback for configuration changes\n   * @param {Function} callback - Callback function\n   */\n  onChange(callback) {\n    this.changeCallbacks.push(callback);\n  }\n\n  /**\n   * Notify all change callbacks\n   * @private\n   */\n  notifyChangeCallbacks() {\n    for (const callback of this.changeCallbacks) {\n      try {\n        callback(this.config);\n      } catch (error) {\n        console.error('Error in configuration change callback:', error);\n      }\n    }\n  }\n\n  /**\n   * Get configuration value by path\n   * @param {string} [path] - Dot-separated path (e.g., 'implement.defaultBackend')\n   * @returns {*}\n   */\n  get(path = null) {\n    if (!path) {\n      return this.config;\n    }\n    \n    const parts = path.split('.');\n    let value = this.config;\n    \n    for (const part of parts) {\n      if (value && typeof value === 'object' && part in value) {\n        value = value[part];\n      } else {\n        return undefined;\n      }\n    }\n    \n    return value;\n  }\n\n  /**\n   * Set configuration value by path\n   * @param {string} path - Dot-separated path\n   * @param {*} value - Value to set\n   */\n  set(path, value) {\n    const parts = path.split('.');\n    const lastPart = parts.pop();\n    \n    let target = this.config;\n    for (const part of parts) {\n      if (!(part in target) || typeof target[part] !== 'object') {\n        target[part] = {};\n      }\n      target = target[part];\n    }\n    \n    target[lastPart] = value;\n  }\n\n  /**\n   * Save configuration to file\n   * @param {string} [path] - Path to save to (defaults to current config path)\n   * @returns {Promise<void>}\n   */\n  async save(path = null) {\n    const savePath = path || this.configPath;\n    if (!savePath) {\n      throw new Error('No configuration file path specified');\n    }\n    \n    try {\n      const configData = JSON.stringify(this.config, null, 2);\n      await writeFile(savePath, configData, 'utf8');\n      console.error(`Configuration saved to: ${savePath}`);\n    } catch (error) {\n      throw new Error(`Failed to save configuration: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get backend-specific configuration\n   * @param {string} backendName - Backend name\n   * @returns {Object}\n   */\n  getBackendConfig(backendName) {\n    return this.config.backends?.[backendName] || {};\n  }\n\n  /**\n   * Get implementation tool configuration\n   * @returns {Object}\n   */\n  getImplementConfig() {\n    return this.config.implement || {};\n  }\n\n  /**\n   * Validate configuration\n   * @returns {Object} Validation result\n   */\n  validate() {\n    const errors = [];\n    const warnings = [];\n    \n    // Check required fields\n    if (!this.config.implement?.defaultBackend) {\n      errors.push('implement.defaultBackend is required');\n    }\n    \n    // Check backend configurations exist\n    const defaultBackend = this.config.implement?.defaultBackend;\n    if (defaultBackend && !this.config.backends?.[defaultBackend]) {\n      warnings.push(`Configuration for default backend '${defaultBackend}' not found`);\n    }\n    \n    // Check fallback backends\n    const fallbackBackends = this.config.implement?.fallbackBackends || [];\n    for (const backend of fallbackBackends) {\n      if (!this.config.backends?.[backend]) {\n        warnings.push(`Configuration for fallback backend '${backend}' not found`);\n      }\n    }\n    \n    // Validate selection strategy\n    const validStrategies = ['auto', 'preference', 'capability'];\n    const strategy = this.config.implement?.selectionStrategy;\n    if (strategy && !validStrategies.includes(strategy)) {\n      errors.push(`Invalid selection strategy: ${strategy}. Must be one of: ${validStrategies.join(', ')}`);\n    }\n    \n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Clean up resources\n   */\n  cleanup() {\n    if (this.configPath) {\n      fs.unwatchFile(this.configPath);\n    }\n    \n    this.changeCallbacks = [];\n    this.watchers.clear();\n  }\n}\n\n// Create singleton instance\nconst configManager = new ConfigManager();\n\nexport {\n  ConfigManager,\n  configManager\n};", "/**\n * Implementation tool wrapper that integrates with the backend system\n * @module ImplementTool\n */\n\nimport BackendManager from './BackendManager.js';\nimport { createBackend, listBackendNames } from '../backends/registry.js';\nimport { BackendError, ErrorTypes } from './utils.js';\nimport { configManager } from './config.js';\n\n/**\n * Implementation tool that uses pluggable backends\n * @class\n */\nclass ImplementTool {\n  /**\n   * @param {Object} config - Tool configuration\n   * @param {boolean} [config.enabled=false] - Whether the tool is enabled\n   * @param {Object} [config.backendConfig] - Backend manager configuration\n   */\n  constructor(config = {}) {\n    this.enabled = config.enabled || false;\n    this.backendManager = null;\n    this.config = config;\n    this.initialized = false;\n  }\n\n  /**\n   * Initialize the implementation tool\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    if (this.initialized) return;\n    \n    if (!this.enabled) {\n      throw new Error('Implementation tool is not enabled. Use --allow-edit flag to enable.');\n    }\n    \n    // Initialize configuration manager\n    await configManager.initialize(this.config.configPath);\n    \n    // Get configuration from manager\n    const implementConfig = configManager.getImplementConfig();\n    const backendConfigs = configManager.get('backends') || {};\n    \n    // Create backend manager with configuration\n    const backendManagerConfig = {\n      ...implementConfig,\n      backends: backendConfigs,\n      ...this.config.backendConfig\n    };\n    \n    this.backendManager = new BackendManager(backendManagerConfig);\n    \n    // Register available backends\n    await this.registerBackends();\n    \n    // Initialize backend manager\n    await this.backendManager.initialize();\n    \n    // Validate configuration\n    const configValidation = configManager.validate();\n    if (!configValidation.valid) {\n      console.error('Configuration errors:', configValidation.errors.join(', '));\n      if (configValidation.warnings.length > 0) {\n        console.warn('Configuration warnings:', configValidation.warnings.join(', '));\n      }\n    }\n    \n    const backendValidation = await this.backendManager.validateConfiguration();\n    if (!backendValidation.valid) {\n      console.warn('Backend configuration warnings:', backendValidation.errors.join(', '));\n    }\n    \n    // Listen for configuration changes\n    configManager.onChange(async (newConfig) => {\n      console.error('Configuration changed, reinitializing backends...');\n      await this.reinitialize(newConfig);\n    });\n    \n    this.initialized = true;\n  }\n\n  /**\n   * Register all available backends\n   * @private\n   */\n  async registerBackends() {\n    const backendNames = listBackendNames();\n    \n    for (const name of backendNames) {\n      try {\n        const backend = createBackend(name);\n        if (backend) {\n          await this.backendManager.registerBackend(backend);\n          console.error(`Registered backend: ${name}`);\n        }\n      } catch (error) {\n        console.warn(`Failed to register backend '${name}':`, error.message);\n      }\n    }\n  }\n\n  /**\n   * Reinitialize with new configuration\n   * @param {Object} newConfig - New configuration\n   * @private\n   */\n  async reinitialize(newConfig) {\n    try {\n      // Clean up existing backend manager\n      if (this.backendManager) {\n        await this.backendManager.cleanup();\n      }\n      \n      // Create new backend manager with updated configuration\n      const implementConfig = newConfig.implement || {};\n      const backendConfigs = newConfig.backends || {};\n      \n      const backendManagerConfig = {\n        ...implementConfig,\n        backends: backendConfigs,\n        ...this.config.backendConfig\n      };\n      \n      this.backendManager = new BackendManager(backendManagerConfig);\n      \n      // Re-register backends\n      await this.registerBackends();\n      \n      // Re-initialize\n      await this.backendManager.initialize();\n      \n      console.error('Backend reinitialization completed');\n    } catch (error) {\n      console.error('Failed to reinitialize backends:', error);\n    }\n  }\n\n  /**\n   * Get tool definition for AI models\n   * @returns {Object}\n   */\n  getToolDefinition() {\n    return {\n      name: 'implement',\n      description: 'Implement a feature or fix a bug using AI-powered code generation. Only available when --allow-edit is enabled.',\n      parameters: {\n        type: 'object',\n        properties: {\n          task: {\n            type: 'string',\n            description: 'The task description for implementation'\n          },\n          backend: {\n            type: 'string',\n            description: 'Optional: Specific backend to use (aider, claude-code)',\n            enum: listBackendNames()\n          },\n          autoCommit: {\n            type: 'boolean',\n            description: 'Whether to auto-commit changes (default: false)'\n          },\n          generateTests: {\n            type: 'boolean',\n            description: 'Whether to generate tests for the implementation'\n          },\n          dryRun: {\n            type: 'boolean',\n            description: 'Perform a dry run without making actual changes'\n          }\n        },\n        required: ['task']\n      }\n    };\n  }\n\n  /**\n   * Execute implementation task\n   * @param {Object} params - Execution parameters\n   * @param {string} params.task - Task description\n   * @param {string} [params.backend] - Specific backend to use\n   * @param {boolean} [params.autoCommit] - Auto-commit changes\n   * @param {boolean} [params.generateTests] - Generate tests\n   * @param {boolean} [params.dryRun] - Dry run mode\n   * @param {string} [params.sessionId] - Session ID\n   * @returns {Promise<Object>}\n   */\n  async execute(params) {\n    if (!this.enabled) {\n      throw new Error('Implementation tool is not enabled. Use --allow-edit flag to enable.');\n    }\n    \n    // Ensure initialized\n    if (!this.initialized) {\n      await this.initialize();\n    }\n    \n    const { task, backend, autoCommit, generateTests, dryRun, sessionId, ...rest } = params;\n    \n    // Build implementation request\n    const request = {\n      sessionId: sessionId || `implement-${Date.now()}`,\n      task,\n      context: {\n        workingDirectory: process.cwd(),\n        ...rest.context\n      },\n      options: {\n        backend,\n        autoCommit: autoCommit || false,\n        generateTests: generateTests || false,\n        dryRun: dryRun || false,\n        ...rest.options\n      },\n      callbacks: {\n        onProgress: (update) => {\n          // Log progress to stderr for visibility\n          if (update.message) {\n            const prefix = update.type === 'stderr' ? '[STDERR]' : '[INFO]';\n            console.error(`${prefix} ${update.message}`);\n          }\n        },\n        onError: (error) => {\n          console.error('[ERROR]', error.message);\n        }\n      }\n    };\n    \n    try {\n      console.error(`Executing implementation task: ${task.substring(0, 100)}${task.length > 100 ? '...' : ''}`);\n      console.error(`Using backend selection strategy: ${this.backendManager.config.selectionStrategy}`);\n      \n      if (backend) {\n        console.error(`Requested backend: ${backend}`);\n      }\n      \n      // Execute implementation\n      const result = await this.backendManager.executeImplementation(request);\n      \n      console.error(`Implementation completed using backend: ${result.backend}`);\n      \n      if (result.fallback) {\n        console.error('Note: Used fallback backend due to primary backend failure');\n      }\n      \n      // Format result for compatibility with existing code\n      return {\n        success: result.success,\n        output: result.output,\n        error: result.error?.message || null,\n        command: `[${result.backend}] ${task}`,\n        timestamp: new Date().toISOString(),\n        prompt: task,\n        backend: result.backend,\n        metrics: result.metrics,\n        changes: result.changes\n      };\n      \n    } catch (error) {\n      console.error(`Implementation failed:`, error.message);\n      \n      // Format error response\n      return {\n        success: false,\n        output: null,\n        error: error.message,\n        command: `[failed] ${task}`,\n        timestamp: new Date().toISOString(),\n        prompt: task,\n        backend: null,\n        errorDetails: error instanceof BackendError ? error.toJSON() : { message: error.message }\n      };\n    }\n  }\n\n  /**\n   * Cancel an implementation session\n   * @param {string} sessionId - Session ID to cancel\n   * @returns {Promise<void>}\n   */\n  async cancel(sessionId) {\n    if (!this.backendManager) {\n      throw new Error('Implementation tool not initialized');\n    }\n    \n    await this.backendManager.cancelImplementation(sessionId);\n  }\n\n  /**\n   * Get backend information\n   * @returns {Promise<Object>}\n   */\n  async getBackendInfo() {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n    \n    const health = await this.backendManager.checkBackendHealth();\n    const availableBackends = this.backendManager.getAvailableBackends();\n    \n    return {\n      enabled: this.enabled,\n      defaultBackend: this.backendManager.config.defaultBackend,\n      fallbackBackends: this.backendManager.config.fallbackBackends,\n      availableBackends,\n      health\n    };\n  }\n\n  /**\n   * Clean up resources\n   * @returns {Promise<void>}\n   */\n  async cleanup() {\n    if (this.backendManager) {\n      await this.backendManager.cleanup();\n    }\n    \n    // Clean up configuration manager\n    configManager.cleanup();\n    \n    this.initialized = false;\n  }\n}\n\n/**\n * Create a singleton instance of the implementation tool\n * This maintains compatibility with the existing code structure\n */\nfunction createImplementTool(config = {}) {\n  const tool = new ImplementTool(config);\n  \n  // Return a tool object compatible with the existing interface\n  return {\n    ...tool.getToolDefinition(),\n    execute: async (params) => {\n      return await tool.execute(params);\n    },\n    cancel: async (sessionId) => {\n      return await tool.cancel(sessionId);\n    },\n    getInfo: async () => {\n      return await tool.getBackendInfo();\n    },\n    cleanup: async () => {\n      return await tool.cleanup();\n    },\n    // Expose the tool instance for advanced usage\n    instance: tool\n  };\n}\n\nexport { ImplementTool, createImplementTool };", "// Import tool generators from @buger/probe package\nimport { searchTool, queryTool, extractTool, DEFAULT_SYSTEM_MESSAGE, listFilesByLevel } from '@buger/probe';\nimport { exec, spawn } from 'child_process';\nimport { promisify } from 'util';\nimport { randomUUID } from 'crypto';\nimport { EventEmitter } from 'events';\nimport fs from 'fs';\nimport { promises as fsPromises } from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { glob } from 'glob';\n\n// Import the new pluggable implementation tool\nimport { createImplementTool } from './implement/core/ImplementTool.js';\n\n// Create an event emitter for tool calls\nexport const toolCallEmitter = new EventEmitter();\n\n// Map to track active tool executions by session ID\nconst activeToolExecutions = new Map();\n\n// Function to check if a session has been cancelled\nexport function isSessionCancelled(sessionId) {\n\treturn activeToolExecutions.get(sessionId)?.cancelled || false;\n}\n\n// Function to cancel all tool executions for a session\nexport function cancelToolExecutions(sessionId) {\n\t// Only log if not in non-interactive mode or if in debug mode\n\tif (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n\t\tconsole.log(`Cancelling tool executions for session: ${sessionId}`);\n\t}\n\tconst sessionData = activeToolExecutions.get(sessionId);\n\tif (sessionData) {\n\t\tsessionData.cancelled = true;\n\t\t// Only log if not in non-interactive mode or if in debug mode\n\t\tif (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n\t\t\tconsole.log(`Session ${sessionId} marked as cancelled`);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n// Function to register a new tool execution\nfunction registerToolExecution(sessionId) {\n\tif (!sessionId) return;\n\n\tif (!activeToolExecutions.has(sessionId)) {\n\t\tactiveToolExecutions.set(sessionId, { cancelled: false });\n\t} else {\n\t\t// Reset cancelled flag if session already exists for a new execution\n\t\tactiveToolExecutions.get(sessionId).cancelled = false;\n\t}\n}\n\n// Function to clear tool execution data for a session\nexport function clearToolExecutionData(sessionId) {\n\tif (!sessionId) return;\n\n\tif (activeToolExecutions.has(sessionId)) {\n\t\tactiveToolExecutions.delete(sessionId);\n\t\t// Only log if not in non-interactive mode or if in debug mode\n\t\tif (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n\t\t\tconsole.log(`Cleared tool execution data for session: ${sessionId}`);\n\t\t}\n\t}\n}\n\n// Generate a default session ID (less relevant now, session is managed per-chat)\nconst defaultSessionId = randomUUID();\n// Only log session ID in debug mode\nif (process.env.DEBUG_CHAT === '1') {\n\tconsole.log(`Generated default session ID (probeTool.js): ${defaultSessionId}`);\n}\n\n// Create configured tools with the session ID\n// Note: These configOptions are less critical now as sessionId is passed explicitly\nconst configOptions = {\n\tsessionId: defaultSessionId,\n\tdebug: process.env.DEBUG_CHAT === '1'\n};\n\n// Create the base tools using the imported generators\nconst baseSearchTool = searchTool(configOptions);\nconst baseQueryTool = queryTool(configOptions);\nconst baseExtractTool = extractTool(configOptions);\n\n\n// Wrap the tools to emit events and handle cancellation\nconst wrapToolWithEmitter = (tool, toolName, baseExecute) => {\n\treturn {\n\t\t...tool, // Spread schema, description etc.\n\t\texecute: async (params) => { // The execute function now receives parsed params\n\t\t\tconst debug = process.env.DEBUG_CHAT === '1';\n\t\t\t// Get the session ID from params (passed down from probeChat.js)\n\t\t\tconst toolSessionId = params.sessionId || defaultSessionId; // Fallback, but should always have sessionId\n\n\t\t\tif (debug) {\n\t\t\t\tconsole.log(`[DEBUG] probeTool: Executing ${toolName} for session ${toolSessionId}`);\n\t\t\t\tconsole.log(`[DEBUG] probeTool: Received params:`, params);\n\t\t\t}\n\n\t\t\t// Register this tool execution (and reset cancel flag if needed)\n\t\t\tregisterToolExecution(toolSessionId);\n\n\t\t\t// Check if this session has been cancelled *before* execution\n\t\t\tif (isSessionCancelled(toolSessionId)) {\n\t\t\t\t// Only log if not in non-interactive mode or if in debug mode\n\t\t\t\tconsole.error(`Tool execution cancelled BEFORE starting for session ${toolSessionId}`);\n\t\t\t\tthrow new Error(`Tool execution cancelled for session ${toolSessionId}`);\n\t\t\t}\n\t\t\t// Only log if not in non-interactive mode or if in debug mode\n\t\t\tconsole.error(`Executing ${toolName} for session ${toolSessionId}`); // Simplified log\n\n\t\t\t// Remove sessionId from params before passing to base tool if it expects only schema params\n\t\t\tconst { sessionId, ...toolParams } = params;\n\n\t\t\ttry {\n\t\t\t\t// Emit a tool call start event\n\t\t\t\tconst toolCallStartData = {\n\t\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\t\tname: toolName,\n\t\t\t\t\targs: toolParams, // Log schema params\n\t\t\t\t\tstatus: 'started'\n\t\t\t\t};\n\t\t\t\tif (debug) {\n\t\t\t\t\tconsole.log(`[DEBUG] probeTool: Emitting toolCallStart:${toolSessionId}`);\n\t\t\t\t}\n\t\t\t\ttoolCallEmitter.emit(`toolCall:${toolSessionId}`, toolCallStartData);\n\n\t\t\t\t// Execute the original tool's execute function with schema params\n\t\t\t\t// Use a promise-based approach with cancellation check\n\t\t\t\tlet result = null;\n\t\t\t\tlet executionError = null;\n\n\t\t\t\tconst executionPromise = baseExecute(toolParams).catch(err => {\n\t\t\t\t\texecutionError = err; // Capture error\n\t\t\t\t});\n\n\t\t\t\tconst checkInterval = 50; // Check every 50ms\n\t\t\t\twhile (result === null && executionError === null) {\n\t\t\t\t\tif (isSessionCancelled(toolSessionId)) {\n\t\t\t\t\t\tconsole.error(`Tool execution cancelled DURING execution for session ${toolSessionId}`);\n\t\t\t\t\t\t// Attempt to signal cancellation if the underlying tool supports it (future enhancement)\n\t\t\t\t\t\t// For now, just throw the cancellation error\n\t\t\t\t\t\tthrow new Error(`Tool execution cancelled for session ${toolSessionId}`);\n\t\t\t\t\t}\n\t\t\t\t\t// Check if promise is resolved or rejected\n\t\t\t\t\tconst status = await Promise.race([\n\t\t\t\t\t\texecutionPromise.then(() => 'resolved').catch(() => 'rejected'),\n\t\t\t\t\t\tnew Promise(resolve => setTimeout(() => resolve('pending'), checkInterval))\n\t\t\t\t\t]);\n\n\t\t\t\t\tif (status === 'resolved') {\n\t\t\t\t\t\tresult = await executionPromise; // Get the result\n\t\t\t\t\t} else if (status === 'rejected') {\n\t\t\t\t\t\t// Error already captured by the catch block on executionPromise\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// If 'pending', continue loop\n\t\t\t\t}\n\n\t\t\t\t// If loop exited due to error\n\t\t\t\tif (executionError) {\n\t\t\t\t\tthrow executionError;\n\t\t\t\t}\n\n\t\t\t\t// If loop exited due to cancellation within the loop\n\t\t\t\tif (isSessionCancelled(toolSessionId)) {\n\t\t\t\t\t// Only log if not in non-interactive mode or if in debug mode\n\t\t\t\t\tif (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n\t\t\t\t\t\tconsole.log(`Tool execution finished but session was cancelled for ${toolSessionId}`);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(`Tool execution cancelled for session ${toolSessionId}`);\n\t\t\t\t}\n\n\n\t\t\t\t// Emit the tool call completion event\n\t\t\t\tconst toolCallData = {\n\t\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\t\tname: toolName,\n\t\t\t\t\targs: toolParams,\n\t\t\t\t\t// Safely preview result\n\t\t\t\t\tresultPreview: typeof result === 'string'\n\t\t\t\t\t\t? (result.length > 200 ? result.substring(0, 200) + '...' : result)\n\t\t\t\t\t\t: (result ? JSON.stringify(result).substring(0, 200) + '...' : 'No Result'),\n\t\t\t\t\tstatus: 'completed'\n\t\t\t\t};\n\t\t\t\tif (debug) {\n\t\t\t\t\tconsole.log(`[DEBUG] probeTool: Emitting toolCall:${toolSessionId} (completed)`);\n\t\t\t\t}\n\t\t\t\ttoolCallEmitter.emit(`toolCall:${toolSessionId}`, toolCallData);\n\n\t\t\t\treturn result;\n\t\t\t} catch (error) {\n\t\t\t\t// If it's a cancellation error, re-throw it directly\n\t\t\t\tif (error.message.includes('cancelled for session')) {\n\t\t\t\t\t// Only log if not in non-interactive mode or if in debug mode\n\t\t\t\t\tif (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n\t\t\t\t\t\tconsole.log(`Caught cancellation error for ${toolName} in session ${toolSessionId}`);\n\t\t\t\t\t}\n\t\t\t\t\t// Emit cancellation event? Or let the caller handle it? Let caller handle.\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\t// Handle other execution errors\n\t\t\t\tif (debug) {\n\t\t\t\t\tconsole.error(`[DEBUG] probeTool: Error executing ${toolName}:`, error);\n\t\t\t\t}\n\n\t\t\t\t// Emit a tool call error event\n\t\t\t\tconst toolCallErrorData = {\n\t\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\t\tname: toolName,\n\t\t\t\t\targs: toolParams,\n\t\t\t\t\terror: error.message || 'Unknown error',\n\t\t\t\t\tstatus: 'error'\n\t\t\t\t};\n\t\t\t\tif (debug) {\n\t\t\t\t\tconsole.log(`[DEBUG] probeTool: Emitting toolCall:${toolSessionId} (error)`);\n\t\t\t\t}\n\t\t\t\ttoolCallEmitter.emit(`toolCall:${toolSessionId}`, toolCallErrorData);\n\n\t\t\t\tthrow error; // Re-throw the error to be caught by probeChat.js loop\n\t\t\t}\n\t\t}\n\t};\n};\n\n// Create the implement tool using the new pluggable system\nconst implementToolConfig = {\n\tenabled: process.env.ALLOW_EDIT === '1' || process.argv.includes('--allow-edit'),\n\tbackendConfig: {\n\t\t// Configuration can be extended here\n\t}\n};\n\nconst pluggableImplementTool = createImplementTool(implementToolConfig);\n\n// Create a compatibility wrapper for the old interface\nconst baseImplementTool = {\n\tname: \"implement\",\n\tdescription: pluggableImplementTool.description,\n\tparameters: pluggableImplementTool.parameters,\n\texecute: async ({ task, autoCommits = false, prompt, sessionId }) => {\n\t\tconst debug = process.env.DEBUG_CHAT === '1';\n\t\t\n\t\tif (debug) {\n\t\t\tconsole.log(`[DEBUG] Executing implementation with task: ${task}`);\n\t\t\tconsole.log(`[DEBUG] Auto-commits: ${autoCommits}`);\n\t\t\tconsole.log(`[DEBUG] Session ID: ${sessionId}`);\n\t\t\tif (prompt) console.log(`[DEBUG] Custom prompt: ${prompt}`);\n\t\t}\n\n\t\t// Check if the tool is enabled\n\t\tif (!implementToolConfig.enabled) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\toutput: null,\n\t\t\t\terror: 'Implementation tool is not enabled. Use --allow-edit flag to enable.',\n\t\t\t\tcommand: null,\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\tprompt: prompt || task\n\t\t\t};\n\t\t}\n\n\t\ttry {\n\t\t\t// Use the new pluggable implementation tool\n\t\t\tconst result = await pluggableImplementTool.execute({\n\t\t\t\ttask: prompt || task, // Use prompt if provided, otherwise use task\n\t\t\t\tautoCommit: autoCommits,\n\t\t\t\tsessionId: sessionId,\n\t\t\t\t// Pass through any additional options that might be useful\n\t\t\t\tcontext: {\n\t\t\t\t\tworkingDirectory: process.cwd()\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// The result is already in the expected format\n\t\t\treturn result;\n\n\t\t} catch (error) {\n\t\t\t// Handle any unexpected errors\n\t\t\tconsole.error(`Error in implement tool:`, error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\toutput: null,\n\t\t\t\terror: error.message || 'Unknown error in implementation tool',\n\t\t\t\tcommand: null,\n\t\t\t\ttimestamp: new Date().toISOString(),\n\t\t\t\tprompt: prompt || task\n\t\t\t};\n\t\t}\n\t}\n};\n\n// Create the listFiles tool\nconst baseListFilesTool = {\n\tname: \"listFiles\",\n\tdescription: 'List files in a specified directory',\n\tparameters: {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tdirectory: {\n\t\t\t\ttype: 'string',\n\t\t\t\tdescription: 'The directory path to list files from. Defaults to current directory if not specified.'\n\t\t\t}\n\t\t},\n\t\trequired: []\n\t},\n\texecute: async ({ directory = '.', sessionId }) => {\n\t\tconst debug = process.env.DEBUG_CHAT === '1';\n\t\tconst currentWorkingDir = process.cwd();\n\t\t\n\t\t// Get allowed folders from environment variable\n\t\tconst allowedFoldersEnv = process.env.ALLOWED_FOLDERS;\n\t\tlet allowedFolders = [];\n\t\t\n\t\tif (allowedFoldersEnv) {\n\t\t\tallowedFolders = allowedFoldersEnv.split(',').map(folder => folder.trim()).filter(folder => folder.length > 0);\n\t\t}\n\n\t\t// Handle default directory behavior when ALLOWED_FOLDERS is set\n\t\tlet targetDirectory = directory;\n\t\tif (allowedFolders.length > 0 && (directory === '.' || directory === './')) {\n\t\t\t// Use the first allowed folder if directory is current directory\n\t\t\ttargetDirectory = allowedFolders[0];\n\t\t\tif (debug) {\n\t\t\t\tconsole.log(`[DEBUG] Redirecting from '${directory}' to first allowed folder: ${targetDirectory}`);\n\t\t\t}\n\t\t}\n\n\t\tconst targetDir = path.resolve(currentWorkingDir, targetDirectory);\n\n\t\t// Validate that the target directory is within allowed folders\n\t\tif (allowedFolders.length > 0) {\n\t\t\tconst isAllowed = allowedFolders.some(allowedFolder => {\n\t\t\t\tconst resolvedAllowedFolder = path.resolve(currentWorkingDir, allowedFolder);\n\t\t\t\treturn targetDir === resolvedAllowedFolder || targetDir.startsWith(resolvedAllowedFolder + path.sep);\n\t\t\t});\n\n\t\t\tif (!isAllowed) {\n\t\t\t\tconst error = `Access denied: Directory '${targetDirectory}' is not within allowed folders: ${allowedFolders.join(', ')}`;\n\t\t\t\tif (debug) {\n\t\t\t\t\tconsole.log(`[DEBUG] ${error}`);\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tdirectory: targetDir,\n\t\t\t\t\terror: error,\n\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif (debug) {\n\t\t\tconsole.log(`[DEBUG] Listing files in directory: ${targetDir}`);\n\t\t}\n\n\t\ttry {\n\t\t\t// Read the directory contents\n\t\t\tconst files = await fs.promises.readdir(targetDir, { withFileTypes: true });\n\n\t\t\t// Format the results\n\t\t\tconst result = files.map(file => {\n\t\t\t\tconst isDirectory = file.isDirectory();\n\t\t\t\treturn {\n\t\t\t\t\tname: file.name,\n\t\t\t\t\ttype: isDirectory ? 'directory' : 'file',\n\t\t\t\t\tpath: path.join(targetDirectory, file.name)\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tif (debug) {\n\t\t\t\tconsole.log(`[DEBUG] Found ${result.length} files/directories in ${targetDir}`);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdirectory: targetDir,\n\t\t\t\tfiles: result,\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error listing files in ${targetDir}:`, error);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tdirectory: targetDir,\n\t\t\t\terror: error.message || 'Unknown error listing files',\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t};\n\t\t}\n\t}\n};\n\n// Create the searchFiles tool\nconst baseSearchFilesTool = {\n\tname: \"searchFiles\",\n\tdescription: 'Search for files using a glob pattern, recursively by default',\n\tparameters: {\n\t\ttype: 'object',\n\t\tproperties: {\n\t\t\tpattern: {\n\t\t\t\ttype: 'string',\n\t\t\t\tdescription: 'The glob pattern to search for (e.g., \"**/*.js\", \"*.md\")'\n\t\t\t},\n\t\t\tdirectory: {\n\t\t\t\ttype: 'string',\n\t\t\t\tdescription: 'The directory to search in. Defaults to current directory if not specified.'\n\t\t\t},\n\t\t\trecursive: {\n\t\t\t\ttype: 'boolean',\n\t\t\t\tdescription: 'Whether to search recursively. Defaults to true.'\n\t\t\t}\n\t\t},\n\t\trequired: ['pattern']\n\t},\n\texecute: async ({ pattern, directory, recursive = true, sessionId }) => {\n\t\t// Ensure directory defaults to current directory\n\t\tdirectory = directory || '.';\n\n\t\tconst debug = process.env.DEBUG_CHAT === '1';\n\t\tconst currentWorkingDir = process.cwd();\n\t\t\n\t\t// Get allowed folders from environment variable\n\t\tconst allowedFoldersEnv = process.env.ALLOWED_FOLDERS;\n\t\tlet allowedFolders = [];\n\t\t\n\t\tif (allowedFoldersEnv) {\n\t\t\tallowedFolders = allowedFoldersEnv.split(',').map(folder => folder.trim()).filter(folder => folder.length > 0);\n\t\t}\n\n\t\t// Handle default directory behavior when ALLOWED_FOLDERS is set\n\t\tlet targetDirectory = directory;\n\t\tif (allowedFolders.length > 0 && (directory === '.' || directory === './')) {\n\t\t\t// Use the first allowed folder if directory is current directory\n\t\t\ttargetDirectory = allowedFolders[0];\n\t\t\tif (debug) {\n\t\t\t\tconsole.log(`[DEBUG] Redirecting from '${directory}' to first allowed folder: ${targetDirectory}`);\n\t\t\t}\n\t\t}\n\n\t\tconst targetDir = path.resolve(currentWorkingDir, targetDirectory);\n\n\t\t// Validate that the target directory is within allowed folders\n\t\tif (allowedFolders.length > 0) {\n\t\t\tconst isAllowed = allowedFolders.some(allowedFolder => {\n\t\t\t\tconst resolvedAllowedFolder = path.resolve(currentWorkingDir, allowedFolder);\n\t\t\t\treturn targetDir === resolvedAllowedFolder || targetDir.startsWith(resolvedAllowedFolder + path.sep);\n\t\t\t});\n\n\t\t\tif (!isAllowed) {\n\t\t\t\tconst error = `Access denied: Directory '${targetDirectory}' is not within allowed folders: ${allowedFolders.join(', ')}`;\n\t\t\t\tif (debug) {\n\t\t\t\t\tconsole.log(`[DEBUG] ${error}`);\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tdirectory: targetDir,\n\t\t\t\t\tpattern: pattern,\n\t\t\t\t\terror: error,\n\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Log execution parameters to stderr for visibility\n\t\tconsole.error(`Executing searchFiles with params: pattern=\"${pattern}\", directory=\"${targetDirectory}\", recursive=${recursive}`);\n\t\tconsole.error(`Resolved target directory: ${targetDir}`);\n\t\tconsole.error(`Current working directory: ${currentWorkingDir}`);\n\n\t\tif (debug) {\n\t\t\tconsole.log(`[DEBUG] Searching for files with pattern: ${pattern}`);\n\t\t\tconsole.log(`[DEBUG] In directory: ${targetDir}`);\n\t\t\tconsole.log(`[DEBUG] Recursive: ${recursive}`);\n\t\t}\n\n\t\t// Validate pattern to prevent overly complex patterns\n\t\tif (pattern.includes('**/**') || pattern.split('*').length > 10) {\n\t\t\tconsole.error(`Pattern too complex: ${pattern}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tdirectory: targetDir,\n\t\t\t\tpattern: pattern,\n\t\t\t\terror: 'Pattern too complex. Please use a simpler glob pattern.',\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t};\n\t\t}\n\n\t\ttry {\n\t\t\t// Set glob options with timeout and limits\n\t\t\tconst options = {\n\t\t\t\tcwd: targetDir,\n\t\t\t\tdot: true, // Include dotfiles\n\t\t\t\tnodir: true, // Only return files, not directories\n\t\t\t\tabsolute: false, // Return paths relative to the search directory\n\t\t\t\ttimeout: 10000, // 10 second timeout\n\t\t\t\tmaxDepth: recursive ? 10 : 1, // Limit recursion depth\n\t\t\t};\n\n\t\t\t// If not recursive, modify the pattern to only search the top level\n\t\t\tconst searchPattern = recursive ? pattern : pattern.replace(/^\\*\\*\\//, '');\n\n\t\t\tconsole.error(`Starting glob search with pattern: ${searchPattern} in ${targetDir}`);\n\t\t\tconsole.error(`Glob options: ${JSON.stringify(options)}`);\n\n\t\t\t// Use a safer approach with manual file searching if the pattern is simple enough\n\t\t\tlet files = [];\n\n\t\t\t// For simple patterns like \"*.js\" or \"bin/*.js\", use a more direct approach\n\t\t\tif (pattern.includes('*') && !pattern.includes('**') && pattern.split('/').length <= 2) {\n\t\t\t\tconsole.error(`Using direct file search for simple pattern: ${pattern}`);\n\n\t\t\t\ttry {\n\t\t\t\t\t// Handle patterns like \"dir/*.ext\" or \"*.ext\"\n\t\t\t\t\tconst parts = pattern.split('/');\n\t\t\t\t\tlet searchDir = targetDir;\n\t\t\t\t\tlet filePattern;\n\n\t\t\t\t\tif (parts.length === 2) {\n\t\t\t\t\t\t// Pattern like \"dir/*.ext\"\n\t\t\t\t\t\tsearchDir = path.join(targetDir, parts[0]);\n\t\t\t\t\t\tfilePattern = parts[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Pattern like \"*.ext\"\n\t\t\t\t\t\tfilePattern = parts[0];\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.error(`Searching in directory: ${searchDir} for files matching: ${filePattern}`);\n\n\t\t\t\t\t// Check if directory exists\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait fsPromises.access(searchDir);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconsole.error(`Directory does not exist: ${searchDir}`);\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\t\tdirectory: targetDir,\n\t\t\t\t\t\t\tpattern: pattern,\n\t\t\t\t\t\t\trecursive: recursive,\n\t\t\t\t\t\t\tfiles: [],\n\t\t\t\t\t\t\tcount: 0,\n\t\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Read directory contents\n\t\t\t\t\tconst dirEntries = await fsPromises.readdir(searchDir, { withFileTypes: true });\n\n\t\t\t\t\t// Convert glob pattern to regex\n\t\t\t\t\tconst regexPattern = filePattern\n\t\t\t\t\t\t.replace(/\\./g, '\\\\.')\n\t\t\t\t\t\t.replace(/\\*/g, '.*');\n\t\t\t\t\tconst regex = new RegExp(`^${regexPattern}$`);\n\n\t\t\t\t\t// Filter files based on pattern\n\t\t\t\t\tfiles = dirEntries\n\t\t\t\t\t\t.filter(entry => entry.isFile() && regex.test(entry.name))\n\t\t\t\t\t\t.map(entry => {\n\t\t\t\t\t\t\tconst relativePath = parts.length === 2\n\t\t\t\t\t\t\t\t? path.join(parts[0], entry.name)\n\t\t\t\t\t\t\t\t: entry.name;\n\t\t\t\t\t\t\treturn relativePath;\n\t\t\t\t\t\t});\n\n\t\t\t\t\tconsole.error(`Direct search found ${files.length} files matching ${filePattern}`);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tconsole.error(`Error in direct file search: ${err.message}`);\n\t\t\t\t\t// Fall back to glob if direct search fails\n\t\t\t\t\tconsole.error(`Falling back to glob search`);\n\n\t\t\t\t\t// Create a promise that rejects after a timeout\n\t\t\t\t\tconst timeoutPromise = new Promise((_, reject) => {\n\t\t\t\t\t\tsetTimeout(() => reject(new Error('Search operation timed out after 10 seconds')), 10000);\n\t\t\t\t\t});\n\n\t\t\t\t\t// Use glob without promisify since it might already return a Promise\n\t\t\t\t\tfiles = await Promise.race([\n\t\t\t\t\t\tglob(searchPattern, options),\n\t\t\t\t\t\ttimeoutPromise\n\t\t\t\t\t]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error(`Using glob for complex pattern: ${pattern}`);\n\n\t\t\t\t// Create a promise that rejects after a timeout\n\t\t\t\tconst timeoutPromise = new Promise((_, reject) => {\n\t\t\t\t\tsetTimeout(() => reject(new Error('Search operation timed out after 10 seconds')), 10000);\n\t\t\t\t});\n\n\t\t\t\t// Use glob without promisify since it might already return a Promise\n\t\t\t\tfiles = await Promise.race([\n\t\t\t\t\tglob(searchPattern, options),\n\t\t\t\t\ttimeoutPromise\n\t\t\t\t]);\n\t\t\t}\n\n\t\t\tconsole.error(`Search completed, found ${files.length} files in ${targetDir}`);\n\t\t\tconsole.error(`Pattern: ${pattern}, Recursive: ${recursive}`);\n\n\t\t\tif (debug) {\n\t\t\t\tconsole.log(`[DEBUG] Found ${files.length} files matching pattern ${pattern}`);\n\t\t\t}\n\n\t\t\t// Limit the number of results to prevent memory issues\n\t\t\tconst maxResults = 1000;\n\t\t\tconst limitedFiles = files.length > maxResults ? files.slice(0, maxResults) : files;\n\n\t\t\tif (files.length > maxResults) {\n\t\t\t\tconsole.warn(`Warning: Limited results to ${maxResults} files out of ${files.length} total matches`);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdirectory: targetDir,\n\t\t\t\tpattern: pattern,\n\t\t\t\trecursive: recursive,\n\t\t\t\tfiles: limitedFiles.map(file => path.join(targetDirectory, file)),\n\t\t\t\tcount: limitedFiles.length,\n\t\t\t\ttotalMatches: files.length,\n\t\t\t\tlimited: files.length > maxResults,\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error searching files with pattern \"${pattern}\" in ${targetDir}:`, error);\n\t\t\tconsole.error(`Search parameters: directory=\"${targetDirectory}\", recursive=${recursive}, sessionId=${sessionId}`);\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tdirectory: targetDir,\n\t\t\t\tpattern: pattern,\n\t\t\t\terror: error.message || 'Unknown error searching files',\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t};\n\t\t}\n\t}\n};\n\n// Export the wrapped tool instances\nexport const searchToolInstance = wrapToolWithEmitter(baseSearchTool, 'search', baseSearchTool.execute);\nexport const queryToolInstance = wrapToolWithEmitter(baseQueryTool, 'query', baseQueryTool.execute);\nexport const extractToolInstance = wrapToolWithEmitter(baseExtractTool, 'extract', baseExtractTool.execute);\nexport const implementToolInstance = wrapToolWithEmitter(baseImplementTool, 'implement', baseImplementTool.execute);\nexport const listFilesToolInstance = wrapToolWithEmitter(baseListFilesTool, 'listFiles', baseListFilesTool.execute);\nexport const searchFilesToolInstance = wrapToolWithEmitter(baseSearchFilesTool, 'searchFiles', baseSearchFilesTool.execute);\n\n// --- Backward Compatibility Layer (probeTool mapping to searchToolInstance) ---\n// This might be less relevant if the AI is strictly using the new XML format,\n// but keep it for potential direct API calls or older UI elements.\nexport const probeTool = {\n\t...searchToolInstance, // Inherit schema description etc. from the wrapped search tool\n\tname: \"search\", // Explicitly set name\n\tdescription: 'DEPRECATED: Use <search> tool instead. Search code using keywords.',\n\t// parameters: searchSchema, // Use the imported schema\n\texecute: async (params) => { // Expects { keywords, folder, ..., sessionId }\n\t\tconst debug = process.env.DEBUG_CHAT === '1';\n\t\tif (debug) {\n\t\t\tconsole.log(`[DEBUG] probeTool (Compatibility Layer) executing for session ${params.sessionId}`);\n\t\t}\n\n\t\t// Map old params ('keywords', 'folder') to new ones ('query', 'path')\n\t\tconst { keywords, folder, sessionId, ...rest } = params;\n\t\tconst mappedParams = {\n\t\t\tquery: keywords,\n\t\t\tpath: folder || '.', // Default path if folder is missing\n\t\t\tsessionId: sessionId, // Pass session ID through\n\t\t\t...rest // Pass other params like allow_tests, maxResults etc.\n\t\t};\n\n\t\tif (debug) {\n\t\t\tconsole.log(\"[DEBUG] probeTool mapped params: \", mappedParams);\n\t\t}\n\n\t\t// Call the *wrapped* searchToolInstance execute function\n\t\t// It will handle cancellation checks and event emitting internally\n\t\ttry {\n\t\t\t// Note: The name emitted by searchToolInstance will be 'search', not 'probeTool' or 'searchCode'\n\t\t\tconst result = await searchToolInstance.execute(mappedParams);\n\n\t\t\t// Format the result for backward compatibility if needed by caller\n\t\t\t// The raw result from searchToolInstance is likely just the search results array/string\n\t\t\tconst formattedResult = {\n\t\t\t\tresults: result, // Assuming result is the direct data\n\t\t\t\tcommand: `probe search --query \"${keywords}\" --path \"${folder || '.'}\"`, // Reconstruct approx command\n\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t};\n\t\t\tif (debug) {\n\t\t\t\tconsole.log(\"[DEBUG] probeTool compatibility layer returning formatted result.\");\n\t\t\t}\n\t\t\treturn formattedResult;\n\n\t\t} catch (error) {\n\t\t\tif (debug) {\n\t\t\t\tconsole.error(`[DEBUG] Error in probeTool compatibility layer:`, error);\n\t\t\t}\n\t\t\t// Error is already emitted by the wrapped searchToolInstance, just re-throw\n\t\t\tthrow error;\n\t\t}\n\t}\n};\n// Export necessary items\nexport { DEFAULT_SYSTEM_MESSAGE, listFilesByLevel };\n// Export the tool generator functions if needed elsewhere\nexport { searchTool, queryTool, extractTool };\n\n// Export capabilities information for the new tools\nexport const toolCapabilities = {\n\tsearch: \"Search code using keywords and patterns\",\n\tquery: \"Query code with structured parameters for more precise results\",\n\textract: \"Extract code blocks and context from files\",\n\timplement: \"Implement features or fix bugs using aider (requires --allow-edit)\",\n\tlistFiles: \"List files and directories in a specified location\",\n\tsearchFiles: \"Find files matching a glob pattern with recursive search capability\"\n};\n", "import 'dotenv/config';\nimport { createAnthropic } from '@ai-sdk/anthropic';\nimport { createOpenAI } from '@ai-sdk/openai';\nimport { createGoogleGenerativeAI } from '@ai-sdk/google';\nimport { streamText } from 'ai'; // Removed 'tool' import as it's not used directly here\nimport { randomUUID } from 'crypto';\nimport { TokenCounter } from './tokenCounter.js';\nimport { TokenUsageDisplay } from './tokenUsageDisplay.js';\nimport { writeFileSync, existsSync } from 'fs';\nimport { join } from 'path';\nimport { TelemetryConfig } from './telemetry.js';\nimport { trace } from '@opentelemetry/api';\nimport { appTracer } from './appTracer.js';\n// Import the tools that emit events and the listFilesByLevel utility\nimport { listFilesByLevel } from '@buger/probe';\n// Import schemas and parser from common (assuming tools.js)\nimport {\n  searchSchema, querySchema, extractSchema, attemptCompletionSchema,\n  searchToolDefinition, queryToolDefinition, extractToolDefinition, attemptCompletionToolDefinition, implementToolDefinition,\n  listFilesToolDefinition, searchFilesToolDefinition,\n  parseXmlToolCallWithThinking\n} from './tools.js'; // Assuming common.js is moved to tools/\n// Import tool *instances* for execution\nimport { searchToolInstance, queryToolInstance, extractToolInstance, implementToolInstance, listFilesToolInstance, searchFilesToolInstance } from './probeTool.js'; // Added new tool instances\n\n// Maximum number of messages to keep in history\nconst MAX_HISTORY_MESSAGES = 100;\n// Maximum iterations for the tool loop - configurable via MAX_TOOL_ITERATIONS env var\nconst MAX_TOOL_ITERATIONS = parseInt(process.env.MAX_TOOL_ITERATIONS || '30', 10);\n\n// Parse and validate allowed folders from environment variable\nconst allowedFolders = process.env.ALLOWED_FOLDERS\n  ? process.env.ALLOWED_FOLDERS.split(',').map(folder => folder.trim()).filter(Boolean)\n  : [];\n\n// Validate folders exist on startup - will be handled by index.js in non-interactive mode\n// This is kept for backward compatibility with direct ProbeChat usage\nconst validateFolders = () => {\n  if (allowedFolders.length > 0) {\n    for (const folder of allowedFolders) {\n      const exists = existsSync(folder);\n      // Only log if not in non-interactive mode or if in debug mode\n      if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n        console.log(`- ${folder} ${exists ? '\u2713' : '\u2717 (not found)'}`);\n        if (!exists) {\n          console.warn(`Warning: Folder \"${folder}\" does not exist or is not accessible`);\n        }\n      }\n    }\n  } else {\n    // Only log if not in non-interactive mode or if in debug mode\n    if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n      console.warn('No folders configured via ALLOWED_FOLDERS. Tools might default to current directory or require explicit paths.');\n    }\n  }\n};\n\n// Only validate folders on startup if not in non-interactive mode\nif (typeof process !== 'undefined' && !process.env.PROBE_CHAT_SKIP_FOLDER_VALIDATION) {\n  validateFolders();\n}\n\n\n/**\n * Extract image URLs from message text\n * @param {string} message - The message text to analyze\n * @param {boolean} debug - Whether to log debug information\n * @returns {Array} Array of { url: string, cleanedMessage: string }\n */\nfunction extractImageUrls(message, debug = false) {\n  // This function should be called within the session context, so it will inherit the trace ID\n  const tracer = trace.getTracer('probe-chat', '1.0.0');\n  return tracer.startActiveSpan('content.image.extract', (span) => {\n    try {\n      // Pattern to match image URLs and base64 data:\n      // 1. GitHub private-user-images URLs (always images, regardless of extension)\n      // 2. GitHub user-attachments/assets URLs (always images, regardless of extension)\n      // 3. URLs with common image extensions (PNG, JPG, JPEG, WebP, GIF)\n      // 4. Base64 data URLs (data:image/...)\n      // Updated to stop at quotes, spaces, or common HTML/XML delimiters\n      const imageUrlPattern = /(?:data:image\\/[a-zA-Z]*;base64,[A-Za-z0-9+/=]+|https?:\\/\\/(?:(?:private-user-images\\.githubusercontent\\.com|github\\.com\\/user-attachments\\/assets)\\/[^\\s\"'<>]+|[^\\s\"'<>]+\\.(?:png|jpg|jpeg|webp|gif)(?:\\?[^\\s\"'<>]*)?))/gi;\n      \n      span.setAttributes({\n        'message.length': message.length,\n        'debug.enabled': debug\n      });\n      \n      if (debug) {\n        console.log(`[DEBUG] Scanning message for image URLs. Message length: ${message.length}`);\n        console.log(`[DEBUG] Image URL pattern: ${imageUrlPattern.toString()}`);\n      }\n      \n      const urls = [];\n      let match;\n      \n      while ((match = imageUrlPattern.exec(message)) !== null) {\n        urls.push(match[0]);\n        if (debug) {\n          console.log(`[DEBUG] Found image URL: ${match[0]}`);\n        }\n      }\n      \n      // Remove image URLs from message text\n      const cleanedMessage = message.replace(imageUrlPattern, '').trim();\n      \n      span.setAttributes({\n        'images.found': urls.length,\n        'message.cleaned_length': cleanedMessage.length\n      });\n      \n      if (debug) {\n        console.log(`[DEBUG] Total image URLs found: ${urls.length}`);\n        if (urls.length > 0) {\n          console.log(`[DEBUG] Original message length: ${message.length}, cleaned message length: ${cleanedMessage.length}`);\n        }\n      }\n      \n      const result = {\n        imageUrls: urls,\n        cleanedMessage: cleanedMessage\n      };\n      \n      span.setStatus({ code: 1 }); // SUCCESS\n      return result;\n    } catch (error) {\n      span.recordException(error);\n      span.setStatus({ code: 2, message: error.message }); // ERROR\n      throw error;\n    } finally {\n      span.end();\n    }\n  });\n}\n\n/**\n * Validate image URLs by checking if they're accessible, handling redirects\n * @param {string[]} imageUrls - Array of image URLs to validate\n * @param {boolean} debug - Whether to log debug messages\n * @returns {Promise<string[]>} Array of valid final image URLs (after redirects)\n */\nasync function validateImageUrls(imageUrls, debug = false) {\n  const validUrls = [];\n  \n  for (const url of imageUrls) {\n    try {\n      // Check if it's a base64 data URL\n      if (url.startsWith('data:image/')) {\n        // Validate base64 data URL format\n        const dataUrlMatch = url.match(/^data:image\\/([a-zA-Z]*);base64,([A-Za-z0-9+/=]+)$/);\n        if (dataUrlMatch) {\n          const [, imageType, base64Data] = dataUrlMatch;\n          \n          // Basic validation of base64 data\n          if (base64Data.length > 0 && imageType) {\n            // Estimate file size from base64 (rough approximation: base64 is ~1.33x original size)\n            const estimatedSize = (base64Data.length * 3) / 4;\n            \n            // Check size limit (10MB)\n            if (estimatedSize <= 10 * 1024 * 1024) {\n              validUrls.push(url);\n              if (debug) {\n                console.log(`[DEBUG] Valid base64 image: ${imageType} (~${(estimatedSize / 1024).toFixed(1)}KB)`);\n              }\n            } else {\n              if (debug) {\n                console.log(`[DEBUG] Base64 image too large: ~${(estimatedSize / 1024 / 1024).toFixed(1)}MB (max 10MB)`);\n              }\n            }\n          } else {\n            if (debug) {\n              console.log(`[DEBUG] Invalid base64 data URL format: ${url.substring(0, 50)}...`);\n            }\n          }\n        } else {\n          if (debug) {\n            console.log(`[DEBUG] Invalid data URL format: ${url.substring(0, 50)}...`);\n          }\n        }\n      } else {\n        // Handle regular HTTP/HTTPS URLs\n        // Always use GET request with Range header to validate and get content type\n        // This works better than HEAD for GitHub URLs and other services\n        const response = await fetch(url, {\n          method: 'GET',\n          headers: {\n            'Range': 'bytes=0-1023' // Only fetch first 1KB to check content type and minimize data transfer\n          },\n          timeout: 10000, // TIMEOUTS.HTTP_REQUEST - 10 second timeout for GitHub URLs which can be slower\n          redirect: 'follow'\n        });\n        \n        if (response.ok || response.status === 206) { // 206 = Partial Content (from Range header)\n          // Check if the response has image content type\n          const contentType = response.headers.get('content-type');\n          if (contentType && contentType.startsWith('image/')) {\n            // Use the final URL after following redirects\n            const finalUrl = response.url;\n            validUrls.push(finalUrl);\n            if (debug) {\n              if (finalUrl !== url) {\n                console.log(`[DEBUG] Valid image URL after redirect: ${url} -> ${finalUrl} (${contentType})`);\n              } else {\n                console.log(`[DEBUG] Valid image URL: ${finalUrl} (${contentType})`);\n              }\n            }\n          } else {\n            if (debug) {\n              console.log(`[DEBUG] URL not an image: ${url} (${contentType || 'unknown type'})`);\n            }\n          }\n        } else {\n          if (debug) {\n            console.log(`[DEBUG] URL not accessible: ${url} (status: ${response.status})`);\n          }\n        }\n      }\n    } catch (error) {\n      if (debug) {\n        console.log(`[DEBUG] Error validating image URL ${url}: ${error.message}`);\n      }\n    }\n  }\n  \n  return validUrls;\n}\n\n/**\n * ProbeChat class to handle chat interactions with AI models\n */\nexport class ProbeChat {\n  /**\n   * Create a new ProbeChat instance\n   * @param {Object} options - Configuration options\n   * @param {string} [options.sessionId] - Optional session ID\n   * @param {boolean} [options.isNonInteractive=false] - Suppress internal logs if true\n   * @param {Function} [options.toolCallCallback] - Callback function for tool calls (sessionId, toolCallData) - *Note: Callback may need adjustment for XML flow*\n   * @param {string} [options.customPrompt] - Custom prompt to replace the default system message\n   * @param {string} [options.promptType] - Predefined prompt type (architect, code-review, support)\n   * @param {boolean} [options.allowEdit=false] - Allow the use of the 'implement' tool\n   */\n  constructor(options = {}) {\n    // Suppress internal logs if in non-interactive mode\n    this.isNonInteractive = !!options.isNonInteractive;\n    // Flag to track if a request has been cancelled\n    this.cancelled = false;\n\n    // AbortController for cancelling fetch requests\n    this.abortController = null;\n    // Make allowedFolders accessible as a property of the class\n    this.allowedFolders = allowedFolders;\n\n    // Store custom prompt or prompt type if provided\n    this.customPrompt = options.customPrompt || process.env.CUSTOM_PROMPT || null;\n    this.promptType = options.promptType || process.env.PROMPT_TYPE || null;\n\n    // Store allowEdit flag - enable if allow_edit is set or if allow_suggestions is set via environment\n    // Note: ALLOW_SUGGESTIONS also enables allowEdit because the implement tool is needed to generate\n    // code changes that reviewdog can then convert into PR review suggestions\n    this.allowEdit = !!options.allowEdit || process.env.ALLOW_EDIT === '1' || process.env.ALLOW_SUGGESTIONS === '1';\n\n    // Store client-provided API credentials if available\n    this.clientApiProvider = options.apiProvider;\n    this.clientApiKey = options.apiKey;\n    this.clientApiUrl = options.apiUrl;\n\n    // Initialize token counter and display\n    this.tokenCounter = new TokenCounter();\n    this.tokenDisplay = new TokenUsageDisplay({\n      maxTokens: 8192 // Will be updated based on model\n    });\n\n    // Use provided session ID or generate a unique one\n    this.sessionId = options.sessionId || randomUUID();\n\n    // Get debug mode\n    this.debug = process.env.DEBUG_CHAT === '1';\n\n    if (this.debug) {\n      console.log(`[DEBUG] Generated session ID for chat: ${this.sessionId}`);\n      console.log(`[DEBUG] Maximum tool iterations configured: ${MAX_TOOL_ITERATIONS}`);\n      console.log(`[DEBUG] Allow Edit (implement tool): ${this.allowEdit}`);\n    }\n\n    // Store tool instances for execution\n    // These are the actual functions/objects that perform the actions\n    this.toolImplementations = {\n      search: searchToolInstance,\n      query: queryToolInstance,\n      extract: extractToolInstance,\n      listFiles: listFilesToolInstance,\n      searchFiles: searchFilesToolInstance,\n      // attempt_completion is handled specially in the loop, no direct implementation needed here\n    };\n\n    // Conditionally add the implement tool if allowed\n    if (this.allowEdit) {\n      this.toolImplementations.implement = implementToolInstance;\n    }\n\n    // Initialize the chat model\n    this.initializeModel();\n\n    // Initialize telemetry\n    this.initializeTelemetry();\n\n    // Initialize chat history\n    this.history = [];\n    \n    // Initialize display history - tracks what users actually see\n    this.displayHistory = [];\n    \n    // Store persistent storage instance if provided\n    this.storage = options.storage || null;\n  }\n\n  /**\n   * Initialize the AI model based on available API keys and forced provider setting\n   */\n  initializeModel() {\n    // Get API keys from environment variables or client-provided values\n    const anthropicApiKey = this.clientApiKey && this.clientApiProvider === 'anthropic' ?\n      this.clientApiKey : process.env.ANTHROPIC_API_KEY;\n    const openaiApiKey = this.clientApiKey && this.clientApiProvider === 'openai' ?\n      this.clientApiKey : process.env.OPENAI_API_KEY;\n    const googleApiKey = this.clientApiKey && this.clientApiProvider === 'google' ?\n      this.clientApiKey : process.env.GOOGLE_API_KEY;\n\n    // Get custom API URLs if provided (client URL takes precedence over environment variables)\n    const llmBaseUrl = process.env.LLM_BASE_URL;           // Generic base URL for all providers\n\n    // For each provider, use client URL if available and matches the provider\n    const anthropicApiUrl = (this.clientApiUrl && this.clientApiProvider === 'anthropic') ?\n      this.clientApiUrl : (process.env.ANTHROPIC_API_URL || llmBaseUrl);\n\n    const openaiApiUrl = (this.clientApiUrl && this.clientApiProvider === 'openai') ?\n      this.clientApiUrl : (process.env.OPENAI_API_URL || llmBaseUrl);\n\n    const googleApiUrl = (this.clientApiUrl && this.clientApiProvider === 'google') ?\n      this.clientApiUrl : (process.env.GOOGLE_API_URL || llmBaseUrl);\n\n    // Get model override if provided\n    const modelName = process.env.MODEL_NAME;\n\n    // Check if client has specified a provider that should be forced\n    const clientForceProvider = this.clientApiProvider && this.clientApiKey ? this.clientApiProvider : null;\n\n    // Use client-forced provider or environment variable\n    const forceProvider = clientForceProvider || (process.env.FORCE_PROVIDER ? process.env.FORCE_PROVIDER.toLowerCase() : null);\n\n    if (this.debug) {\n      console.log(`[DEBUG] Available API keys: Anthropic=${!!anthropicApiKey}, OpenAI=${!!openaiApiKey}, Google=${!!googleApiKey}`);\n      console.log(`[DEBUG] Force provider: ${forceProvider || '(not set)'}`);\n      if (llmBaseUrl) console.log(`[DEBUG] Generic LLM Base URL: ${llmBaseUrl}`);\n      if (process.env.ANTHROPIC_API_URL) console.log(`[DEBUG] Custom Anthropic URL: ${anthropicApiUrl}`);\n      if (process.env.OPENAI_API_URL) console.log(`[DEBUG] Custom OpenAI URL: ${openaiApiUrl}`);\n      if (process.env.GOOGLE_API_URL) console.log(`[DEBUG] Custom Google URL: ${googleApiUrl}`);\n      if (modelName) console.log(`[DEBUG] Model override: ${modelName}`);\n    }\n\n    // Check if a specific provider is forced\n\n    if (forceProvider) {\n      if (!this.isNonInteractive || this.debug) {\n        console.log(`Provider forced to: ${forceProvider}`);\n      }\n\n      if (forceProvider === 'anthropic' && anthropicApiKey) {\n        this.initializeAnthropicModel(anthropicApiKey, anthropicApiUrl, modelName);\n        return;\n      } else if (forceProvider === 'openai' && openaiApiKey) {\n        this.initializeOpenAIModel(openaiApiKey, openaiApiUrl, modelName);\n        return;\n      } else if (forceProvider === 'google' && googleApiKey) {\n        this.initializeGoogleModel(googleApiKey, googleApiUrl, modelName);\n        return;\n      }\n\n      console.warn(`WARNING: Forced provider \"${forceProvider}\" selected but required API key is missing or invalid! Falling back to auto-detection.`);\n    }\n\n    // If no provider is forced or forced provider failed, use the first available API key\n    if (anthropicApiKey) {\n      this.initializeAnthropicModel(anthropicApiKey, anthropicApiUrl, modelName);\n    } else if (openaiApiKey) {\n      this.initializeOpenAIModel(openaiApiKey, openaiApiUrl, modelName);\n    } else if (googleApiKey) {\n      this.initializeGoogleModel(googleApiKey, googleApiUrl, modelName);\n    } else {\n      console.error('FATAL: No API key provided. Please set ANTHROPIC_API_KEY, OPENAI_API_KEY, or GOOGLE_API_KEY environment variable.');\n      this.noApiKeysMode = true; // Use flag for potential UI handling\n      this.model = 'none';\n      this.apiType = 'none';\n      console.log('ProbeChat cannot function without an API key.');\n      // Consider throwing an error here in a real application to prevent execution\n      // throw new Error('No API key configured for AI provider.');\n    }\n  }\n\n  /**\n   * Initialize Anthropic model\n   * @param {string} apiKey - Anthropic API key\n   * @param {string} [apiUrl] - Optional Anthropic API URL override\n   * @param {string} [modelName] - Optional model name override\n   */\n  initializeAnthropicModel(apiKey, apiUrl, modelName) {\n    this.provider = createAnthropic({\n      apiKey: apiKey,\n      ...(apiUrl && { baseURL: apiUrl }), // Conditionally add baseURL\n    });\n    this.model = modelName || 'claude-3-7-sonnet-20250219';\n    this.apiType = 'anthropic';\n    if (!this.isNonInteractive || this.debug) {\n      const urlSource = process.env.ANTHROPIC_API_URL ? 'ANTHROPIC_API_URL' :\n        (process.env.LLM_BASE_URL ? 'LLM_BASE_URL' : 'default');\n      console.log(`Using Anthropic API with model: ${this.model}${apiUrl ? ` (URL: ${apiUrl}, from: ${urlSource})` : ''}`);\n    }\n  }\n\n  /**\n   * Initialize OpenAI model\n   * @param {string} apiKey - OpenAI API key\n   * @param {string} [apiUrl] - Optional OpenAI API URL override\n   * @param {string} [modelName] - Optional model name override\n   */\n  initializeOpenAIModel(apiKey, apiUrl, modelName) {\n    this.provider = createOpenAI({\n      compatibility: 'strict',\n      apiKey: apiKey,\n      ...(apiUrl && { baseURL: apiUrl }), // Conditionally add baseURL\n    });\n    this.model = modelName || 'gpt-4o';\n    this.apiType = 'openai';\n    if (!this.isNonInteractive || this.debug) {\n      const urlSource = process.env.OPENAI_API_URL ? 'OPENAI_API_URL' :\n        (process.env.LLM_BASE_URL ? 'LLM_BASE_URL' : 'default');\n      console.log(`Using OpenAI API with model: ${this.model}${apiUrl ? ` (URL: ${apiUrl}, from: ${urlSource})` : ''}`);\n    }\n  }\n\n  /**\n   * Initialize Google model\n   * @param {string} apiKey - Google API key\n   * @param {string} [apiUrl] - Optional Google API URL override\n   * @param {string} [modelName] - Optional model name override\n   */\n  initializeGoogleModel(apiKey, apiUrl, modelName) {\n    this.provider = createGoogleGenerativeAI({\n      apiKey: apiKey,\n      ...(apiUrl && { baseURL: apiUrl }), // Conditionally add baseURL\n    });\n    this.model = modelName || 'gemini-2.0-flash';\n    this.apiType = 'google';\n    if (!this.isNonInteractive || this.debug) {\n      const urlSource = process.env.GOOGLE_API_URL ? 'GOOGLE_API_URL' :\n        (process.env.LLM_BASE_URL ? 'LLM_BASE_URL' : 'default');\n      console.log(`Using Google API with model: ${this.model}${apiUrl ? ` (URL: ${apiUrl}, from: ${urlSource})` : ''}`);\n    }\n    // Note: Google's tool support might differ. Ensure XML approach works reliably.\n  }\n\n  /**\n   * Initialize telemetry configuration\n   */\n  initializeTelemetry() {\n    try {\n      // Check if telemetry is enabled via environment variables\n      const fileEnabled = process.env.OTEL_ENABLE_FILE === 'true';\n      const remoteEnabled = process.env.OTEL_ENABLE_REMOTE === 'true';\n      const consoleEnabled = process.env.OTEL_ENABLE_CONSOLE === 'true';\n      \n      if (fileEnabled || remoteEnabled || consoleEnabled) {\n        this.telemetryConfig = new TelemetryConfig({\n          enableFile: fileEnabled,\n          enableRemote: remoteEnabled,\n          enableConsole: consoleEnabled,\n          filePath: process.env.OTEL_FILE_PATH || './traces.jsonl',\n          remoteEndpoint: process.env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT || 'http://localhost:4318/v1/traces'\n        });\n        \n        this.telemetryConfig.initialize();\n        \n        if (this.debug) {\n          console.log('[DEBUG] Telemetry initialized successfully');\n        }\n      } else {\n        if (this.debug) {\n          console.log('[DEBUG] Telemetry disabled - no exporters configured');\n        }\n      }\n    } catch (error) {\n      console.error('Failed to initialize telemetry:', error.message);\n      this.telemetryConfig = null;\n    }\n  }\n\n  /**\n    * Get the system message with instructions for the AI (XML Tool Format)\n    * @returns {Promise<string>} - The system message\n    */\n  async getSystemMessage() {\n    // --- Dynamically build Tool Definitions ---\n    let toolDefinitions = `\n${searchToolDefinition}\n${queryToolDefinition}\n${extractToolDefinition}\n${listFilesToolDefinition}\n${searchFilesToolDefinition}\n${attemptCompletionToolDefinition}\n`;\n    if (this.allowEdit) {\n      toolDefinitions += `${implementToolDefinition}\\n`;\n    }\n\n    // --- Dynamically build Tool Guidelines ---\n    let xmlToolGuidelines = `\n# Tool Use Formatting\n\nTool use MUST be formatted using XML-style tags. The tool name is enclosed in opening and closing tags, and each parameter is similarly enclosed within its own set of tags. You MUST use exactly ONE tool call per message until you are ready to complete the task.\n\nStructure:\n<tool_name>\n<parameter1_name>value1</parameter1_name>\n<parameter2_name>value2</parameter2_name>\n...\n</tool_name>\n\nExample:\n<search>\n<query>error handling</query>\n<path>src/search</path>\n</search>\n\n# Thinking Process\n\nBefore using a tool, analyze the situation within <thinking></thinking> tags. This helps you organize your thoughts and make better decisions. Your thinking process should include:\n\n1. Analyze what information you already have and what information you need to proceed with the task.\n2. Determine which of the available tools would be most effective for gathering this information or accomplishing the current step.\n3. Check if all required parameters for the tool are available or can be inferred from the context.\n4. If all parameters are available, proceed with the tool use.\n5. If parameters are missing, explain what's missing and why it's needed.\n\nExample:\n<thinking>\nI need to find code related to error handling in the search module. The most appropriate tool for this is the search tool, which requires a query parameter and a path parameter. I have both the query (\"error handling\") and the path (\"src/search\"), so I can proceed with the search.\n</thinking>\n\n# Tool Use Guidelines\n\n1.  Think step-by-step about how to achieve the user's goal.\n2.  Use <thinking></thinking> tags to analyze the situation and determine the appropriate tool.\n3.  Choose **one** tool that helps achieve the current step.\n4.  Format the tool call using the specified XML format. Ensure all required parameters are included.\n5.  **You MUST respond with exactly one tool call in the specified XML format in each turn.**\n6.  Wait for the tool execution result, which will be provided in the next message (within a <tool_result> block).\n7.  Analyze the tool result and decide the next step. If more tool calls are needed, repeat steps 2-6.\n8.  If the task is fully complete and all previous steps were successful, use the \\`<attempt_completion>\\` tool to provide the final answer. This is the ONLY way to finish the task.\n9.  If you cannot proceed (e.g., missing information, invalid request), explain the issue clearly before using \\`<attempt_completion>\\` with an appropriate message in the \\`<result>\\` tag.\n10. Do not be lazy and dig to the topic as deep as possible, until you see full picture.\n\nAvailable Tools:\n- search: Search code using keyword queries.\n- query: Search code using structural AST patterns.\n- extract: Extract specific code blocks or lines from files.\n- listFiles: List files and directories in a specified location.\n- searchFiles: Find files matching a glob pattern with recursive search capability.\n${this.allowEdit ? '- implement: Implement a feature or fix a bug using aider.\\n' : ''}\n- attempt_completion: Finalize the task and provide the result to the user.\n`;\n    // Common instructions that will be added to all prompts\n    const commonInstructions = `<instructions>\nFollow these instructions carefully:\n1.  Analyze the user's request.\n2.  Use <thinking></thinking> tags to analyze the situation and determine the appropriate tool for each step.\n3.  Use the available tools step-by-step to fulfill the request.\n4.  You should always prefer the \\`search\\` tool for code-related questions. Read full files only if really necessary.\n4.  Ensure to get really deep and understand the full picture before answering. Ensure to check dependencies where required.\n5.  You MUST respond with exactly ONE tool call per message, using the specified XML format, until the task is complete.\n6.  Wait for the tool execution result (provided in the next user message in a <tool_result> block) before proceeding to the next step.\n7.  Once the task is fully completed, and you have confirmed the success of all steps, use the '<attempt_completion>' tool to provide the final result. This is the ONLY way to signal completion.\n8.  Prefer concise and focused search queries. Use specific keywords and phrases to narrow down results. Avoid reading files in full, only when absolutely necessary.\n9.  Show mermaid diagrams to illustrate complex code structures or workflows. In diagrams, content inside [\"...\"] always should be in quotes.</instructions>\n`;\n\n    // Define predefined prompts (without the common instructions)\n    const predefinedPrompts = {\n      'code-explorer': `You are ProbeChat Code Explorer, a specialized AI assistant focused on helping developers, product managers, and QAs understand and navigate codebases. Your primary function is to answer questions based on code, explain how systems work, and provide insights into code functionality using the provided code analysis tools.\n\nWhen exploring code:\n- Provide clear, concise explanations based on user request\n- Find and highlight the most relevant code snippets, if required\n- Trace function calls and data flow through the system\n- Use diagrams to illustrate code structure and relationships when helpful\n- Try to understand the user's intent and provide relevant information\n- Understand high level picture\n- Balance detail with clarity in your explanations`,\n\n      'architect': `You are ProbeChat Architect, a specialized AI assistant focused on software architecture and design. Your primary function is to help users understand, analyze, and design software systems using the provided code analysis tools. You excel at identifying architectural patterns, suggesting improvements, and creating high-level design documentation. You provide detailed and accurate responses to user queries about system architecture, component relationships, and code organization.\n\nWhen analyzing code:\n- Focus on high-level design patterns and system organization\n- Identify architectural patterns and component relationships\n- Evaluate system structure and suggest architectural improvements\n- Create diagrams to illustrate system architecture and workflows\n- Consider scalability, maintainability, and extensibility in your analysis`,\n\n      'code-review': `You are ProbeChat Code Reviewer, a specialized AI assistant focused on code quality and best practices. Your primary function is to help users identify issues, suggest improvements, and ensure code follows best practices using the provided code analysis tools. You excel at spotting bugs, performance issues, security vulnerabilities, and style inconsistencies. You provide detailed and constructive feedback on code quality.\n\nWhen reviewing code:\n- Look for bugs, edge cases, and potential issues\n- Identify performance bottlenecks and optimization opportunities\n- Check for security vulnerabilities and best practices\n- Evaluate code style and consistency\n- Is the backward compatibility can be broken?\n- Organize feedback by severity (critical, major, minor) and type (bug, performance, security, style)\n- Provide specific, actionable suggestions with code examples where appropriate\n\n## Failure Detection\n\nIf you detect critical issues that should prevent the code from being merged, include <fail> in your response:\n- Security vulnerabilities that could be exploited\n- Breaking changes without proper documentation or migration path\n- Critical bugs that would cause system failures\n- Severe violations of project standards that must be addressed\n\nThe <fail> tag will cause the GitHub check to fail, drawing immediate attention to these critical issues.`,\n\n      'engineer': `You are senior engineer focused on software architecture and design.\nBefore jumping on the task you first, in details analyse user request, and try to provide elegant and concise solution.\nIf solution is clear, you can jump to implementation right away, if not, you can ask user a clarification question, by calling attempt_completion tool, with required details.\nYou are allowed to use search tool with allow_tests argument, in order to find the tests.\n\nBefore jumping to implementation:\n- Focus on high-level design patterns and system organization\n- Identify architectural patterns and component relationships\n- Evaluate system structure and suggest architectural improvements\n- Focus on backward compatibility.\n- Respond with diagrams to illustrate system architecture and workflows, if required.\n- Consider scalability, maintainability, and extensibility in your analysis\n\nDuring the implementation:\n- Avoid implementing special cases\n- Do not forget to add the tests`,\n\n      'support': `You are ProbeChat Support, a specialized AI assistant focused on helping developers troubleshoot issues and solve problems. Your primary function is to help users diagnose errors, understand unexpected behaviors, and find solutions using the provided code analysis tools. You excel at debugging, explaining complex concepts, and providing step-by-step guidance. You provide detailed and patient support to help users overcome technical challenges.\n\nWhen troubleshooting:\n- Focus on finding root causes, not just symptoms\n- Explain concepts clearly with appropriate context\n- Provide step-by-step guidance to solve problems\n- Suggest diagnostic steps to verify solutions\n- Consider edge cases and potential complications\n- Be empathetic and patient in your explanations`\n    };\n\n    let systemMessage = '';\n\n    // Use custom prompt if provided\n    if (this.customPrompt) {\n      // For custom prompts, use the entire content as is\n      systemMessage = \"<role>\" + this.customPrompt + \"</role>\";\n      if (this.debug) {\n        console.log(`[DEBUG] Using custom prompt`);\n      }\n    }\n    // Use predefined prompt if specified\n    else if (this.promptType && predefinedPrompts[this.promptType]) {\n      systemMessage = \"<role>\" + predefinedPrompts[this.promptType] + \"</role>\";\n      if (this.debug) {\n        console.log(`[DEBUG] Using predefined prompt: ${this.promptType}`);\n      }\n      // Add common instructions to predefined prompts\n      systemMessage += commonInstructions;\n    } else {\n      // Use the default prompt (code explorer) if no prompt type is specified\n      systemMessage = \"<role>\" + predefinedPrompts['code-explorer'] + \"</role>\";\n      if (this.debug) {\n        console.log(`[DEBUG] Using default prompt: code explorer`);\n      }\n      // Add common instructions to the default prompt\n      systemMessage += commonInstructions;\n    }\n    // Add XML Tool Guidelines\n    systemMessage += `\\n${xmlToolGuidelines}\\n`;\n\n    // Add Tool Definitions\n    systemMessage += `\\n# Tools Available\\n${toolDefinitions}\\n`;\n\n    // Add special emphasis for image handling\n    systemMessage += `\\n# CRITICAL: XML Tool Format Required\\n\\nEven when processing images or visual content, you MUST respond using the XML tool format. Do not provide direct answers about images - instead use the appropriate tool (usually <attempt_completion>) with your analysis inside the <result> tag.\\n\\nExample when analyzing an image:\\n<attempt_completion>\\n<result>\\nI can see this is a promotional image from Tyk showing... [your analysis here]\\n</result>\\n</attempt_completion>\\n`;\n\n\n    const searchDirectory = this.allowedFolders.length > 0 ? this.allowedFolders[0] : process.cwd();\n    if (this.debug) {\n      console.log(`[DEBUG] Generating file list for base directory: ${searchDirectory}...`);\n    }\n\n    // Add folder information\n    if (this.allowedFolders.length > 0) {\n      const folderList = this.allowedFolders.map(f => `\"${f}\"`).join(', ');\n      systemMessage += `\\n\\nYou are configured to primarily operate within these folders: ${folderList}. When using tools like 'search' or 'query', the 'path' parameter should generally refer to these folders or subpaths within them. The root for relative paths is considered the project base.`;\n    } else {\n      systemMessage += `\\n\\nCurrent path: ${searchDirectory}. When using tools, specify paths like '.' for the current directory, 'src/utils', etc., within the 'path' parameter. Dependencies are located in /dep folder: \"/dep/go/github.com/user/repo\", \"/dep/js/<package>\", \"/dep/rust/crate_name\".`;\n    }\n\n    // Add Rules/Capabilities section\n    systemMessage += `\\n\\n# Capabilities & Rules\\n- Search given folder using keywords (\\`search\\`) or structural patterns (\\`query\\`).\\n- Extract specific code blocks or full files using (\\`extract\\`).\\n- File paths are relative to the project base unless using dependency syntax.\\n- Always wait for tool results (\\`<tool_result>...\\`) before proceeding.\\n- Use \\`attempt_completion\\` ONLY when the entire task is finished.\\n- Be direct and technical. Use exactly ONE tool call per response in the specified XML format. Prefer using search tool.\\n`;\n\n    if (this.debug) {\n      console.log(`[DEBUG] Base system message length (pre-file list): ${systemMessage.length}`);\n    }\n\n    // Add file list information if available\n    try {\n      let files = await listFilesByLevel({\n        directory: searchDirectory, // Use the determined search directory\n        maxFiles: 100, // Keep it reasonable\n        respectGitignore: true\n      });\n\n      // Exclude debug file(s) and common large directories\n      files = files.filter((file) => {\n        const lower = file.toLowerCase();\n        return !lower.includes('probe-debug.txt') && !lower.includes('node_modules') && !lower.includes('/.git/');\n      });\n\n      if (files.length > 0) {\n        const fileListHeader = `\\n\\n# Project Files (Sample of up to ${files.length} files in ${searchDirectory}):\\n`;\n        const fileListContent = files.map(file => `- ${file}`).join('\\n');\n        systemMessage += fileListHeader + fileListContent;\n        if (this.debug) {\n          console.log(`[DEBUG] Added ${files.length} files to system message. Total length: ${systemMessage.length}`);\n        }\n      } else {\n        if (this.debug) {\n          console.log(`[DEBUG] No files found or listed for the project directory: ${searchDirectory}.`);\n        }\n        systemMessage += `\\n\\n# Project Files\\nNo files listed for the primary directory (${searchDirectory}). You may need to use tools like 'search' or 'query' with broad paths initially if the user's request requires file exploration.`;\n      }\n    } catch (error) {\n      console.warn(`Warning: Could not generate file list for directory \"${searchDirectory}\": ${error.message}`);\n      systemMessage += `\\n\\n# Project Files\\nCould not retrieve file listing. Proceed based on user instructions and tool capabilities.`;\n    }\n\n    if (this.debug) {\n      console.log(`[DEBUG] Final system message length: ${systemMessage.length}`);\n      // Log first/last parts for verification\n      const debugFilePath = join(process.cwd(), 'probe-debug-system-prompt.txt');\n      try {\n        writeFileSync(debugFilePath, systemMessage);\n        console.log(`[DEBUG] Full system prompt saved to ${debugFilePath}`);\n      } catch (e) {\n        console.error(`[DEBUG] Failed to write full system prompt: ${e.message}`);\n        console.log(`[DEBUG] System message START:\\n${systemMessage.substring(0, 300)}...`);\n        console.log(`[DEBUG] System message END:\\n...${systemMessage.substring(systemMessage.length - 300)}`);\n      }\n    }\n\n    return systemMessage;\n  }\n\n  /**\n   * Abort the current chat request\n   */\n  abort() {\n    if (!this.isNonInteractive || this.debug) {\n      console.log(`Aborting chat for session: ${this.sessionId}`);\n    }\n    this.cancelled = true;\n\n    // Abort any fetch requests\n    if (this.abortController) {\n      try {\n        this.abortController.abort('User cancelled request'); // Pass reason\n      } catch (error) {\n        // Ignore errors if already aborted or controller is in an unexpected state\n        if (error.name !== 'AbortError') {\n          console.error('Error aborting fetch request:', error);\n        }\n      }\n    }\n  }\n\n  /**\n   * Process a user message and get a response\n   * @param {string} message - The user message\n   * @param {string} [sessionId] - Optional session ID to use for this chat (overrides the default)\n   * @param {Object} [apiCredentials] - Optional API credentials for this call\n   * @param {string[]} [images] - Optional array of base64 image URLs\n   * @returns {Promise<string>} - The AI response\n   */\n  async chat(message, sessionId, apiCredentials = null, images = []) {\n    // Use our custom app tracer for granular tracing\n    const effectiveSessionId = sessionId || this.sessionId;\n    \n    // Start the chat session span first, then execute the entire chat flow within the session context\n    const chatSessionSpan = appTracer.startChatSession(effectiveSessionId, message, this.apiType, this.model);\n    \n    // Execute the entire chat flow within the session context\n    return await appTracer.withSessionContext(effectiveSessionId, async () => {\n    \n    try {\n\n        // Update client credentials if provided in this call\n        if (apiCredentials) {\n          this.clientApiProvider = apiCredentials.apiProvider || this.clientApiProvider;\n          this.clientApiKey = apiCredentials.apiKey || this.clientApiKey;\n          this.clientApiUrl = apiCredentials.apiUrl || this.clientApiUrl;\n\n          // Re-initialize the model with the new credentials\n          if (apiCredentials.apiKey && apiCredentials.apiProvider) {\n            this.initializeModel();\n          }\n        }\n\n        // Handle no API keys mode gracefully\n        if (this.noApiKeysMode) {\n          console.error(\"Cannot process chat: No API keys configured.\");\n          appTracer.endChatSession(effectiveSessionId, false, 0);\n          // Return structured response even for API key errors\n          return {\n            response: \"Error: ProbeChat is not configured with an AI provider API key. Please set the appropriate environment variable (e.g., ANTHROPIC_API_KEY, OPENAI_API_KEY) or provide an API key in the browser.\",\n            tokenUsage: { contextWindow: 0, current: {}, total: {} }\n          };\n        }\n\n        // Reset cancelled flag for the new request\n        this.cancelled = false;\n\n        // Create a new AbortController for this specific request\n        // This ensures previous cancellations don't affect new requests\n        this.abortController = new AbortController();\n\n        // If a session ID is provided and it's different from the current one, update it\n        if (sessionId && sessionId !== this.sessionId) {\n          if (this.debug) {\n            console.log(`[DEBUG] Switching session ID from ${this.sessionId} to ${sessionId}`);\n          }\n          // Update the session ID for this instance\n          this.sessionId = sessionId;\n          // NOTE: History is NOT cleared automatically when session ID changes this way.\n          // Call clearHistory() explicitly if a new session should start fresh.\n        }\n\n        // Process the message using the potentially updated session ID\n        const result = await this._processChat(message, effectiveSessionId, images);\n        \n        appTracer.endChatSession(effectiveSessionId, true, result.tokenUsage?.total?.total || 0);\n        \n        // CRITICAL FIX: Ensure all spans are properly exported before returning\n        if (this.telemetryConfig) {\n          try {\n            // First, ensure the session span is ended within its context\n            await appTracer.withSessionContext(effectiveSessionId, async () => {\n              // Small delay to ensure all child spans are ended\n              await new Promise(resolve => setTimeout(resolve, 50));\n            });\n            \n            // Give BatchSpanProcessor time to process the ended spans\n            // BatchSpanProcessor has a scheduledDelayMillis of 500ms (reduced from default 5000ms)\n            await new Promise(resolve => setTimeout(resolve, 600));\n            \n            // Force flush all pending spans\n            await this.telemetryConfig.forceFlush();\n            \n            // Additional delay to ensure file writes complete\n            await new Promise(resolve => setTimeout(resolve, 100));\n          } catch (flushError) {\n            if (this.debug) console.log('[DEBUG] Telemetry flush warning:', flushError.message);\n          }\n        }\n        \n        return result;\n      } catch (error) {\n        appTracer.endChatSession(effectiveSessionId, false, 0);\n        \n        // CRITICAL FIX: Ensure all spans are properly exported even on error\n        if (this.telemetryConfig) {\n          try {\n            // First, ensure the session span is ended within its context\n            await appTracer.withSessionContext(effectiveSessionId, async () => {\n              // Small delay to ensure all child spans are ended\n              await new Promise(resolve => setTimeout(resolve, 50));\n            });\n            \n            // Give BatchSpanProcessor time to process the ended spans\n            // BatchSpanProcessor has a scheduledDelayMillis of 500ms (reduced from default 5000ms)\n            await new Promise(resolve => setTimeout(resolve, 600));\n            \n            // Force flush all pending spans\n            await this.telemetryConfig.forceFlush();\n            \n            // Additional delay to ensure file writes complete\n            await new Promise(resolve => setTimeout(resolve, 100));\n          } catch (flushError) {\n            if (this.debug) console.log('[DEBUG] Telemetry flush warning:', flushError.message);\n          }\n        }\n        \n        throw error;\n      }\n    }); // End withSessionContext\n  }\n\n  /**\n   * Internal method to process a chat message using the XML tool loop\n   * @param {string} message - The user message\n   * @param {string} sessionId - The session ID for tracing\n   * @param {string[]} images - Array of base64 image URLs\n   * @returns {Promise<string>} - The final AI response after loop completion\n   * @private\n   */\n  async _processChat(message, sessionId, images = []) {\n    let currentIteration = 0;\n    let completionAttempted = false;\n    let finalResult = `Error: Max tool iterations (${MAX_TOOL_ITERATIONS}) reached without completion. You can increase this limit using the MAX_TOOL_ITERATIONS environment variable or --max-iterations flag.`; // Default error\n\n    this.abortController = new AbortController();\n    const debugFilePath = join(process.cwd(), 'probe-debug.txt');\n\n    try {\n      if (this.debug) {\n        console.log(`[DEBUG] ===== Starting XML Tool Chat Loop (Session: ${this.sessionId}) =====`);\n        console.log(`[DEBUG] Received user message: ${message}`);\n        console.log(`[DEBUG] Initial history length: ${this.history.length}`);\n      }\n\n      this.tokenCounter.startNewTurn();\n      this.tokenCounter.addRequestTokens(this.tokenCounter.countTokens(message));\n\n      if (this.history.length > MAX_HISTORY_MESSAGES) {\n        const removedCount = this.history.length - MAX_HISTORY_MESSAGES;\n        this.history = this.history.slice(removedCount);\n        if (this.debug) console.log(`[DEBUG] Trimmed history to ${this.history.length} messages (removed ${removedCount}).`);\n      }\n\n      const isFirstMessage = this.history.length === 0;\n      \n      // Start user message processing trace\n      const messageId = `msg_${Date.now()}`;\n      appTracer.startUserMessageProcessing(sessionId, messageId, message);\n      \n      // Extract image URLs from the message within the processing context\n      const { imageUrls, cleanedMessage } = appTracer.withUserProcessingContext(sessionId, () => \n        extractImageUrls(message, this.debug)\n      );\n      \n      // Start image processing trace if images are found\n      if (imageUrls.length > 0) {\n        appTracer.startImageProcessing(sessionId, messageId, imageUrls, cleanedMessage.length);\n        if (this.debug) console.log(`[DEBUG] Found ${imageUrls.length} image URLs in message`);\n      }\n      \n      // Log image detection only in interactive mode or debug mode\n      if (imageUrls.length > 0) {\n        if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n          console.log(`Detected ${imageUrls.length} image URL(s) in message.`);\n        }\n        if (this.debug) {\n          console.log(`[DEBUG] Extracted image URLs:`, imageUrls);\n        }\n      }\n      \n      // Validate image URLs and filter out broken ones\n      let validImageUrls = [];\n      let validationResults = null;\n      \n      if (imageUrls.length > 0) {\n        const validationStartTime = Date.now();\n        validImageUrls = await validateImageUrls(imageUrls, this.debug);\n        const validationEndTime = Date.now();\n        \n        // Record validation results in trace\n        validationResults = {\n          totalUrls: imageUrls.length,\n          validUrls: validImageUrls.length,\n          invalidUrls: imageUrls.length - validImageUrls.length,\n          redirectedUrls: 0, // TODO: capture from validateImageUrls if needed\n          timeoutUrls: 0, // TODO: capture from validateImageUrls if needed  \n          networkErrors: 0, // TODO: capture from validateImageUrls if needed\n          durationMs: validationEndTime - validationStartTime\n        };\n        \n        appTracer.recordImageValidation(sessionId, validationResults);\n        appTracer.endImageProcessing(sessionId, validImageUrls.length > 0, validImageUrls.length);\n      } else {\n        validImageUrls = await validateImageUrls(imageUrls, this.debug);\n      }\n      \n      // Start the agent loop trace within user processing context\n      appTracer.withUserProcessingContext(sessionId, () => {\n        appTracer.startAgentLoop(sessionId, MAX_TOOL_ITERATIONS);\n      });\n      \n      // Log validation results only in interactive mode or debug mode\n      if (imageUrls.length > 0) {\n        const invalidCount = imageUrls.length - validImageUrls.length;\n        if (process.env.PROBE_NON_INTERACTIVE !== '1' || process.env.DEBUG_CHAT === '1') {\n          if (validImageUrls.length > 0) {\n            console.log(`Image validation: ${validImageUrls.length} valid, ${invalidCount} invalid/inaccessible.`);\n          } else {\n            console.log(`Image validation: All ${imageUrls.length} image URLs failed validation.`);\n          }\n        }\n        \n        if (this.debug && validImageUrls.length > 0) {\n          console.log(`[DEBUG] Valid image URLs:`, validImageUrls);\n        }\n      }\n      \n      const wrappedMessage = isFirstMessage ? `<task>\\n${cleanedMessage}\\n</task>` : cleanedMessage;\n\n      // Combine extracted URL images with uploaded base64 images\n      const allImages = [...validImageUrls, ...images];\n      \n      // Create the user message with potential image attachments\n      const userMessage = { role: 'user', content: wrappedMessage };\n      \n      // Store user message in display history (always visible to users)\n      const displayUserMessage = { \n        role: 'user', \n        content: message, // Store original unwrapped message\n        visible: true, \n        displayType: 'user',\n        timestamp: new Date().toISOString()\n      };\n      \n      // Add image attachments if any images are present\n      if (allImages.length > 0) {\n        userMessage.content = [\n          { type: 'text', text: wrappedMessage },\n          ...allImages.map(imageUrl => ({\n            type: 'image',\n            image: imageUrl\n          }))\n        ];\n        \n        // Add images to display message as well\n        displayUserMessage.images = allImages;\n        \n        if (this.debug) {\n          console.log(`[DEBUG] Created message with ${allImages.length} images (${validImageUrls.length} from URLs, ${images.length} uploaded)`);\n        }\n      }\n      \n      // Add user message to display history\n      if (!this.displayHistory) {\n        this.displayHistory = [];\n      }\n      this.displayHistory.push(displayUserMessage);\n      \n      // Save user message to persistent storage\n      if (this.storage) {\n        this.storage.saveMessage(this.sessionId, {\n          role: 'user',\n          content: message, // Original message\n          timestamp: Date.now(),\n          displayType: 'user',\n          visible: 1,\n          images: allImages,\n          metadata: {}\n        }).catch(err => {\n          console.error('Failed to save user message to persistent storage:', err);\n        });\n      }\n\n      let currentMessages = [\n        ...this.history,\n        userMessage\n      ];\n\n      const promptGenerationStart = Date.now();\n      const systemPrompt = await this.getSystemMessage();\n      const promptGenerationEnd = Date.now();\n      \n      if (this.debug) {\n        const systemTokens = this.tokenCounter.countTokens(systemPrompt);\n        this.tokenCounter.addRequestTokens(systemTokens);\n        console.log(`[DEBUG] System prompt estimated tokens: ${systemTokens}`);\n        \n        // Record system prompt generation metrics\n        appTracer.recordSystemPromptGeneration(sessionId, {\n          baseLength: 11747, // Approximate base system message length\n          finalLength: systemPrompt.length,\n          filesAdded: this.history.length > 0 ? 35 : 36, // Approximate from logs\n          generationDurationMs: promptGenerationEnd - promptGenerationStart,\n          promptType: this.promptType || 'default',\n          estimatedTokens: systemTokens\n        });\n      }\n\n      while (currentIteration < MAX_TOOL_ITERATIONS && !completionAttempted) {\n        currentIteration++;\n        if (this.cancelled) throw new Error('Request was cancelled by the user');\n\n        // Start iteration trace within agent loop context\n        appTracer.withAgentLoopContext(sessionId, () => {\n          appTracer.startAgentIteration(sessionId, currentIteration, currentMessages.length, this.tokenCounter.contextSize || 0);\n        });\n\n        if (this.debug) {\n          console.log(`\\n[DEBUG] --- Tool Loop Iteration ${currentIteration}/${MAX_TOOL_ITERATIONS} ---`);\n          console.log(`[DEBUG] Current messages count for AI call: ${currentMessages.length}`);\n          currentMessages.slice(-3).forEach((msg, idx) => {\n            const contentPreview = (typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content)).substring(0, 80).replace(/\\n/g, ' ');\n            console.log(`[DEBUG]   Msg[${currentMessages.length - 3 + idx}]: ${msg.role}: ${contentPreview}...`);\n          });\n        }\n\n        this.tokenCounter.calculateContextSize(currentMessages);\n        if (this.debug) console.log(`[DEBUG] Estimated context tokens BEFORE LLM call (Iter ${currentIteration}): ${this.tokenCounter.contextSize}`);\n\n        let maxResponseTokens = 4000;\n        if (this.model.includes('claude-3-opus') || this.model.startsWith('gpt-4-')) {\n          maxResponseTokens = 4096;\n        } else if (this.model.includes('claude-3-5-sonnet') || this.model.startsWith('gpt-4o')) {\n          maxResponseTokens = 8000;\n        } else if (this.model.includes('gemini-2.5')) {\n          maxResponseTokens = 60000;\n        } else if (this.model.startsWith('gemini')) {\n          maxResponseTokens = 8000;\n        }\n        this.tokenDisplay = new TokenUsageDisplay({ maxTokens: maxResponseTokens });\n\n        const userMsgIndices = currentMessages.reduce(\n          (acc, msg, index) => (msg.role === 'user' ? [...acc, index] : acc),\n          []\n        );\n        const lastUserMsgIndex = userMsgIndices[userMsgIndices.length - 1] ?? -1;\n        const secondLastUserMsgIndex = userMsgIndices[userMsgIndices.length - 2] ?? -1;\n\n        let transformedMessages = currentMessages;\n        if (this.apiType === 'anthropic') {\n          transformedMessages = currentMessages.map((message, index) => {\n            if (message.role === 'user' && (index === lastUserMsgIndex || index === secondLastUserMsgIndex)) {\n              return {\n                ...message,\n                content: typeof message.content === 'string'\n                  ? [{ type: \"text\", text: message.content, providerOptions: { anthropic: { cacheControl: { type: 'ephemeral' } } } }]\n                  : message.content.map((content, contentIndex) => {\n                    // Only apply cache_control to the text part, not images\n                    if (content.type === 'text' && contentIndex === 0) {\n                      return {\n                        ...content,\n                        providerOptions: { anthropic: { cacheControl: { type: 'ephemeral' } } }\n                      };\n                    }\n                    return content;\n                  })\n              };\n            }\n            return message;\n          });\n        }\n\n        let streamError;\n\n        const generateOptions = {\n          model: this.provider(this.model),\n          messages: transformedMessages,\n          system: systemPrompt,\n          temperature: 0.3,\n          maxTokens: maxResponseTokens,\n          signal: this.abortController.signal,\n          onError({ error }) {\n            streamError = error;\n            console.error(error); // your error logging logic here\n          },\n          providerOptions: {\n            openai: {\n              streamOptions: {\n                include_usage: true\n              }\n            }\n          },\n          experimental_telemetry: {\n            isEnabled: false, // Disable built-in telemetry in favor of our custom tracing\n            functionId: this.sessionId,\n            metadata: {\n              sessionId: this.sessionId,\n              iteration: currentIteration,\n              model: this.model,\n              apiType: this.apiType,\n              allowEdit: this.allowEdit,\n              promptType: this.promptType || 'default'\n            }\n          }\n        };\n\n        // Start AI generation request trace within iteration context\n        const aiRequestSpan = appTracer.withIterationContext(sessionId, currentIteration, () => {\n          return appTracer.startAiGenerationRequest(sessionId, currentIteration, this.model, this.apiType, {\n          temperature: 0.3,\n          maxTokens: maxResponseTokens,\n          maxRetries: 2\n          });\n        });\n\n        // **Streaming Response Handling**\n        let assistantResponseContent = '';\n        let startTime = Date.now();\n        let firstChunkTime = null;\n        try {\n          if (this.debug) console.log(`[DEBUG] Calling streamText with model ${this.model}...`);\n\n          if (streamError) {\n            throw streamError\n          }\n\n          const { textStream } = streamText(generateOptions);\n          for await (const chunk of textStream) {\n            if (this.cancelled) throw new Error('Request was cancelled by the user');\n            if (firstChunkTime === null) {\n              firstChunkTime = Date.now();\n            }\n            assistantResponseContent += chunk;\n          }\n\n          if (this.debug) {\n            console.log(`[DEBUG] Streamed AI response (Iter ${currentIteration}). Length: ${assistantResponseContent.length}`);\n          }\n          if (assistantResponseContent.length == 0) {\n            console.warn(`[WARN] Empty response from AI model (Iter ${currentIteration}).`);\n            throw new Error('Empty response from AI model');\n          }\n\n          currentMessages.push({ role: 'assistant', content: assistantResponseContent });\n\n          const responseTokenCount = this.tokenCounter.countTokens(assistantResponseContent);\n          if (this.debug) console.log(`[DEBUG] Estimated response tokens (Iter ${currentIteration}): ${responseTokenCount}`);\n          this.tokenCounter.addResponseTokens(responseTokenCount);\n          this.tokenCounter.calculateContextSize(currentMessages);\n          if (this.debug) console.log(`[DEBUG] Context size AFTER LLM response (Iter ${currentIteration}): ${this.tokenCounter.contextSize}`);\n\n          // Record AI response in trace\n          const endTime = Date.now();\n          appTracer.recordAiResponse(sessionId, currentIteration, {\n            response: assistantResponseContent, // Include actual response content\n            responseLength: assistantResponseContent.length,\n            completionTokens: responseTokenCount,\n            promptTokens: this.tokenCounter.contextSize || 0,\n            finishReason: 'stop',\n            timeToFirstChunk: firstChunkTime ? (firstChunkTime - startTime) : 0,\n            timeToFinish: endTime - startTime\n          });\n\n          appTracer.endAiRequest(sessionId, currentIteration, true);\n\n        } catch (error) {\n          // Classify and record the AI model error\n          let errorCategory = 'unknown';\n          if (this.cancelled || error.name === 'AbortError' || (error.message && error.message.includes('cancelled'))) {\n            errorCategory = 'cancellation';\n          } else if (error.message?.includes('timeout')) {\n            errorCategory = 'timeout';\n          } else if (error.message?.includes('rate limit') || error.message?.includes('quota')) {\n            errorCategory = 'api_limit';\n          } else if (error.message?.includes('network') || error.message?.includes('fetch')) {\n            errorCategory = 'network';\n          } else if (error.status >= 400 && error.status < 500) {\n            errorCategory = 'client_error';\n          } else if (error.status >= 500) {\n            errorCategory = 'server_error';\n          }\n          \n          appTracer.recordAiModelError(sessionId, currentIteration, {\n            category: errorCategory,\n            message: error.message,\n            model: this.model,\n            provider: this.apiType,\n            statusCode: error.status || 0,\n            retryAttempt: 0\n          });\n          \n          appTracer.endAiRequest(sessionId, currentIteration, false);\n          \n          if (this.cancelled || error.name === 'AbortError' || (error.message && error.message.includes('cancelled'))) {\n            console.log(`Chat request cancelled during LLM call (Iter ${currentIteration})`);\n            this.cancelled = true;\n            appTracer.recordSessionCancellation(sessionId, 'ai_request_cancelled', {\n              currentIteration,\n              activeTool: 'ai_generation'\n            });\n            throw new Error('Request was cancelled by the user');\n          }\n          console.error(`Error during streamText (Iter ${currentIteration}):`, error);\n          finalResult = `Error: Failed to get response from AI model during iteration ${currentIteration}. ${error.message}`;\n          throw new Error(finalResult);\n        }\n\n        const parsedTool = parseXmlToolCallWithThinking(assistantResponseContent);\n        if (parsedTool) {\n          const { toolName, params } = parsedTool;\n          if (this.debug) console.log(`[DEBUG] Parsed tool call: ${toolName} with params:`, params);\n          \n          // Record tool call parsing in trace\n          appTracer.recordToolCallParsed(sessionId, currentIteration, toolName, params);\n\n          if (toolName === 'attempt_completion') {\n            completionAttempted = true;\n            const validation = attemptCompletionSchema.safeParse(params);\n            if (!validation.success) {\n              finalResult = `Error: AI attempted completion with invalid parameters: ${JSON.stringify(validation.error.issues)}`;\n              console.warn(`[WARN] Invalid attempt_completion parameters:`, validation.error.issues);\n              appTracer.recordCompletionAttempt(sessionId, false);\n            } else {\n              finalResult = validation.data.result;\n              \n              // Store final assistant response in display history\n              const displayAssistantMessage = {\n                role: 'assistant', \n                content: finalResult,\n                visible: true, \n                displayType: 'final',\n                timestamp: new Date().toISOString()\n              };\n              this.displayHistory.push(displayAssistantMessage);\n              \n              // Save final response to persistent storage\n              if (this.storage) {\n                this.storage.saveMessage(this.sessionId, {\n                  role: 'assistant',\n                  content: finalResult,\n                  timestamp: Date.now(),\n                  displayType: 'final',\n                  visible: 1,\n                  images: [],\n                  metadata: {}\n                }).catch(err => {\n                  console.error('Failed to save final response to persistent storage:', err);\n                });\n              }\n              \n              appTracer.recordCompletionAttempt(sessionId, true, finalResult);\n              if (this.debug) {\n                console.log(`[DEBUG] Completion attempted successfully. Final Result captured.`);\n\n                try {\n                  const systemPrompt = await this.getSystemMessage();\n                  let debugContent = `system: ${systemPrompt}\\n\\n`;\n                  for (const msg of currentMessages) {\n                    if (msg.role === 'user' || msg.role === 'assistant') {\n                      debugContent += `${msg.role}: ${msg.content}\\n\\n`;\n                    }\n                  }\n                  debugContent += `assistant (final result): ${finalResult}\\n\\n`;\n                  writeFileSync(debugFilePath, debugContent, { flag: 'w' });\n                  if (this.debug) console.log(`[DEBUG] Wrote complete chat history to ${debugFilePath}`);\n                } catch (error) {\n                  console.error(`Error writing chat history to debug file: ${error.message}`);\n                }\n              }\n            }\n            break;\n\n          } else if (this.toolImplementations[toolName]) {\n            const toolInstance = this.toolImplementations[toolName];\n            let toolResultContent = '';\n            \n            // Start tool execution trace within iteration context\n            appTracer.withIterationContext(sessionId, currentIteration, () => {\n              appTracer.startToolExecution(sessionId, currentIteration, toolName, params);\n            });\n            \n            try {\n              const enhancedParams = { ...params, sessionId: this.sessionId };\n              if (this.debug) console.log(`[DEBUG] Executing tool '${toolName}' with params:`, enhancedParams);\n              const executionResult = await toolInstance.execute(enhancedParams);\n              toolResultContent = typeof executionResult === 'string' ? executionResult : JSON.stringify(executionResult, null, 2);\n              if (this.debug) {\n                const preview = toolResultContent.substring(0, 200).replace(/\\n/g, ' ') + (toolResultContent.length > 200 ? '...' : '');\n                console.log(`[DEBUG] Tool '${toolName}' executed successfully. Result preview: ${preview}`);\n              }\n              \n              // End tool execution trace with success\n              appTracer.endToolExecution(sessionId, currentIteration, true, toolResultContent.length, null, toolResultContent);\n            } catch (error) {\n              console.error(`Error executing tool ${toolName}:`, error);\n              toolResultContent = `Error executing tool ${toolName}: ${error.message}`;\n              if (this.debug) console.log(`[DEBUG] Tool '${toolName}' execution FAILED.`);\n              \n              // Classify and record tool execution error\n              let errorCategory = 'execution';\n              if (error.message?.includes('validation')) {\n                errorCategory = 'validation';\n              } else if (error.message?.includes('permission') || error.message?.includes('access')) {\n                errorCategory = 'filesystem';\n              } else if (error.message?.includes('network') || error.message?.includes('fetch')) {\n                errorCategory = 'network';\n              } else if (error.message?.includes('timeout')) {\n                errorCategory = 'timeout';\n              }\n              \n              appTracer.recordToolError(sessionId, currentIteration, toolName, {\n                category: errorCategory,\n                message: error.message,\n                exitCode: error.code || 0,\n                signal: error.signal || '',\n                params: enhancedParams\n              });\n              \n              // End tool execution trace with failure\n              appTracer.endToolExecution(sessionId, currentIteration, false, 0, error.message, toolResultContent);\n            }\n\n            const toolResultMessage = `<tool_result>\\n${toolResultContent}\\n</tool_result>`;\n            currentMessages.push({ role: 'user', content: toolResultMessage });\n            this.tokenCounter.calculateContextSize(currentMessages);\n            if (this.debug) console.log(`[DEBUG] Context size after adding tool result for '${toolName}': ${this.tokenCounter.contextSize}`);\n\n          } else {\n            if (this.debug) console.log(`[DEBUG] Assistant used invalid tool name: ${toolName}`);\n            const errorContent = `<tool_result>\\nError: Invalid tool name specified: '${toolName}'. Please use one of: search, query, extract, attempt_completion.\\n</tool_result>`;\n            currentMessages.push({ role: 'user', content: errorContent });\n            this.tokenCounter.calculateContextSize(currentMessages);\n          }\n\n        } else {\n          if (this.debug) console.log(`[DEBUG] Assistant response did not contain a valid XML tool call.`);\n          const forceToolContent = `Your response did not contain a valid tool call in the required XML format. You MUST respond with exactly one tool call (e.g., <search>...</search> or <attempt_completion>...</attempt_completion>) based on the previous steps and the user's goal. Analyze the situation and choose the appropriate next tool.`;\n          currentMessages.push({ role: 'user', content: forceToolContent });\n          this.tokenCounter.calculateContextSize(currentMessages);\n        }\n\n        if (currentMessages.length > MAX_HISTORY_MESSAGES + 3) {\n          const messagesBefore = currentMessages.length;\n          const removeCount = currentMessages.length - MAX_HISTORY_MESSAGES;\n          currentMessages = currentMessages.slice(removeCount);\n          \n          // Record in-loop history management\n          appTracer.recordHistoryOperation(sessionId, 'trim', {\n            messagesBefore,\n            messagesAfter: currentMessages.length,\n            messagesRemoved: removeCount,\n            reason: 'loop_memory_limit'\n          });\n          \n          if (this.debug) console.log(`[DEBUG] Trimmed 'currentMessages' within loop to ${currentMessages.length} (removed ${removeCount}).`);\n          this.tokenCounter.calculateContextSize(currentMessages);\n        }\n        \n        // End iteration trace\n        appTracer.endIteration(sessionId, currentIteration, true, completionAttempted ? 'completion_attempted' : 'tool_executed');\n      }\n\n      if (currentIteration >= MAX_TOOL_ITERATIONS && !completionAttempted) {\n        console.warn(`[WARN] Max tool iterations (${MAX_TOOL_ITERATIONS}) reached for session ${this.sessionId}. Returning current error state.`);\n      }\n      \n      // End agent loop trace\n      appTracer.endAgentLoop(sessionId, currentIteration, completionAttempted, completionAttempted ? 'completion' : 'max_iterations');\n\n      this.history = currentMessages.map(msg => ({ ...msg }));\n      if (this.history.length > MAX_HISTORY_MESSAGES) {\n        const messagesBefore = this.history.length;\n        const finalRemoveCount = this.history.length - MAX_HISTORY_MESSAGES;\n        this.history = this.history.slice(finalRemoveCount);\n        \n        // Record history management operation\n        appTracer.recordHistoryOperation(sessionId, 'trim', {\n          messagesBefore,\n          messagesAfter: this.history.length,\n          messagesRemoved: finalRemoveCount,\n          reason: 'max_length'\n        });\n        \n        if (this.debug) console.log(`[DEBUG] Final history trim applied. Length: ${this.history.length} (removed ${finalRemoveCount})`);\n      }\n\n      this.tokenCounter.updateHistory(this.history);\n      \n      // Record token metrics\n      const tokenUsage = this.tokenCounter.getTokenUsage();\n      appTracer.recordTokenMetrics(sessionId, {\n        contextWindow: tokenUsage.contextWindow || 0,\n        currentTotal: tokenUsage.current?.total || 0,\n        requestTokens: tokenUsage.current?.request || 0,\n        responseTokens: tokenUsage.current?.response || 0,\n        cacheRead: tokenUsage.current?.cacheRead || 0,\n        cacheWrite: tokenUsage.current?.cacheWrite || 0\n      });\n      \n      // End user message processing trace\n      appTracer.endUserMessageProcessing(sessionId, completionAttempted);\n      \n      if (this.debug) {\n        console.log(`[DEBUG] Updated tokenCounter history with ${this.history.length} messages`);\n        console.log(`[DEBUG] Context size after history update: ${this.tokenCounter.contextSize}`);\n        console.log(`[DEBUG] ===== Ending XML Tool Chat Loop =====`);\n        console.log(`[DEBUG] Loop finished after ${currentIteration} iterations.`);\n        console.log(`[DEBUG] Completion attempted: ${completionAttempted}`);\n        console.log(`[DEBUG] Final history length: ${this.history.length}`);\n        const resultPreview = (typeof finalResult === 'string' ? finalResult : JSON.stringify(finalResult)).substring(0, 200).replace(/\\n/g, ' ');\n        console.log(`[DEBUG] Returning final result: \"${resultPreview}...\"`);\n      }\n\n      this.tokenCounter.calculateContextSize(this.history);\n      const updatedTokenUsage = this.tokenCounter.getTokenUsage();\n      if (this.debug) {\n        console.log(`[DEBUG] Final context window size: ${updatedTokenUsage.contextWindow}`);\n        console.log(`[DEBUG] Cache metrics - Read: ${updatedTokenUsage.current.cacheRead}, Write: ${updatedTokenUsage.current.cacheWrite}`);\n      }\n\n      return {\n        response: finalResult,\n        tokenUsage: updatedTokenUsage\n      };\n\n    } catch (error) {\n      // Check if this is a critical API error that should cause process exit\n      const isCriticalApiError = this._isCriticalApiError(error);\n      \n      // Record the top-level processing error\n      if (this.cancelled || (error.message && error.message.includes('cancelled'))) {\n        appTracer.recordSessionCancellation(sessionId, 'processing_cancelled', {\n          currentIteration,\n          errorMessage: error.message\n        });\n      } else {\n        // Record as a general processing error\n        appTracer.recordAiModelError(sessionId, currentIteration || 0, {\n          category: isCriticalApiError ? 'critical_api_error' : 'processing_error',\n          message: error.message,\n          model: this.model,\n          provider: this.apiType,\n          statusCode: error.statusCode || 0,\n          retryAttempt: 0\n        });\n      }\n      \n      // End chat session before cleanup to ensure span is properly captured\n      appTracer.endChatSession(sessionId, false, 0);\n      \n      // Clean up any remaining spans for this session (but session span is already ended)\n      appTracer.cleanup(sessionId);\n      \n      console.error('Error in chat processing loop:', error);\n      if (this.debug) console.error('Error in chat processing loop:', error);\n\n      this.tokenCounter.updateHistory(this.history);\n      if (this.debug) console.log(`[DEBUG] Error case - Updated tokenCounter history with ${this.history.length} messages`);\n\n      this.tokenCounter.calculateContextSize(this.history);\n      const updatedTokenUsage = this.tokenCounter.getTokenUsage();\n      if (this.debug) {\n        console.log(`[DEBUG] Error case - Final context window size: ${updatedTokenUsage.contextWindow}`);\n        console.log(`[DEBUG] Error case - Cache metrics - Read: ${updatedTokenUsage.current.cacheRead}, Write: ${updatedTokenUsage.current.cacheWrite}`);\n      }\n\n      if (this.cancelled || (error.message && error.message.includes('cancelled'))) {\n        return { response: \"Request cancelled.\", tokenUsage: updatedTokenUsage };\n      }\n      \n      // Re-throw critical API errors so the process exits with code 1\n      if (isCriticalApiError) {\n        throw error;\n      }\n      \n      return {\n        response: `Error during chat processing: ${error.message || 'An unexpected error occurred.'}`,\n        tokenUsage: updatedTokenUsage\n      };\n    } finally {\n      this.abortController = null;\n    }\n  }\n\n  /**\n   * Check if an error is a critical API error that should cause process exit\n   * @param {Error} error - The error to check\n   * @returns {boolean} - True if this is a critical API error\n   * @private\n   */\n  _isCriticalApiError(error) {\n    // Check for AI SDK API call errors\n    if (error[Symbol.for('vercel.ai.error.AI_APICallError')]) {\n      const statusCode = error.statusCode;\n      const errorMessage = error.message?.toLowerCase() || '';\n      \n      // Critical HTTP status codes that indicate configuration issues\n      if (statusCode === 401 || statusCode === 403) {\n        return true; // Unauthorized/Forbidden - bad API key\n      }\n      if (statusCode === 404) {\n        return true; // Not Found - wrong URL or model not found\n      }\n      if (statusCode >= 500 && statusCode < 600) {\n        return false; // Server errors - could be temporary, don't exit\n      }\n    }\n    \n    // Check for specific error messages that indicate configuration issues\n    const errorMessage = error.message?.toLowerCase() || '';\n    if (errorMessage.includes('not found')) {\n      return true; // API endpoint not found\n    }\n    if (errorMessage.includes('unauthorized') || errorMessage.includes('invalid api key')) {\n      return true; // Authentication issues\n    }\n    if (errorMessage.includes('forbidden') || errorMessage.includes('access denied')) {\n      return true; // Permission issues\n    }\n    if (errorMessage.includes('empty response from ai model')) {\n      return true; // Indicates API connection/configuration issue\n    }\n    \n    return false; // Other errors are not critical\n  }\n\n  /**\n   * Get the current token usage summary\n   * @returns {Object} - Raw token usage data for UI display\n   */\n  getTokenUsage() {\n    // Get raw token usage from the counter\n    const usage = this.tokenCounter.getTokenUsage();\n\n    // Return the raw usage data directly\n    // This allows the web interface to format it as needed\n    return usage;\n  }\n\n  /**\n   * Clear the entire history and reset session/token usage\n   * @returns {string} - The new session ID\n   */\n  clearHistory() {\n    const oldHistoryLength = this.history.length;\n    const oldSessionId = this.sessionId;\n\n    this.history = [];\n    this.sessionId = randomUUID(); // Generate a new session ID\n\n    // Clear the tokenCounter - this resets all counters and the internal history\n    this.tokenCounter.clear();\n\n    // Double-check that the tokenCounter's history is empty\n    if (this.tokenCounter.history && this.tokenCounter.history.length > 0) {\n      this.tokenCounter.history = [];\n      if (this.debug) {\n        console.log(`[DEBUG] Explicitly cleared tokenCounter history after clear() call`);\n      }\n    }\n\n    this.cancelled = false; // Reset cancellation flag\n    if (this.abortController) {\n      // Ensure any lingering abort signal is cleared (though should be handled by `chat`)\n      try { this.abortController.abort('History cleared'); } catch (e) { /* ignore */ }\n      this.abortController = null;\n    }\n\n\n    if (this.debug) {\n      console.log(`[DEBUG] ===== CLEARING CHAT HISTORY & STATE =====`);\n      console.log(`[DEBUG] Cleared ${oldHistoryLength} messages from history`);\n      console.log(`[DEBUG] Old session ID: ${oldSessionId}`);\n      console.log(`[DEBUG] New session ID: ${this.sessionId}`);\n      console.log(`[DEBUG] Token counter reset.`);\n      console.log(`[DEBUG] Cancellation flag reset.`);\n    }\n\n    // Tool implementations are instance properties, they persist. Session ID is passed during execution.\n\n    return this.sessionId; // Return the newly generated session ID\n  }\n\n  /**\n   * Get the session ID for this chat instance\n   * @returns {string} - The session ID\n   */\n  getSessionId() {\n    return this.sessionId;\n  }\n}\n\n// Export the extractImageUrls function for testing\nexport { extractImageUrls };\n", "import 'dotenv/config';\n\n/**\n * Basic authentication middleware\n * Checks for valid username and password in the Authorization header\n * Can be enabled/disabled via environment variables\n */\nexport function authMiddleware(req, res, next) {\n\t// Check if authentication is enabled\n\tconst AUTH_ENABLED = process.env.AUTH_ENABLED === '1';\n\n\t// If authentication is not enabled, skip authentication check\n\tif (!AUTH_ENABLED) {\n\t\treturn next(req, res);\n\t}\n\n\t// Get configured username and password from environment variables\n\tconst AUTH_USERNAME = process.env.AUTH_USERNAME || 'admin';\n\tconst AUTH_PASSWORD = process.env.AUTH_PASSWORD || 'password';\n\n\t// Check if request has Authorization header\n\tconst authHeader = req.headers.authorization;\n\n\tif (!authHeader) {\n\t\t// No Authorization header, return 401 Unauthorized\n\t\tres.writeHead(401, {\n\t\t\t'Content-Type': 'text/plain',\n\t\t\t'WWW-Authenticate': 'Basic realm=\"Probe Code Search\"'\n\t\t});\n\t\tres.end('Authentication required');\n\t\treturn;\n\t}\n\n\t// Parse Authorization header\n\ttry {\n\t\t// Basic auth format: \"Basic base64(username:password)\"\n\t\tconst authParts = authHeader.split(' ');\n\t\tif (authParts.length !== 2 || authParts[0] !== 'Basic') {\n\t\t\tthrow new Error('Invalid Authorization header format');\n\t\t}\n\n\t\t// Decode base64 credentials\n\t\tconst credentials = Buffer.from(authParts[1], 'base64').toString('utf-8');\n\t\tconst [username, password] = credentials.split(':');\n\n\t\t// Check if credentials match\n\t\tif (username === AUTH_USERNAME && password === AUTH_PASSWORD) {\n\t\t\t// Authentication successful, proceed to next middleware\n\t\t\treturn next(req, res);\n\t\t} else {\n\t\t\t// Invalid credentials, return 401 Unauthorized\n\t\t\tres.writeHead(401, {\n\t\t\t\t'Content-Type': 'text/plain',\n\t\t\t\t'WWW-Authenticate': 'Basic realm=\"Probe Code Search\"'\n\t\t\t});\n\t\t\tres.end('Invalid credentials');\n\t\t\treturn;\n\t\t}\n\t} catch (error) {\n\t\t// Error parsing Authorization header, return 400 Bad Request\n\t\tres.writeHead(400, { 'Content-Type': 'text/plain' });\n\t\tres.end('Invalid Authorization header');\n\t\treturn;\n\t}\n}\n\n/**\n * Apply authentication middleware to a request handler\n * @param {Function} handler - The request handler function\n * @returns {Function} - A new handler function with authentication\n */\nexport function withAuth(handler) {\n\treturn (req, res) => {\n\t\tauthMiddleware(req, res, () => handler(req, res));\n\t};\n}", "// Map to store active requests by session ID\nconst activeRequests = new Map();\n\n/**\n * Register a request as active\n * @param {string} sessionId - The session ID\n * @param {Object} requestData - Data about the request (can include abort functions, etc.)\n */\nexport function registerRequest(sessionId, requestData) {\n\tif (!sessionId) {\n\t\tconsole.warn('Attempted to register request without session ID');\n\t\treturn;\n\t}\n\n\tconsole.log(`Registering request for session: ${sessionId}`);\n\tactiveRequests.set(sessionId, requestData);\n}\n\n/**\n * Cancel a request by session ID\n * @param {string} sessionId - The session ID\n * @returns {boolean} - Whether the cancellation was successful\n */\nexport function cancelRequest(sessionId) {\n\tif (!sessionId) {\n\t\tconsole.warn('Attempted to cancel request without session ID');\n\t\treturn false;\n\t}\n\n\tconst requestData = activeRequests.get(sessionId);\n\tif (!requestData) {\n\t\tconsole.warn(`No active request found for session: ${sessionId}`);\n\t\treturn false;\n\t}\n\n\tconsole.log(`Cancelling request for session: ${sessionId}`);\n\n\t// Call the abort function if it exists\n\tif (typeof requestData.abort === 'function') {\n\t\ttry {\n\t\t\trequestData.abort();\n\t\t\tconsole.log(`Successfully aborted request for session: ${sessionId}`);\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error aborting request for session ${sessionId}:`, error);\n\t\t}\n\t}\n\n\t// Remove the request from the active requests map\n\tactiveRequests.delete(sessionId);\n\treturn true;\n}\n\n/**\n * Check if a request is active\n * @param {string} sessionId - The session ID\n * @returns {boolean} - Whether the request is active\n */\nexport function isRequestActive(sessionId) {\n\treturn activeRequests.has(sessionId);\n}\n\n/**\n * Get all active requests\n * @returns {Map} - Map of all active requests\n */\nexport function getActiveRequests() {\n\treturn activeRequests;\n}\n\n/**\n * Clear a request from the active requests map\n * @param {string} sessionId - The session ID\n */\nexport function clearRequest(sessionId) {\n\tif (!sessionId) {\n\t\tconsole.warn('Attempted to clear request without session ID');\n\t\treturn;\n\t}\n\n\tif (activeRequests.has(sessionId)) {\n\t\tconsole.log(`Clearing request for session: ${sessionId}`);\n\t\tactiveRequests.delete(sessionId);\n\t}\n}", "import { homedir } from 'os';\nimport { join } from 'path';\nimport { existsSync, mkdirSync, writeFileSync, readFileSync, readdirSync, statSync, unlinkSync } from 'fs';\n\n/**\n * JSON file-based storage for chat history\n * Each session is stored as a separate JSON file in ~/.probe/sessions/\n * Uses file modification time for sorting sessions\n */\nexport class JsonChatStorage {\n  constructor(options = {}) {\n    this.webMode = options.webMode || false;\n    this.verbose = options.verbose || false;\n    this.baseDir = this.getChatHistoryDir();\n    this.sessionsDir = join(this.baseDir, 'sessions');\n    this.fallbackToMemory = false;\n    \n    // In-memory fallback storage\n    this.memorySessions = new Map();\n    this.memoryMessages = new Map(); // sessionId -> messages[]\n  }\n  \n  /**\n   * Get the appropriate directory for storing chat history\n   */\n  getChatHistoryDir() {\n    if (process.platform === 'win32') {\n      // Windows: Use LocalAppData\n      const localAppData = process.env.LOCALAPPDATA || join(homedir(), 'AppData', 'Local');\n      return join(localAppData, 'probe');\n    } else {\n      // Mac/Linux: Use ~/.probe\n      return join(homedir(), '.probe');\n    }\n  }\n  \n  /**\n   * Ensure the chat history directory exists\n   */\n  ensureChatHistoryDir() {\n    try {\n      if (!existsSync(this.baseDir)) {\n        mkdirSync(this.baseDir, { recursive: true });\n      }\n      if (!existsSync(this.sessionsDir)) {\n        mkdirSync(this.sessionsDir, { recursive: true });\n      }\n      return true;\n    } catch (error) {\n      console.warn(`Failed to create chat history directory ${this.baseDir}:`, error.message);\n      return false;\n    }\n  }\n  \n  /**\n   * Get the file path for a session\n   */\n  getSessionFilePath(sessionId) {\n    return join(this.sessionsDir, `${sessionId}.json`);\n  }\n  \n  /**\n   * Initialize storage - JSON files if in web mode and directory is accessible\n   */\n  async initialize() {\n    if (!this.webMode) {\n      this.fallbackToMemory = true;\n      if (this.verbose) {\n        console.log('Using in-memory storage (CLI mode)');\n      }\n      return true;\n    }\n    \n    try {\n      if (!this.ensureChatHistoryDir()) {\n        this.fallbackToMemory = true;\n        if (this.verbose) {\n          console.log('Cannot create history directory, using in-memory storage');\n        }\n        return true;\n      }\n      \n      if (this.verbose) {\n        console.log(`JSON file storage initialized at: ${this.sessionsDir}`);\n      }\n      \n      return true;\n    } catch (error) {\n      console.warn('Failed to initialize JSON storage, falling back to memory:', error.message);\n      this.fallbackToMemory = true;\n      return true;\n    }\n  }\n  \n  /**\n   * Save or update session data\n   */\n  async saveSession(sessionData) {\n    const { id, createdAt, lastActivity, firstMessagePreview, metadata = {} } = sessionData;\n    \n    if (this.fallbackToMemory) {\n      this.memorySessions.set(id, {\n        id,\n        created_at: createdAt,\n        last_activity: lastActivity,\n        first_message_preview: firstMessagePreview,\n        metadata\n      });\n      return true;\n    }\n    \n    try {\n      const filePath = this.getSessionFilePath(id);\n      \n      // Read existing session data if it exists\n      let existingData = {\n        id,\n        created_at: createdAt,\n        last_activity: lastActivity,\n        first_message_preview: firstMessagePreview,\n        metadata,\n        messages: []\n      };\n      \n      if (existsSync(filePath)) {\n        try {\n          const fileContent = readFileSync(filePath, 'utf8');\n          const existing = JSON.parse(fileContent);\n          existingData = {\n            ...existing,\n            last_activity: lastActivity,\n            first_message_preview: firstMessagePreview || existing.first_message_preview,\n            metadata: { ...existing.metadata, ...metadata }\n          };\n        } catch (error) {\n          console.warn(`Failed to read existing session file ${filePath}:`, error.message);\n        }\n      }\n      \n      writeFileSync(filePath, JSON.stringify(existingData, null, 2));\n      return true;\n    } catch (error) {\n      console.error('Failed to save session:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Update session activity timestamp\n   */\n  async updateSessionActivity(sessionId, timestamp = Date.now()) {\n    if (this.fallbackToMemory) {\n      const session = this.memorySessions.get(sessionId);\n      if (session) {\n        session.last_activity = timestamp;\n      }\n      return true;\n    }\n    \n    try {\n      const filePath = this.getSessionFilePath(sessionId);\n      if (existsSync(filePath)) {\n        const fileContent = readFileSync(filePath, 'utf8');\n        const sessionData = JSON.parse(fileContent);\n        sessionData.last_activity = timestamp;\n        writeFileSync(filePath, JSON.stringify(sessionData, null, 2));\n      }\n      return true;\n    } catch (error) {\n      console.error('Failed to update session activity:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Save a message to the session\n   */\n  async saveMessage(sessionId, messageData) {\n    const {\n      role,\n      content,\n      timestamp = Date.now(),\n      displayType,\n      visible = 1,\n      images = [],\n      metadata = {}\n    } = messageData;\n    \n    const message = {\n      role,\n      content,\n      timestamp,\n      display_type: displayType,\n      visible,\n      images,\n      metadata\n    };\n    \n    if (this.fallbackToMemory) {\n      if (!this.memoryMessages.has(sessionId)) {\n        this.memoryMessages.set(sessionId, []);\n      }\n      this.memoryMessages.get(sessionId).push(message);\n      return true;\n    }\n    \n    try {\n      const filePath = this.getSessionFilePath(sessionId);\n      let sessionData = {\n        id: sessionId,\n        created_at: timestamp,\n        last_activity: timestamp,\n        first_message_preview: null,\n        metadata: {},\n        messages: []\n      };\n      \n      // Read existing session data\n      if (existsSync(filePath)) {\n        try {\n          const fileContent = readFileSync(filePath, 'utf8');\n          sessionData = JSON.parse(fileContent);\n        } catch (error) {\n          console.warn(`Failed to read session file ${filePath}:`, error.message);\n        }\n      }\n      \n      // Add message to session\n      sessionData.messages.push(message);\n      sessionData.last_activity = timestamp;\n      \n      // Update first message preview if this is the first user message\n      if (role === 'user' && !sessionData.first_message_preview) {\n        const preview = content.length > 100 ? content.substring(0, 100) + '...' : content;\n        sessionData.first_message_preview = preview;\n      }\n      \n      writeFileSync(filePath, JSON.stringify(sessionData, null, 2));\n      return true;\n    } catch (error) {\n      console.error('Failed to save message:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Get session history (display messages only)\n   */\n  async getSessionHistory(sessionId, limit = 100) {\n    if (this.fallbackToMemory) {\n      const messages = this.memoryMessages.get(sessionId) || [];\n      return messages\n        .filter(msg => msg.visible)\n        .slice(0, limit);\n    }\n    \n    try {\n      const filePath = this.getSessionFilePath(sessionId);\n      if (!existsSync(filePath)) {\n        return [];\n      }\n      \n      const fileContent = readFileSync(filePath, 'utf8');\n      const sessionData = JSON.parse(fileContent);\n      \n      return (sessionData.messages || [])\n        .filter(msg => msg.visible)\n        .slice(0, limit);\n    } catch (error) {\n      console.error('Failed to get session history:', error);\n      return [];\n    }\n  }\n  \n  /**\n   * List recent sessions using file modification dates\n   */\n  async listSessions(limit = 50, offset = 0) {\n    if (this.fallbackToMemory) {\n      const sessions = Array.from(this.memorySessions.values())\n        .sort((a, b) => b.last_activity - a.last_activity)\n        .slice(offset, offset + limit);\n      return sessions;\n    }\n    \n    try {\n      if (!existsSync(this.sessionsDir)) {\n        return [];\n      }\n      \n      // Get all JSON files in sessions directory\n      const files = readdirSync(this.sessionsDir)\n        .filter(file => file.endsWith('.json'))\n        .map(file => {\n          const filePath = join(this.sessionsDir, file);\n          const stat = statSync(filePath);\n          return {\n            file,\n            filePath,\n            mtime: stat.mtime.getTime(),\n            sessionId: file.replace('.json', '')\n          };\n        })\n        .sort((a, b) => b.mtime - a.mtime) // Sort by modification time (newest first)\n        .slice(offset, offset + limit);\n      \n      const sessions = [];\n      for (const fileInfo of files) {\n        try {\n          const fileContent = readFileSync(fileInfo.filePath, 'utf8');\n          const sessionData = JSON.parse(fileContent);\n          sessions.push({\n            id: sessionData.id,\n            created_at: sessionData.created_at,\n            last_activity: sessionData.last_activity || fileInfo.mtime,\n            first_message_preview: sessionData.first_message_preview,\n            metadata: sessionData.metadata || {}\n          });\n        } catch (error) {\n          console.warn(`Failed to read session file ${fileInfo.filePath}:`, error.message);\n        }\n      }\n      \n      return sessions;\n    } catch (error) {\n      console.error('Failed to list sessions:', error);\n      return [];\n    }\n  }\n  \n  /**\n   * Delete a session and its file\n   */\n  async deleteSession(sessionId) {\n    if (this.fallbackToMemory) {\n      this.memorySessions.delete(sessionId);\n      this.memoryMessages.delete(sessionId);\n      return true;\n    }\n    \n    try {\n      const filePath = this.getSessionFilePath(sessionId);\n      if (existsSync(filePath)) {\n        unlinkSync(filePath);\n      }\n      return true;\n    } catch (error) {\n      console.error('Failed to delete session:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Prune old sessions (older than specified days)\n   */\n  async pruneOldSessions(olderThanDays = 30) {\n    const cutoffTime = Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);\n    \n    if (this.fallbackToMemory) {\n      let pruned = 0;\n      for (const [sessionId, session] of this.memorySessions.entries()) {\n        if (session.last_activity < cutoffTime) {\n          this.memorySessions.delete(sessionId);\n          this.memoryMessages.delete(sessionId);\n          pruned++;\n        }\n      }\n      return pruned;\n    }\n    \n    try {\n      if (!existsSync(this.sessionsDir)) {\n        return 0;\n      }\n      \n      const files = readdirSync(this.sessionsDir).filter(file => file.endsWith('.json'));\n      let pruned = 0;\n      \n      for (const file of files) {\n        const filePath = join(this.sessionsDir, file);\n        const stat = statSync(filePath);\n        \n        if (stat.mtime.getTime() < cutoffTime) {\n          unlinkSync(filePath);\n          pruned++;\n        }\n      }\n      \n      return pruned;\n    } catch (error) {\n      console.error('Failed to prune old sessions:', error);\n      return 0;\n    }\n  }\n  \n  /**\n   * Get storage statistics\n   */\n  async getStats() {\n    if (this.fallbackToMemory) {\n      let messageCount = 0;\n      let visibleMessageCount = 0;\n      \n      for (const messages of this.memoryMessages.values()) {\n        messageCount += messages.length;\n        visibleMessageCount += messages.filter(msg => msg.visible).length;\n      }\n      \n      return {\n        session_count: this.memorySessions.size,\n        message_count: messageCount,\n        visible_message_count: visibleMessageCount,\n        storage_type: 'memory'\n      };\n    }\n    \n    try {\n      if (!existsSync(this.sessionsDir)) {\n        return {\n          session_count: 0,\n          message_count: 0,\n          visible_message_count: 0,\n          storage_type: 'json_files'\n        };\n      }\n      \n      const files = readdirSync(this.sessionsDir).filter(file => file.endsWith('.json'));\n      let messageCount = 0;\n      let visibleMessageCount = 0;\n      \n      for (const file of files) {\n        try {\n          const filePath = join(this.sessionsDir, file);\n          const fileContent = readFileSync(filePath, 'utf8');\n          const sessionData = JSON.parse(fileContent);\n          \n          if (sessionData.messages) {\n            messageCount += sessionData.messages.length;\n            visibleMessageCount += sessionData.messages.filter(msg => msg.visible).length;\n          }\n        } catch (error) {\n          // Skip corrupted files\n        }\n      }\n      \n      return {\n        session_count: files.length,\n        message_count: messageCount,\n        visible_message_count: visibleMessageCount,\n        storage_type: 'json_files'\n      };\n    } catch (error) {\n      console.error('Failed to get storage stats:', error);\n      return {\n        session_count: 0,\n        message_count: 0,\n        visible_message_count: 0,\n        storage_type: 'error'\n      };\n    }\n  }\n  \n  /**\n   * Check if using persistent storage\n   */\n  isPersistent() {\n    return !this.fallbackToMemory;\n  }\n  \n  /**\n   * Close storage (no-op for JSON files)\n   */\n  async close() {\n    // No cleanup needed for JSON files\n  }\n}", "import 'dotenv/config';\nimport { createServer } from 'http';\n// import { streamText } from 'ai'; // streamText might not be suitable for the loop logic directly\nimport { readFileSync, existsSync } from 'fs';\nimport { resolve, dirname, join } from 'path';\nimport { fileURLToPath } from 'url';\nimport { randomUUID } from 'crypto';\nimport { ProbeChat } from './probeChat.js';\nimport { TokenUsageDisplay } from './tokenUsageDisplay.js';\nimport { authMiddleware, withAuth } from './auth.js';\nimport {\n\t// probeTool, // This is the compatibility layer, less critical now\n\tsearchToolInstance, // Keep direct instances for API endpoints\n\tqueryToolInstance,\n\textractToolInstance,\n\timplementToolInstance,\n\ttoolCallEmitter,\n\tcancelToolExecutions,\n\tclearToolExecutionData,\n\tisSessionCancelled\n} from './probeTool.js';\nimport { registerRequest, cancelRequest, clearRequest, isRequestActive } from './cancelRequest.js';\nimport { JsonChatStorage } from './storage/JsonChatStorage.js';\n\n// Get the directory name of the current module\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\n// Global storage instance - will be initialized when web server starts\nlet globalStorage = null;\n\n// Map to store chat instances by session ID\nconst chatSessions = new Map();\n\n/**\n * Retrieve or create a ProbeChat instance keyed by sessionId.\n */\nfunction getOrCreateChat(sessionId, apiCredentials = null) {\n\tif (!sessionId) {\n\t\t// Safety fallback: generate a random ID if missing\n\t\tsessionId = randomUUID(); // Use crypto.randomUUID() if available/preferred\n\t\tconsole.warn(`[WARN] Missing sessionId, generated fallback: ${sessionId}`);\n\t}\n\t\n\t// Check in-memory cache first\n\tif (chatSessions.has(sessionId)) {\n\t\tconst existingChat = chatSessions.get(sessionId);\n\t\t// Update activity timestamp in persistent storage\n\t\tif (globalStorage) {\n\t\t\tglobalStorage.updateSessionActivity(sessionId).catch(err => {\n\t\t\t\tconsole.error('Failed to update session activity:', err);\n\t\t\t});\n\t\t}\n\t\treturn existingChat;\n\t}\n\n\t// Create options object with sessionId and API credentials if provided\n\tconst options = { sessionId };\n\tif (apiCredentials) {\n\t\toptions.apiProvider = apiCredentials.apiProvider;\n\t\toptions.apiKey = apiCredentials.apiKey;\n\t\toptions.apiUrl = apiCredentials.apiUrl;\n\t}\n\t\n\t// Pass storage instance for persistent storage\n\tif (globalStorage) {\n\t\toptions.storage = globalStorage;\n\t}\n\n\tconst newChat = new ProbeChat(options);\n\t\n\t// Add timestamps for session tracking\n\tconst now = Date.now();\n\tnewChat.createdAt = now;\n\tnewChat.lastActivity = now;\n\t\n\t// Store in memory cache\n\tchatSessions.set(sessionId, newChat);\n\t\n\t// Save session metadata to persistent storage\n\tif (globalStorage) {\n\t\tglobalStorage.saveSession({\n\t\t\tid: sessionId,\n\t\t\tcreatedAt: now,\n\t\t\tlastActivity: now,\n\t\t\tfirstMessagePreview: null, // Will be updated when first message is sent\n\t\t\tmetadata: {\n\t\t\t\tapiProvider: apiCredentials?.apiProvider || null\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tconsole.error('Failed to save session to persistent storage:', err);\n\t\t});\n\t}\n\t\n\tif (process.env.DEBUG_CHAT === '1') {\n\t\tconsole.log(`[DEBUG] Created and stored new chat instance for session: ${sessionId}. Total sessions: ${chatSessions.size}`);\n\t\tif (apiCredentials && apiCredentials.apiKey) {\n\t\t\tconsole.log(`[DEBUG] Chat instance created with client-provided API credentials (provider: ${apiCredentials.apiProvider})`);\n\t\t}\n\t}\n\treturn newChat;\n}\n\n/**\n * Start the web server\n * @param {string} version - The version of the application\n * @param {boolean} hasApiKeys - Whether any API keys are configured\n * @param {Object} options - Additional options\n * @param {boolean} options.allowEdit - Whether to allow editing files via the implement tool\n */\nexport function startWebServer(version, hasApiKeys = true, options = {}) {\n\tconst allowEdit = options?.allowEdit || false;\n\t\n\tif (allowEdit) {\n\t\tconsole.log('Edit mode enabled: implement tool is available');\n\t}\n\t// Authentication configuration\n\tconst AUTH_ENABLED = process.env.AUTH_ENABLED === '1';\n\tconst AUTH_USERNAME = process.env.AUTH_USERNAME || 'admin';\n\tconst AUTH_PASSWORD = process.env.AUTH_PASSWORD || 'password';\n\n\tif (AUTH_ENABLED) {\n\t\tconsole.log(`Authentication enabled (username: ${AUTH_USERNAME})`);\n\t} else {\n\t\tconsole.log('Authentication disabled');\n\t}\n\n\t// Initialize persistent storage for web mode\n\tglobalStorage = new JsonChatStorage({ \n\t\twebMode: true, \n\t\tverbose: process.env.DEBUG_CHAT === '1' \n\t});\n\t\n\t// Initialize storage asynchronously\n\t(async () => {\n\t\ttry {\n\t\t\tawait globalStorage.initialize();\n\t\t\tconst stats = await globalStorage.getStats();\n\t\t\tconsole.log(`Chat history storage: ${stats.storage_type} (${stats.session_count} sessions, ${stats.visible_message_count} messages)`);\n\t\t} catch (error) {\n\t\t\tconsole.warn('Failed to initialize chat history storage:', error.message);\n\t\t}\n\t})();\n\n\t// Map to store SSE clients by session ID\n\tconst sseClients = new Map();\n\n\t// Initialize a default ProbeChat instance for /folders endpoint? Or make folders static?\n\t// Let's make /folders rely on environment variables directly or a static config\n\t// to avoid needing a default chat instance just for that.\n\tconst staticAllowedFolders = process.env.ALLOWED_FOLDERS\n\t\t? process.env.ALLOWED_FOLDERS.split(',').map(folder => folder.trim()).filter(Boolean)\n\t\t: [];\n\n\n\tlet noApiKeysMode = !hasApiKeys;\n\tif (noApiKeysMode) {\n\t\tconsole.log('Running in No API Keys mode - will show setup instructions to users');\n\t} else {\n\t\tconsole.log('API keys detected. Chat functionality enabled.');\n\t}\n\n\n\t// Define the tools available for direct API calls (bypassing LLM loop)\n\t// Note: probeTool is the backward compatibility wrapper\n\tconst directApiTools = {\n\t\tsearch: searchToolInstance,\n\t\tquery: queryToolInstance,\n\t\textract: extractToolInstance\n\t};\n\t\n\t// Add implement tool if edit mode is enabled\n\tif (allowEdit) {\n\t\tdirectApiTools.implement = implementToolInstance;\n\t}\n\n\n\t// Helper function to send SSE data\n\tfunction sendSSEData(res, data, eventType = 'message') {\n\t\tconst DEBUG = process.env.DEBUG_CHAT === '1';\n\t\ttry {\n\t\t\t// Check if the response stream is still writable\n\t\t\tif (!res.writable || res.writableEnded) {\n\t\t\t\tif (DEBUG) console.log(`[DEBUG] SSE stream closed for event type ${eventType}, cannot send.`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (DEBUG) {\n\t\t\t\t// console.log(`[DEBUG] Sending SSE data, event type: ${eventType}`); // Can be noisy\n\t\t\t}\n\t\t\tres.write(`event: ${eventType}\\n`);\n\t\t\tres.write(`data: ${JSON.stringify(data)}\\n\\n`);\n\t\t\tif (DEBUG) {\n\t\t\t\t// console.log(`[DEBUG] SSE data sent successfully for event: ${eventType}`);\n\t\t\t\t// const preview = JSON.stringify(data).substring(0, 100);\n\t\t\t\t// console.log(`[DEBUG] SSE data content preview: ${preview}...`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(`[ERROR] Error sending SSE data:`, error);\n\t\t\t// Attempt to close the connection gracefully on error?\n\t\t\ttry {\n\t\t\t\tif (res.writable && !res.writableEnded) res.end();\n\t\t\t} catch (closeError) {\n\t\t\t\tconsole.error(`[ERROR] Error closing SSE stream after send error:`, closeError);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Map to store active chat instances by session ID for cancellation purposes\n\tconst activeChatInstances = new Map();\n\n\tconst server = createServer(async (req, res) => {\n\t\t// Apply authentication middleware to all requests first\n\t\tconst processRequest = (routeHandler) => {\n\t\t\t// First apply authentication middleware\n\t\t\tauthMiddleware(req, res, () => {\n\t\t\t\t// Then process the route if authentication passes\n\t\t\t\trouteHandler(req, res);\n\t\t\t});\n\t\t};\n\n\t\t// Define route handlers\n\t\tconst routes = {\n\t\t\t// Handle OPTIONS requests for CORS preflight (Common)\n\t\t\t'OPTIONS /api/token-usage': (req, res) => handleOptions(res),\n\t\t\t'OPTIONS /api/sessions': (req, res) => handleOptions(res),\n\t\t\t'OPTIONS /chat': (req, res) => handleOptions(res),\n\t\t\t'OPTIONS /api/search': (req, res) => handleOptions(res),\n\t\t\t'OPTIONS /api/query': (req, res) => handleOptions(res),\n\t\t\t'OPTIONS /api/extract': (req, res) => handleOptions(res),\n\t\t\t'OPTIONS /api/implement': (req, res) => handleOptions(res),\n\t\t\t'OPTIONS /cancel-request': (req, res) => handleOptions(res),\n\t\t\t'OPTIONS /folders': (req, res) => handleOptions(res), // Added for /folders\n\n\n\t\t\t// Token usage API endpoint\n\t\t\t'GET /api/token-usage': (req, res) => {\n\t\t\t\tconst sessionId = getSessionIdFromUrl(req);\n\t\t\t\tif (!sessionId) return sendError(res, 400, 'Missing sessionId parameter');\n\n\t\t\t\tconst chatInstance = chatSessions.get(sessionId);\n\t\t\t\tif (!chatInstance) return sendError(res, 404, 'Session not found');\n\n\t\t\t\tconst DEBUG = process.env.DEBUG_CHAT === '1';\n\n\t\t\t\t// Update the tokenCounter's history with the chat history\n\t\t\t\tif (chatInstance.tokenCounter && typeof chatInstance.tokenCounter.updateHistory === 'function' &&\n\t\t\t\t\tchatInstance.history) {\n\t\t\t\t\tchatInstance.tokenCounter.updateHistory(chatInstance.history);\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tconsole.log(`[DEBUG] Updated tokenCounter history with ${chatInstance.history.length} messages for token usage request`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Get raw token usage data from the chat instance\n\t\t\t\tconst tokenUsage = chatInstance.getTokenUsage();\n\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tconsole.log(`[DEBUG] Token usage request - Context window size: ${tokenUsage.contextWindow}`);\n\t\t\t\t\tconsole.log(`[DEBUG] Token usage request - Cache metrics - Read: ${tokenUsage.current.cacheRead}, Write: ${tokenUsage.current.cacheWrite}`);\n\t\t\t\t}\n\n\t\t\t\t// Send the raw token usage data to the client\n\t\t\t\t// The client-side JavaScript will handle formatting\n\t\t\t\tsendJson(res, 200, tokenUsage);\n\t\t\t},\n\n\t\t\t// Session history API endpoint for URL-based session restoration\n\t\t\t'GET /api/session/:sessionId/history': async (req, res) => {\n\t\t\t\tconst sessionId = extractSessionIdFromHistoryPath(req.url);\n\t\t\t\tif (!sessionId) return sendError(res, 400, 'Missing sessionId in URL path');\n\n\t\t\t\tconst DEBUG = process.env.DEBUG_CHAT === '1';\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tconsole.log(`[DEBUG] Fetching history for session: ${sessionId}`);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\t// First check if session is in memory cache\n\t\t\t\t\tconst chatInstance = chatSessions.get(sessionId);\n\t\t\t\t\tlet history = [];\n\t\t\t\t\tlet tokenUsage = null;\n\t\t\t\t\tlet exists = false;\n\n\t\t\t\t\tif (chatInstance) {\n\t\t\t\t\t\t// Session is active - use in-memory display history for consistency\n\t\t\t\t\t\thistory = chatInstance.displayHistory || [];\n\t\t\t\t\t\ttokenUsage = chatInstance.getTokenUsage();\n\t\t\t\t\t\texists = true;\n\t\t\t\t\t} else if (globalStorage) {\n\t\t\t\t\t\t// Session not in memory - try loading from persistent storage\n\t\t\t\t\t\tconst persistentHistory = await globalStorage.getSessionHistory(sessionId);\n\t\t\t\t\t\tif (persistentHistory && persistentHistory.length > 0) {\n\t\t\t\t\t\t\t// Convert stored messages to display format\n\t\t\t\t\t\t\thistory = persistentHistory.map(msg => ({\n\t\t\t\t\t\t\t\trole: msg.role,\n\t\t\t\t\t\t\t\tcontent: msg.content,\n\t\t\t\t\t\t\t\ttimestamp: new Date(msg.timestamp).toISOString(),\n\t\t\t\t\t\t\t\tdisplayType: msg.display_type,\n\t\t\t\t\t\t\t\tvisible: msg.visible,\n\t\t\t\t\t\t\t\timages: msg.images || []\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\texists = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsendJson(res, 200, {\n\t\t\t\t\t\thistory: history,\n\t\t\t\t\t\ttokenUsage: tokenUsage,\n\t\t\t\t\t\tsessionId: sessionId,\n\t\t\t\t\t\texists: exists,\n\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t});\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error fetching session history:', error);\n\t\t\t\t\tsendJson(res, 200, {\n\t\t\t\t\t\thistory: [],\n\t\t\t\t\t\ttokenUsage: null,\n\t\t\t\t\t\tsessionId: sessionId,\n\t\t\t\t\t\texists: false,\n\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Sessions list endpoint for history dropdown\n\t\t\t'GET /api/sessions': async (req, res) => {\n\t\t\t\tconst DEBUG = process.env.DEBUG_CHAT === '1';\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tconsole.log(`[DEBUG] Fetching sessions list`);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst sessions = [];\n\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\tconst maxAge = 2 * 60 * 60 * 1000; // 2 hours in milliseconds\n\n\t\t\t\t\tif (globalStorage) {\n\t\t\t\t\t\t// Get sessions from persistent storage\n\t\t\t\t\t\tconst storedSessions = await globalStorage.listSessions(50);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (const session of storedSessions) {\n\t\t\t\t\t\t\t// Skip inactive sessions older than 2 hours\n\t\t\t\t\t\t\tif (now - session.last_activity > maxAge) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Use stored preview or generate from session metadata\n\t\t\t\t\t\t\tlet preview = session.first_message_preview;\n\t\t\t\t\t\t\tif (!preview) {\n\t\t\t\t\t\t\t\t// If no preview stored, try to get first message from history\n\t\t\t\t\t\t\t\tconst history = await globalStorage.getSessionHistory(session.id, 1);\n\t\t\t\t\t\t\t\tif (history.length > 0 && history[0].role === 'user') {\n\t\t\t\t\t\t\t\t\tconst cleanContent = extractContentFromMessage(history[0].content);\n\t\t\t\t\t\t\t\t\tpreview = cleanContent.length > 100 \n\t\t\t\t\t\t\t\t\t\t? cleanContent.substring(0, 100) + '...' \n\t\t\t\t\t\t\t\t\t\t: cleanContent;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (preview) {\n\t\t\t\t\t\t\t\tsessions.push({\n\t\t\t\t\t\t\t\t\tsessionId: session.id,\n\t\t\t\t\t\t\t\t\tpreview: preview,\n\t\t\t\t\t\t\t\t\tmessageCount: 0, // We could calculate this but it's not critical\n\t\t\t\t\t\t\t\t\tcreatedAt: new Date(session.created_at).toISOString(),\n\t\t\t\t\t\t\t\t\tlastActivity: new Date(session.last_activity).toISOString(),\n\t\t\t\t\t\t\t\t\trelativeTime: getRelativeTime(session.last_activity)\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Fallback to in-memory sessions\n\t\t\t\t\t\tfor (const [sessionId, chatInstance] of chatSessions.entries()) {\n\t\t\t\t\t\t\t// Skip sessions without any history\n\t\t\t\t\t\t\tif (!chatInstance.history || chatInstance.history.length === 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get session metadata\n\t\t\t\t\t\t\tconst createdAt = chatInstance.createdAt || now;\n\t\t\t\t\t\t\tconst lastActivity = chatInstance.lastActivity || createdAt;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Skip inactive sessions older than 2 hours\n\t\t\t\t\t\t\tif (now - lastActivity > maxAge) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Find the first user message for preview\n\t\t\t\t\t\t\tconst firstUserMessage = chatInstance.history.find(msg => msg.role === 'user');\n\t\t\t\t\t\t\tif (!firstUserMessage) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Extract clean content and create preview\n\t\t\t\t\t\t\tconst cleanContent = extractContentFromMessage(firstUserMessage.content);\n\t\t\t\t\t\t\tconst preview = cleanContent.length > 100 \n\t\t\t\t\t\t\t\t? cleanContent.substring(0, 100) + '...' \n\t\t\t\t\t\t\t\t: cleanContent;\n\n\t\t\t\t\t\t\tsessions.push({\n\t\t\t\t\t\t\t\tsessionId: sessionId,\n\t\t\t\t\t\t\t\tpreview: preview,\n\t\t\t\t\t\t\t\tmessageCount: chatInstance.history.length,\n\t\t\t\t\t\t\t\tcreatedAt: new Date(createdAt).toISOString(),\n\t\t\t\t\t\t\t\tlastActivity: new Date(lastActivity).toISOString(),\n\t\t\t\t\t\t\t\trelativeTime: getRelativeTime(lastActivity)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tconsole.log(`[DEBUG] Returning ${sessions.length} sessions`);\n\t\t\t\t\t}\n\n\t\t\t\t\tsendJson(res, 200, {\n\t\t\t\t\t\tsessions: sessions,\n\t\t\t\t\t\ttotal: sessions.length,\n\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t});\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error('Error fetching sessions list:', error);\n\t\t\t\t\tsendJson(res, 500, { error: 'Failed to fetch sessions' });\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Static file routes\n\t\t\t'GET /logo.png': (req, res) => serveStatic(res, join(__dirname, 'logo.png'), 'image/png'),\n\t\t\t// UI Routes\n\t\t\t'GET /': (req, res) => {\n\t\t\t\tconst htmlPath = join(__dirname, 'index.html');\n\t\t\t\tserveHtml(res, htmlPath, { 'data-no-api-keys': noApiKeysMode ? 'true' : 'false' });\n\t\t\t},\n\n\t\t\t// Chat session route - serves HTML with injected session ID\n\t\t\t'GET /chat/:sessionId': (req, res) => {\n\t\t\t\tconst sessionId = extractSessionIdFromPath(req.url);\n\t\t\t\tif (!sessionId) {\n\t\t\t\t\treturn sendError(res, 400, 'Invalid session ID in URL');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Validate that session exists or at least has a valid UUID format\n\t\t\t\tif (!isValidUUID(sessionId)) {\n\t\t\t\t\treturn sendError(res, 400, 'Invalid session ID format');\n\t\t\t\t}\n\n\t\t\t\tconst htmlPath = join(__dirname, 'index.html');\n\t\t\t\tserveHtml(res, htmlPath, { \n\t\t\t\t\t'data-no-api-keys': noApiKeysMode ? 'true' : 'false',\n\t\t\t\t\t'data-session-id': sessionId\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t'GET /folders': (req, res) => {\n\t\t\t\tconst currentWorkingDir = process.cwd();\n\t\t\t\t// Use static config or environment variables directly\n\t\t\t\tconst folders = staticAllowedFolders.length > 0 ? staticAllowedFolders : [currentWorkingDir];\n\t\t\t\t// Use first allowed folder as currentDir, or fall back to process.cwd()\n\t\t\t\tconst currentDir = staticAllowedFolders.length > 0 ? staticAllowedFolders[0] : currentWorkingDir;\n\n\t\t\t\tsendJson(res, 200, {\n\t\t\t\t\tfolders: folders,\n\t\t\t\t\tcurrentDir: currentDir,\n\t\t\t\t\tnoApiKeysMode: noApiKeysMode\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t'GET /openapi.yaml': (req, res) => serveStatic(res, join(__dirname, 'openapi.yaml'), 'text/yaml'),\n\n\n\t\t\t// SSE endpoint for tool calls - NO AUTH for easier client implementation\n\t\t\t'GET /api/tool-events': (req, res) => {\n\t\t\t\tconst DEBUG = process.env.DEBUG_CHAT === '1';\n\t\t\t\tconst sessionId = getSessionIdFromUrl(req);\n\t\t\t\tif (!sessionId) {\n\t\t\t\t\tif (DEBUG) console.error(`[DEBUG] SSE: No sessionId found in URL: ${req.url}`);\n\t\t\t\t\treturn sendError(res, 400, 'Missing sessionId parameter');\n\t\t\t\t}\n\n\t\t\t\tif (DEBUG) console.log(`[DEBUG] SSE: Setting up connection for session: ${sessionId}`);\n\n\t\t\t\t// Set headers for SSE\n\t\t\t\tres.writeHead(200, {\n\t\t\t\t\t'Content-Type': 'text/event-stream',\n\t\t\t\t\t'Cache-Control': 'no-cache',\n\t\t\t\t\t'Connection': 'keep-alive',\n\t\t\t\t\t'Access-Control-Allow-Origin': '*' // Allow all origins for SSE\n\t\t\t\t});\n\t\t\t\tif (DEBUG) console.log(`[DEBUG] SSE: Headers set for session: ${sessionId}`);\n\n\t\t\t\t// Send initial connection established event\n\t\t\t\tconst connectionData = { type: 'connection', message: 'SSE Connection Established', sessionId, timestamp: new Date().toISOString() };\n\t\t\t\tsendSSEData(res, connectionData, 'connection');\n\t\t\t\tif (DEBUG) console.log(`[DEBUG] SSE: Sent connection event for session: ${sessionId}`);\n\n\t\t\t\t// Send a test event (optional, for debugging)\n\t\t\t\t// setTimeout(() => sendSSEData(res, { type: 'test', message: 'Test event', sessionId }, 'test'), 1000);\n\n\t\t\t\t// Function to handle tool call events for this session\n\t\t\t\tconst handleToolCall = (toolCall) => {\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t// console.log(`[DEBUG] SSE: Handling tool call event for session ${sessionId}: ${toolCall.name}`); // Noisy\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Store tool call in chat session's display history\n\t\t\t\t\tconst chatInstance = chatSessions.get(sessionId);\n\t\t\t\t\tif (chatInstance && toolCall.status === 'completed') {\n\t\t\t\t\t\t// Only store completed tool calls that users see\n\t\t\t\t\t\tconst displayToolCall = {\n\t\t\t\t\t\t\trole: 'toolCall',\n\t\t\t\t\t\t\tname: toolCall.name,\n\t\t\t\t\t\t\targs: toolCall.args || {},\n\t\t\t\t\t\t\ttimestamp: toolCall.timestamp || new Date().toISOString(),\n\t\t\t\t\t\t\tvisible: true,\n\t\t\t\t\t\t\tdisplayType: 'toolCall'\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!chatInstance.displayHistory) {\n\t\t\t\t\t\t\tchatInstance.displayHistory = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchatInstance.displayHistory.push(displayToolCall);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Also save to persistent storage\n\t\t\t\t\t\tif (globalStorage) {\n\t\t\t\t\t\t\tglobalStorage.saveMessage(sessionId, {\n\t\t\t\t\t\t\t\trole: 'toolCall',\n\t\t\t\t\t\t\t\tcontent: `Tool: ${toolCall.name}\\nArgs: ${JSON.stringify(toolCall.args || {}, null, 2)}`,\n\t\t\t\t\t\t\t\ttimestamp: toolCall.timestamp ? new Date(toolCall.timestamp).getTime() : Date.now(),\n\t\t\t\t\t\t\t\tdisplayType: 'toolCall',\n\t\t\t\t\t\t\t\tvisible: 1,\n\t\t\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\t\t\tname: toolCall.name,\n\t\t\t\t\t\t\t\t\targs: toolCall.args || {}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}).catch(err => {\n\t\t\t\t\t\t\t\tconsole.error('Failed to save tool call to persistent storage:', err);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tconsole.log(`[DEBUG] Stored tool call in display history: ${toolCall.name}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Ensure data is serializable and add timestamp if missing\n\t\t\t\t\tconst serializableCall = {\n\t\t\t\t\t\t...toolCall,\n\t\t\t\t\t\ttimestamp: toolCall.timestamp || new Date().toISOString(),\n\t\t\t\t\t\t_sse_sent_at: new Date().toISOString()\n\t\t\t\t\t};\n\t\t\t\t\tsendSSEData(res, serializableCall, 'toolCall'); // Event type 'toolCall'\n\t\t\t\t};\n\n\t\t\t\t// Register event listener for this specific session\n\t\t\t\tconst eventName = `toolCall:${sessionId}`;\n\t\t\t\t// Remove previous listener for this exact session ID if any (safety measure)\n\t\t\t\tconst existingHandler = sseClients.get(sessionId)?.handler;\n\t\t\t\tif (existingHandler) {\n\t\t\t\t\ttoolCallEmitter.removeListener(eventName, existingHandler);\n\t\t\t\t}\n\n\t\t\t\ttoolCallEmitter.on(eventName, handleToolCall);\n\t\t\t\tif (DEBUG) console.log(`[DEBUG] SSE: Registered listener for ${eventName}`);\n\n\t\t\t\t// Store client and handler for cleanup\n\t\t\t\tsseClients.set(sessionId, { res, handler: handleToolCall });\n\t\t\t\tif (DEBUG) console.log(`[DEBUG] SSE: Client added for session ${sessionId}. Total clients: ${sseClients.size}`);\n\n\t\t\t\t// Handle client disconnect\n\t\t\t\treq.on('close', () => {\n\t\t\t\t\tif (DEBUG) console.log(`[DEBUG] SSE: Client disconnecting: ${sessionId}`);\n\t\t\t\t\ttoolCallEmitter.removeListener(eventName, handleToolCall);\n\t\t\t\t\tsseClients.delete(sessionId);\n\t\t\t\t\tif (DEBUG) console.log(`[DEBUG] SSE: Client removed for session ${sessionId}. Remaining clients: ${sseClients.size}`);\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t// Cancellation endpoint\n\t\t\t'POST /cancel-request': async (req, res) => {\n\t\t\t\thandlePostRequest(req, res, async (body) => {\n\t\t\t\t\tconst { sessionId } = body;\n\t\t\t\t\tif (!sessionId) return sendError(res, 400, 'Missing required parameter: sessionId');\n\n\t\t\t\t\tconst DEBUG = process.env.DEBUG_CHAT === '1';\n\t\t\t\t\tif (DEBUG) console.log(`\\n[DEBUG] ===== Cancel Request for Session: ${sessionId} =====`);\n\n\t\t\t\t\t// 1. Cancel Tool Executions (via probeTool.js)\n\t\t\t\t\tconst toolExecutionsCancelled = cancelToolExecutions(sessionId);\n\n\t\t\t\t\t// 2. Cancel Active Chat Request (via probeChat instance)\n\t\t\t\t\tconst chatInstance = activeChatInstances.get(sessionId);\n\t\t\t\t\tlet chatInstanceAborted = false;\n\t\t\t\t\tif (chatInstance && typeof chatInstance.abort === 'function') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tchatInstance.abort(); // This sets chatInstance.cancelled = true and aborts controller\n\t\t\t\t\t\t\tchatInstanceAborted = true;\n\t\t\t\t\t\t\tif (DEBUG) console.log(`[DEBUG] Aborted chat instance processing for session: ${sessionId}`);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tconsole.error(`Error aborting chat instance for session ${sessionId}:`, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (DEBUG) console.log(`[DEBUG] No active chat instance found in map for session ${sessionId} to abort.`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// 3. Cancel the request tracking entry (via cancelRequest.js - might be redundant if chatInstance.abort works)\n\t\t\t\t\tconst requestCancelled = cancelRequest(sessionId); // This calls the registered abort function\n\n\t\t\t\t\t// Clean up map entry (might be done in finally block of chat endpoint too)\n\t\t\t\t\tactiveChatInstances.delete(sessionId);\n\n\n\t\t\t\t\tconsole.log(`Cancellation processed for session ${sessionId}: Tools=${toolExecutionsCancelled}, Chat=${chatInstanceAborted}, RequestTracking=${requestCancelled}`);\n\n\t\t\t\t\tsendJson(res, 200, {\n\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\tmessage: 'Cancellation request processed',\n\t\t\t\t\t\tdetails: { toolExecutionsCancelled, chatInstanceAborted, requestCancelled },\n\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t// --- Direct API Tool Endpoints (Bypass LLM Loop) ---\n\t\t\t'POST /api/search': async (req, res) => {\n\t\t\t\thandlePostRequest(req, res, async (body) => {\n\t\t\t\t\tconst { query, path, allow_tests, maxResults, maxTokens, sessionId: reqSessionId } = body; // Renamed params\n\t\t\t\t\tif (!query) return sendError(res, 400, 'Missing required parameter: query');\n\n\t\t\t\t\tconst sessionId = reqSessionId || randomUUID(); // Use provided or generate new for direct call\n\t\t\t\t\tconst toolParams = { query, path, allow_tests, maxResults, maxTokens, sessionId };\n\n\t\t\t\t\tawait executeDirectTool(res, directApiTools.search, 'search', toolParams, sessionId);\n\t\t\t\t});\n\t\t\t},\n\t\t\t'POST /api/query': async (req, res) => {\n\t\t\t\thandlePostRequest(req, res, async (body) => {\n\t\t\t\t\tconst { pattern, path, language, allow_tests, sessionId: reqSessionId } = body;\n\t\t\t\t\tif (!pattern) return sendError(res, 400, 'Missing required parameter: pattern');\n\n\t\t\t\t\tconst sessionId = reqSessionId || randomUUID();\n\t\t\t\t\tconst toolParams = { pattern, path, language, allow_tests, sessionId };\n\n\t\t\t\t\tawait executeDirectTool(res, directApiTools.query, 'query', toolParams, sessionId);\n\t\t\t\t});\n\t\t\t},\n\t\t\t'POST /api/extract': async (req, res) => {\n\t\t\t\thandlePostRequest(req, res, async (body) => {\n\t\t\t\t\tconst { file_path, line, end_line, allow_tests, context_lines, format, input_content, sessionId: reqSessionId } = body;\n\t\t\t\t\t// file_path or input_content is required by the underlying tool implementation usually\n\t\t\t\t\tif (!file_path && !input_content) return sendError(res, 400, 'Missing required parameter: file_path or input_content');\n\n\t\t\t\t\tconst sessionId = reqSessionId || randomUUID();\n\t\t\t\t\tconst toolParams = { file_path, line, end_line, allow_tests, context_lines, format, input_content, sessionId };\n\n\t\t\t\t\tawait executeDirectTool(res, directApiTools.extract, 'extract', toolParams, sessionId);\n\t\t\t\t});\n\t\t\t},\n\t\t\t\n\t\t\t// Implement tool endpoint (only available if allowEdit is true)\n\t\t\t'POST /api/implement': async (req, res) => {\n\t\t\t\t// Check if edit mode is enabled\n\t\t\t\tif (!directApiTools.implement) {\n\t\t\t\t\treturn sendError(res, 403, 'Implement tool is not enabled. Start server with --allow-edit to enable.');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\thandlePostRequest(req, res, async (body) => {\n\t\t\t\t\tconst { task, sessionId: reqSessionId } = body;\n\t\t\t\t\tif (!task) return sendError(res, 400, 'Missing required parameter: task');\n\n\t\t\t\t\tconst sessionId = reqSessionId || randomUUID();\n\t\t\t\t\tconst toolParams = { task, sessionId };\n\n\t\t\t\t\tawait executeDirectTool(res, directApiTools.implement, 'implement', toolParams, sessionId);\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t// --- Main Chat Endpoint (Handles the Loop) ---\n\t\t\t'POST /chat': (req, res) => { // This is the route used by the frontend UI\n\t\t\t\thandlePostRequest(req, res, async (requestData) => {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\timages = [], // Array of base64 image URLs\n\t\t\t\t\t\tsessionId: reqSessionId,\n\t\t\t\t\t\tclearHistory,\n\t\t\t\t\t\tapiProvider,\n\t\t\t\t\t\tapiKey,\n\t\t\t\t\t\tapiUrl\n\t\t\t\t\t} = requestData;\n\t\t\t\t\tconst DEBUG = process.env.DEBUG_CHAT === '1';\n\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tconsole.log(`\\n[DEBUG] ===== UI Chat Request =====`);\n\t\t\t\t\t\tconsole.log(`[DEBUG] Request Data:`, { ...requestData, apiKey: requestData.apiKey ? '******' : undefined });\n\t\t\t\t\t}\n\n\t\t\t\t\t// --- Session and Instance Management ---\n\t\t\t\t\tconst chatSessionId = reqSessionId || randomUUID(); // Ensure we always have a session ID\n\t\t\t\t\tif (!reqSessionId && DEBUG) console.log(`[DEBUG] No session ID from UI, generated: ${chatSessionId}`);\n\t\t\t\t\telse if (DEBUG) console.log(`[DEBUG] Using session ID from UI: ${chatSessionId}`);\n\n\t\t\t\t\t// Get or create the chat instance *without* API key overrides here.\n\t\t\t\t\t// API keys from request are ignored for existing sessions to preserve history consistency.\n\t\t\t\t\t// If a *new* session is created AND keys are provided, the ProbeChat constructor *should* handle them.\n\t\t\t\t\t// Extract API credentials from request if available\n\t\t\t\t\tconst apiCredentials = apiKey ? { apiProvider, apiKey, apiUrl } : null;\n\n\t\t\t\t\t// Get or create chat instance with API credentials\n\t\t\t\t\tconst chatInstance = getOrCreateChat(chatSessionId, apiCredentials);\n\n\t\t\t\t\t// Update last activity timestamp\n\t\t\t\t\tchatInstance.lastActivity = Date.now();\n\n\t\t\t\t\t// Check if API keys are needed but missing\n\t\t\t\t\tif (chatInstance.noApiKeysMode) {\n\t\t\t\t\t\tconsole.warn(`[WARN] Chat request for session ${chatSessionId} cannot proceed: No API keys configured.`);\n\t\t\t\t\t\treturn sendError(res, 503, 'Chat service unavailable: API key not configured on server.');\n\t\t\t\t\t}\n\n\t\t\t\t\t// Register this request as active for cancellation\n\t\t\t\t\tregisterRequest(chatSessionId, { abort: () => chatInstance.abort() });\n\t\t\t\t\tif (DEBUG) console.log(`[DEBUG] Registered cancellable request for session: ${chatSessionId}`);\n\t\t\t\t\tactiveChatInstances.set(chatSessionId, chatInstance); // Store for direct access during cancellation\n\n\t\t\t\t\t// --- Handle Clear History ---\n\t\t\t\t\tif (message === '__clear_history__' || clearHistory) {\n\t\t\t\t\t\tconsole.log(`Clearing chat history for session: ${chatSessionId}`);\n\t\t\t\t\t\tconst newSessionId = chatInstance.clearHistory(); // clearHistory now returns the *new* session ID\n\t\t\t\t\t\t// Remove old session state\n\t\t\t\t\t\tclearRequest(chatSessionId);\n\t\t\t\t\t\tactiveChatInstances.delete(chatSessionId);\n\t\t\t\t\t\tclearToolExecutionData(chatSessionId);\n\t\t\t\t\t\tchatSessions.delete(chatSessionId); // Remove old instance from map\n\t\t\t\t\t\t// We don't create the *new* instance here, it will be created on the *next* message request\n\n\t\t\t\t\t\t// Create a new empty token usage object for the cleared history\n\t\t\t\t\t\tconst emptyTokenUsage = {\n\t\t\t\t\t\t\tcontextWindow: 0,\n\t\t\t\t\t\t\tcurrent: {\n\t\t\t\t\t\t\t\trequest: 0,\n\t\t\t\t\t\t\t\tresponse: 0,\n\t\t\t\t\t\t\t\ttotal: 0,\n\t\t\t\t\t\t\t\tcacheRead: 0,\n\t\t\t\t\t\t\t\tcacheWrite: 0,\n\t\t\t\t\t\t\t\tcacheTotal: 0\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttotal: {\n\t\t\t\t\t\t\t\trequest: 0,\n\t\t\t\t\t\t\t\tresponse: 0,\n\t\t\t\t\t\t\t\ttotal: 0,\n\t\t\t\t\t\t\t\tcacheRead: 0,\n\t\t\t\t\t\t\t\tcacheWrite: 0,\n\t\t\t\t\t\t\t\tcacheTotal: 0\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tsendJson(res, 200, {\n\t\t\t\t\t\t\tresponse: 'Chat history cleared',\n\t\t\t\t\t\t\ttokenUsage: emptyTokenUsage, // Include empty token usage data\n\t\t\t\t\t\t\tnewSessionId: newSessionId, // Inform UI about the new ID\n\t\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn; // Stop processing\n\t\t\t\t\t}\n\n\t\t\t\t\t// --- Execute Chat Loop (Non-Streaming Response) ---\n\t\t\t\t\t// The loop is inside chatInstance.chat now.\n\t\t\t\t\t// We expect the *final* result string back.\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Pass API credentials to the chat method if provided\n\t\t\t\t\t\tconst apiCredentials = apiKey ? { apiProvider, apiKey, apiUrl } : null;\n\t\t\t\t\t\tconst result = await chatInstance.chat(message, chatSessionId, apiCredentials, images); // Pass session ID, API credentials, and images\n\n\t\t\t\t\t\t// Check if cancelled *during* the chat call (ProbeChat throws error)\n\t\t\t\t\t\t// Error handled in catch block\n\n\t\t\t\t\t\t// Handle the new structured response format\n\t\t\t\t\t\tlet responseText;\n\t\t\t\t\t\tlet tokenUsage;\n\n\t\t\t\t\t\tif (result && typeof result === 'object' && 'response' in result) {\n\t\t\t\t\t\t\t// New format: { response: string, tokenUsage: object }\n\t\t\t\t\t\t\tresponseText = result.response;\n\t\t\t\t\t\t\ttokenUsage = result.tokenUsage;\n\n\t\t\t\t\t\t\tif (process.env.DEBUG_CHAT === '1') {\n\t\t\t\t\t\t\t\tconsole.log(`[DEBUG] Received structured response with token usage data`);\n\t\t\t\t\t\t\t\tconsole.log(`[DEBUG] Context window size: ${tokenUsage.contextWindow}`);\n\t\t\t\t\t\t\t\tconsole.log(`[DEBUG] Cache metrics - Read: ${tokenUsage.current.cacheRead}, Write: ${tokenUsage.current.cacheWrite}`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Legacy format: string response\n\t\t\t\t\t\t\tresponseText = result;\n\t\t\t\t\t\t\ttokenUsage = chatInstance.getTokenUsage(); // Get token usage separately\n\n\t\t\t\t\t\t\tif (process.env.DEBUG_CHAT === '1') {\n\t\t\t\t\t\t\t\tconsole.log(`[DEBUG] Received legacy response format, fetched token usage separately`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create the response object with the response text and token usage data\n\t\t\t\t\t\tconst responseObject = {\n\t\t\t\t\t\t\tresponse: responseText,\n\t\t\t\t\t\t\ttokenUsage: tokenUsage,\n\t\t\t\t\t\t\tsessionId: chatSessionId,\n\t\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Send the response with token usage in both the body and header\n\t\t\t\t\t\tsendJson(res, 200, responseObject, { 'X-Token-Usage': JSON.stringify(tokenUsage) });\n\n\t\t\t\t\t\tconsole.log(`Finished chat request for session: ${chatSessionId}`);\n\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t// Check if the error is actually a structured response with token usage\n\t\t\t\t\t\tlet errorResponse = error;\n\t\t\t\t\t\tlet tokenUsage;\n\n\t\t\t\t\t\tif (error && typeof error === 'object' && error.response && error.tokenUsage) {\n\t\t\t\t\t\t\t// This is a structured error response from probeChat\n\t\t\t\t\t\t\terrorResponse = error.response;\n\t\t\t\t\t\t\ttokenUsage = error.tokenUsage;\n\n\t\t\t\t\t\t\tif (process.env.DEBUG_CHAT === '1') {\n\t\t\t\t\t\t\t\tconsole.log(`[DEBUG] Received structured error response with token usage data`);\n\t\t\t\t\t\t\t\tconsole.log(`[DEBUG] Context window size: ${tokenUsage.contextWindow}`);\n\t\t\t\t\t\t\t\tconsole.log(`[DEBUG] Cache metrics - Read: ${tokenUsage.current.cacheRead}, Write: ${tokenUsage.current.cacheWrite}`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Get token usage separately for regular errors\n\n\t\t\t\t\t\t\t// First update the tokenCounter's history with the chat history\n\t\t\t\t\t\t\tif (chatInstance.tokenCounter && typeof chatInstance.tokenCounter.updateHistory === 'function' &&\n\t\t\t\t\t\t\t\tchatInstance.history) {\n\t\t\t\t\t\t\t\tchatInstance.tokenCounter.updateHistory(chatInstance.history);\n\t\t\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\t\t\tconsole.log(`[DEBUG] Updated tokenCounter history with ${chatInstance.history.length} messages for error case`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Force recalculation of context window size\n\t\t\t\t\t\t\tif (chatInstance.tokenCounter && typeof chatInstance.tokenCounter.calculateContextSize === 'function') {\n\t\t\t\t\t\t\t\tchatInstance.tokenCounter.calculateContextSize(chatInstance.history);\n\t\t\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\t\t\tconsole.log(`[DEBUG] Forced recalculation of context window size for error case`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get updated token usage after history update and recalculation\n\t\t\t\t\t\t\ttokenUsage = chatInstance.getTokenUsage();\n\n\t\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\t\tconsole.log(`[DEBUG] Error case - Final context window size: ${tokenUsage.contextWindow}`);\n\t\t\t\t\t\t\t\tconsole.log(`[DEBUG] Error case - Cache metrics - Read: ${tokenUsage.current.cacheRead}, Write: ${tokenUsage.current.cacheWrite}`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Handle errors, including cancellation\n\t\t\t\t\t\tif (errorResponse.message && errorResponse.message.includes('cancelled') ||\n\t\t\t\t\t\t\t(typeof errorResponse === 'string' && errorResponse.includes('cancelled'))) {\n\t\t\t\t\t\t\tconsole.log(`Chat request processing was cancelled for session: ${chatSessionId}`);\n\t\t\t\t\t\t\t// Send structured error response with token usage\n\t\t\t\t\t\t\tsendJson(res, 499, {\n\t\t\t\t\t\t\t\terror: 'Request cancelled by user',\n\t\t\t\t\t\t\t\ttokenUsage: tokenUsage,\n\t\t\t\t\t\t\t\tsessionId: chatSessionId,\n\t\t\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t\t\t}); // 499 Client Closed Request\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error(`Error processing chat for session ${chatSessionId}:`, error);\n\t\t\t\t\t\t\t// Send structured error response with token usage\n\t\t\t\t\t\t\tsendJson(res, 500, {\n\t\t\t\t\t\t\t\terror: `Chat processing error: ${typeof errorResponse === 'string' ? errorResponse : errorResponse.message || 'Unknown error'}`,\n\t\t\t\t\t\t\t\ttokenUsage: tokenUsage,\n\t\t\t\t\t\t\t\tsessionId: chatSessionId,\n\t\t\t\t\t\t\t\ttimestamp: new Date().toISOString()\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\t// Cleanup regardless of success, error, or cancellation\n\t\t\t\t\t\tclearRequest(chatSessionId);\n\t\t\t\t\t\tactiveChatInstances.delete(chatSessionId);\n\t\t\t\t\t\t// Don't clear tool execution data here, it might be needed if user retries\n\t\t\t\t\t\t// clearToolExecutionData(chatSessionId);\n\t\t\t\t\t\tif (DEBUG) console.log(`[DEBUG] Cleaned up active request tracking for session: ${chatSessionId}`);\n\t\t\t\t\t}\n\t\t\t\t}); // End handlePostRequest for /chat\n\t\t\t} // End /chat route\n\t\t}; // End routes object\n\n\t\t// --- Request Routing ---\n\t\tconst parsedUrl = new URL(req.url, `http://${req.headers.host}`);\n\t\tconst routeKey = `${req.method} ${parsedUrl.pathname}`;\n\t\tlet handler = routes[routeKey];\n\n\t\t// Handle dynamic routes if no exact match found\n\t\tif (!handler) {\n\t\t\t// Check for /chat/:sessionId pattern\n\t\t\tif (req.method === 'GET' && parsedUrl.pathname.match(/^\\/chat\\/[^/?]+$/)) {\n\t\t\t\thandler = routes['GET /chat/:sessionId'];\n\t\t\t}\n\t\t\t// Check for /api/session/:sessionId/history pattern\n\t\t\telse if (req.method === 'GET' && parsedUrl.pathname.match(/^\\/api\\/session\\/[^/?]+\\/history$/)) {\n\t\t\t\thandler = routes['GET /api/session/:sessionId/history'];\n\t\t\t}\n\t\t}\n\n\t\tif (handler) {\n\t\t\t// Skip auth for specific public routes\n\t\t\tconst publicRoutes = ['GET /openapi.yaml', 'GET /api/tool-events', 'GET /logo.png', 'GET /', 'GET /folders', 'OPTIONS']; // Add OPTIONS\n\t\t\tconst isPublicRoute = publicRoutes.includes(routeKey) || req.method === 'OPTIONS' || \n\t\t\t\t\t\t\t\t  parsedUrl.pathname.match(/^\\/chat\\/[^/?]+$/) || // Chat sessions are public\n\t\t\t\t\t\t\t\t  parsedUrl.pathname.match(/^\\/api\\/session\\/[^/?]+\\/history$/); // History API is public\n\t\t\t\n\t\t\tif (isPublicRoute) {\n\t\t\t\thandler(req, res);\n\t\t\t} else {\n\t\t\t\tprocessRequest(handler); // Apply auth middleware\n\t\t\t}\n\t\t} else {\n\t\t\t// No route match, return 404\n\t\t\tsendError(res, 404, 'Not Found');\n\t\t}\n\t}); // End createServer\n\n\t// Start the server\n\tconst PORT = process.env.PORT || 8080;\n\tserver.listen(PORT, () => {\n\t\tconsole.log(`Probe Web Interface v${version}`);\n\t\tconsole.log(`Server running on http://localhost:${PORT}`);\n\t\tconsole.log(`Environment: ${process.env.NODE_ENV || 'development'}`);\n\t\tif (noApiKeysMode) {\n\t\t\tconsole.log('*** Running in NO API KEYS mode. Chat functionality disabled. ***');\n\t\t}\n\t});\n}\n\n\n// --- Helper Functions ---\n\nfunction handleOptions(res) {\n\tres.writeHead(200, {\n\t\t'Access-Control-Allow-Origin': '*', // Or specific origin\n\t\t'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n\t\t'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Session-ID', // Add any custom headers needed\n\t\t'Access-Control-Max-Age': '86400' // 24 hours\n\t});\n\tres.end();\n}\n\nfunction sendJson(res, statusCode, data, headers = {}) {\n\tif (res.headersSent) return;\n\tres.writeHead(statusCode, {\n\t\t'Content-Type': 'application/json',\n\t\t'Access-Control-Allow-Origin': '*', // Adjust as needed\n\t\t'Access-Control-Expose-Headers': 'X-Token-Usage', // Expose custom headers\n\t\t...headers\n\t});\n\tres.end(JSON.stringify(data));\n}\n\nfunction sendError(res, statusCode, message) {\n\tif (res.headersSent) return;\n\tconsole.error(`Sending error (${statusCode}): ${message}`);\n\tres.writeHead(statusCode, {\n\t\t'Content-Type': 'application/json',\n\t\t'Access-Control-Allow-Origin': '*'\n\t});\n\tres.end(JSON.stringify({ error: message, status: statusCode }));\n}\n\nfunction serveStatic(res, filePath, contentType) {\n\tif (res.headersSent) return;\n\tif (existsSync(filePath)) {\n\t\tres.writeHead(200, { 'Content-Type': contentType });\n\t\tconst fileData = readFileSync(filePath);\n\t\tres.end(fileData);\n\t} else {\n\t\tsendError(res, 404, `${contentType} not found`);\n\t}\n}\n\nfunction serveHtml(res, filePath, bodyAttributes = {}) {\n\tif (res.headersSent) return;\n\tif (existsSync(filePath)) {\n\t\tres.writeHead(200, { 'Content-Type': 'text/html' });\n\t\tlet html = readFileSync(filePath, 'utf8');\n\t\t// Inject attributes into body tag\n\t\tconst attributesString = Object.entries(bodyAttributes)\n\t\t\t.map(([key, value]) => `${key}=\"${String(value).replace(/\"/g, '\"')}\"`)\n\t\t\t.join(' ');\n\t\tif (attributesString) {\n\t\t\thtml = html.replace('<body', `<body ${attributesString}`);\n\t\t}\n\t\tres.end(html);\n\t} else {\n\t\tsendError(res, 404, 'HTML file not found');\n\t}\n}\n\n\nfunction getSessionIdFromUrl(req) {\n\ttry {\n\t\tconst url = new URL(req.url, `http://${req.headers.host}`);\n\t\treturn url.searchParams.get('sessionId');\n\t} catch (error) {\n\t\tconsole.error(`Error parsing URL for sessionId: ${error.message}`);\n\t\t// Fallback: manual parsing (less reliable)\n\t\tconst match = req.url.match(/[?&]sessionId=([^&]+)/);\n\t\treturn match ? match[1] : null;\n\t}\n}\n\nasync function handlePostRequest(req, res, callback) {\n\tlet body = '';\n\treq.on('data', chunk => body += chunk);\n\treq.on('end', async () => {\n\t\ttry {\n\t\t\tconst parsedBody = JSON.parse(body);\n\t\t\tawait callback(parsedBody);\n\t\t} catch (error) {\n\t\t\tif (error instanceof SyntaxError) {\n\t\t\t\tsendError(res, 400, 'Invalid JSON in request body');\n\t\t\t} else {\n\t\t\t\tconsole.error('Error handling POST request:', error);\n\t\t\t\tsendError(res, 500, `Internal Server Error: ${error.message}`);\n\t\t\t}\n\t\t}\n\t});\n\treq.on('error', (err) => {\n\t\tconsole.error('Request error:', err);\n\t\tsendError(res, 500, 'Request error');\n\t});\n}\n\nasync function executeDirectTool(res, toolInstance, toolName, toolParams, sessionId) {\n\tconst DEBUG = process.env.DEBUG_CHAT === '1';\n\tif (DEBUG) {\n\t\tconsole.log(`\\n[DEBUG] ===== Direct API Tool Call: ${toolName} =====`);\n\t\tconsole.log(`[DEBUG] Session ID: ${sessionId}`);\n\t\tconsole.log(`[DEBUG] Params:`, toolParams);\n\t}\n\ttry {\n\t\t// Execute the tool instance directly (it handles events/cancellation)\n\t\tconst result = await toolInstance.execute(toolParams);\n\t\tsendJson(res, 200, { results: result, timestamp: new Date().toISOString() });\n\t} catch (error) {\n\t\tconsole.error(`Error executing direct tool ${toolName}:`, error);\n\t\tlet statusCode = 500;\n\t\tlet errorMessage = `Error executing ${toolName}`;\n\t\tif (error.message.includes('cancelled')) {\n\t\t\tstatusCode = 499; // Client Closed Request\n\t\t\terrorMessage = 'Operation cancelled';\n\t\t} else if (error.code === 'ENOENT') {\n\t\t\tstatusCode = 404; errorMessage = 'File or path not found';\n\t\t} else if (error.code === 'EACCES') {\n\t\t\tstatusCode = 403; errorMessage = 'Permission denied';\n\t\t}\n\t\t// Add more specific error handling if needed\n\t\tsendError(res, statusCode, `${errorMessage}: ${error.message}`);\n\t}\n}\n\nfunction extractSessionIdFromPath(url) {\n\t// Extract session ID from URLs like /chat/session-id\n\tconst match = url.match(/^\\/chat\\/([^/?]+)/);\n\treturn match ? match[1] : null;\n}\n\nfunction isValidUUID(str) {\n\t// Basic UUID validation (any version, with or without hyphens)\n\tconst uuidRegex = /^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$/i;\n\treturn uuidRegex.test(str);\n}\n\nfunction extractSessionIdFromHistoryPath(url) {\n\t// Extract session ID from URLs like /api/session/session-id/history\n\tconst match = url.match(/^\\/api\\/session\\/([^/?]+)\\/history/);\n\treturn match ? match[1] : null;\n}\n\nfunction extractContentFromMessage(content) {\n\t// Handle different XML patterns used by the assistant and clean user messages\n\tconst patterns = [\n\t\t/<task>([\\s\\S]*?)<\\/task>/,\n\t\t/<attempt_completion>\\s*<result>([\\s\\S]*?)<\\/result>\\s*<\\/attempt_completion>/,\n\t\t/<result>([\\s\\S]*?)<\\/result>/\n\t];\n\t\n\tfor (const pattern of patterns) {\n\t\tconst match = content.match(pattern);\n\t\tif (match) {\n\t\t\treturn match[1].trim();\n\t\t}\n\t}\n\t\n\t// If no XML pattern matches, return the content as-is\n\treturn content.trim();\n}\n\nfunction getRelativeTime(timestamp) {\n\tconst now = Date.now();\n\tconst diff = now - timestamp;\n\t\n\tconst seconds = Math.floor(diff / 1000);\n\tconst minutes = Math.floor(seconds / 60);\n\tconst hours = Math.floor(minutes / 60);\n\tconst days = Math.floor(hours / 24);\n\t\n\tif (days > 0) return `${days}d ago`;\n\tif (hours > 0) return `${hours}h ago`;\n\tif (minutes > 0) return `${minutes}m ago`;\n\treturn 'just now';\n}\n", "#!/usr/bin/env node\n\n// Check for non-interactive mode flag early, before any imports\n// This ensures the environment variable is set before any module code runs\nif (process.argv.includes('-m') || process.argv.includes('--message')) {\n  process.env.PROBE_NON_INTERACTIVE = '1';\n}\n\n// Check if stdin is connected to a pipe (not a TTY)\n// This allows for usage like: echo \"query\" | probe-chat\nif (!process.stdin.isTTY) {\n  process.env.PROBE_NON_INTERACTIVE = '1';\n  process.env.PROBE_STDIN_PIPED = '1';\n}\n\nimport 'dotenv/config';\nimport inquirer from 'inquirer';\nimport chalk from 'chalk';\nimport ora from 'ora';\nimport { Command } from 'commander';\nimport { existsSync, realpathSync, readFileSync } from 'fs';\nimport { resolve, dirname, join } from 'path';\nimport { fileURLToPath } from 'url';\nimport { randomUUID } from 'crypto';\nimport { ProbeChat } from './probeChat.js';\nimport { TokenUsageDisplay } from './tokenUsageDisplay.js';\nimport { DEFAULT_SYSTEM_MESSAGE } from '@buger/probe';\n\n/**\n * Main function that runs the Probe Chat CLI or web interface\n */\nexport function main() {\n  // Get the directory name of the current module\n  const __dirname = dirname(fileURLToPath(import.meta.url));\n  const packageJsonPath = join(__dirname, 'package.json');\n\n  // Read package.json to get the version\n  let version = '1.0.0'; // Default fallback version\n  try {\n    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));\n    version = packageJson.version || version;\n  } catch (error) {\n    // Non-critical, suppress in non-interactive unless debug\n    // console.warn(`Warning: Could not read version from package.json: ${error.message}`);\n  }\n\n  // Create a new instance of the program\n  const program = new Command();\n\n  program\n    .name('probe-chat')\n    .description('CLI chat interface for Probe code search')\n    .version(version)\n    .option('-d, --debug', 'Enable debug mode')\n    .option('--model-name <model>', 'Specify the model to use') // Renamed from --model\n    .option('-f, --force-provider <provider>', 'Force a specific provider (options: anthropic, openai, google)')\n    .option('-w, --web', 'Run in web interface mode')\n    .option('-p, --port <port>', 'Port to run web server on (default: 8080)')\n    .option('-m, --message <message>', 'Send a single message and exit (non-interactive mode)')\n    .option('-s, --session-id <sessionId>', 'Specify a session ID for the chat (optional)')\n    .option('--json', 'Output the response as JSON in non-interactive mode')\n    .option('--max-iterations <number>', 'Maximum number of tool iterations allowed (default: 30)')\n    .option('--prompt <value>', 'Use a custom prompt (values: architect, code-review, support, path to a file, or arbitrary string)')\n    .option('--allow-edit', 'Enable the implement tool for editing files')\n    .option('--implement-tool-backend <backend>', 'Choose implementation tool backend (aider, claude-code)')\n    .option('--implement-tool-timeout <ms>', 'Implementation tool timeout in milliseconds')\n    .option('--implement-tool-config <path>', 'Path to implementation tool configuration file')\n    .option('--implement-tool-list-backends', 'List available implementation tool backends')\n    .option('--implement-tool-backend-info <backend>', 'Show information about a specific implementation tool backend')\n    .option('--trace-file [path]', 'Enable tracing to file (default: ./traces.jsonl)')\n    .option('--trace-remote [endpoint]', 'Enable tracing to remote endpoint (default: http://localhost:4318/v1/traces)')\n    .option('--trace-console', 'Enable tracing to console (for debugging)')\n    .argument('[path]', 'Path to the codebase to search (overrides ALLOWED_FOLDERS)')\n    .parse(process.argv);\n\n  const options = program.opts();\n  const pathArg = program.args[0];\n\n  // --- Logging Configuration ---\n  const isPipedInput = process.env.PROBE_STDIN_PIPED === '1';\n  const isNonInteractive = !!options.message || isPipedInput;\n\n  // Environment variable is already set at the top of the file\n  // This is just for code clarity\n  if (isNonInteractive && process.env.PROBE_NON_INTERACTIVE !== '1') {\n    process.env.PROBE_NON_INTERACTIVE = '1';\n  }\n\n  // Raw logging for non-interactive output\n  const rawLog = (...args) => console.log(...args);\n  const rawError = (...args) => console.error(...args);\n\n  // Disable color/formatting in raw non-interactive mode\n  if (isNonInteractive && !options.json && !options.debug) {\n    chalk.level = 0;\n  }\n\n  // Conditional logging helpers\n  const logInfo = (...args) => {\n    if (!isNonInteractive || options.debug) {\n      console.log(...args);\n    }\n  };\n  const logWarn = (...args) => {\n    if (!isNonInteractive || options.debug) {\n      console.warn(...args);\n    } else if (isNonInteractive) {\n      // Optionally log warnings to stderr in non-interactive mode even without debug\n      // rawError('Warning:', ...args);\n    }\n  };\n  const logError = (...args) => {\n    // Always log errors, but use rawError in non-interactive mode\n    if (isNonInteractive) {\n      rawError('Error:', ...args); // Prefix with Error: for clarity on stderr\n    } else {\n      console.error(...args);\n    }\n  };\n  // --- End Logging Configuration ---\n\n  if (options.debug) {\n    process.env.DEBUG_CHAT = '1';\n    logInfo(chalk.yellow('Debug mode enabled'));\n  }\n  if (options.modelName) { // Use renamed option\n    process.env.MODEL_NAME = options.modelName;\n    logInfo(chalk.blue(`Using model: ${options.modelName}`));\n  }\n  if (options.forceProvider) {\n    const provider = options.forceProvider.toLowerCase();\n    if (!['anthropic', 'openai', 'google'].includes(provider)) {\n      logError(chalk.red(`Invalid provider \"${provider}\". Must be one of: anthropic, openai, google`));\n      process.exit(1);\n    }\n    process.env.FORCE_PROVIDER = provider;\n    logInfo(chalk.blue(`Forcing provider: ${provider}`));\n  }\n\n  // Set MAX_TOOL_ITERATIONS from command line if provided\n  if (options.maxIterations) {\n    const maxIterations = parseInt(options.maxIterations, 10);\n    if (isNaN(maxIterations) || maxIterations <= 0) {\n      logError(chalk.red(`Invalid max iterations value: ${options.maxIterations}. Must be a positive number.`));\n      process.exit(1);\n    }\n    process.env.MAX_TOOL_ITERATIONS = maxIterations.toString();\n    logInfo(chalk.blue(`Setting maximum tool iterations to: ${maxIterations}`));\n  }\n\n  // Handle --implement-tool-list-backends option\n  if (options.implementToolListBackends) {\n    (async () => {\n      const { listBackendNames, getBackendMetadata } = await import('./implement/backends/registry.js');\n      const backends = listBackendNames();\n      \n      console.log('\\nAvailable implementation tool backends:');\n      for (const backend of backends) {\n        const metadata = getBackendMetadata(backend);\n        console.log(`\\n  ${chalk.bold(backend)} - ${metadata.description}`);\n        console.log(`    Version: ${metadata.version}`);\n        console.log(`    Languages: ${metadata.capabilities.supportsLanguages.join(', ')}`);\n      }\n      process.exit(0);\n    })();\n  }\n\n  // Handle --implement-tool-backend-info option\n  if (options.implementToolBackendInfo) {\n    (async () => {\n      const { getBackendMetadata } = await import('./implement/backends/registry.js');\n      const metadata = getBackendMetadata(options.implementToolBackendInfo);\n      \n      if (!metadata) {\n        console.error(`Backend '${options.implementToolBackendInfo}' not found`);\n        process.exit(1);\n      }\n      \n      console.log(`\\n${chalk.bold('Backend Information: ' + options.implementToolBackendInfo)}`);\n      console.log(`\\nDescription: ${metadata.description}`);\n      console.log(`Version: ${metadata.version}`);\n      console.log(`\\nCapabilities:`);\n      console.log(`  Languages: ${metadata.capabilities.supportsLanguages.join(', ')}`);\n      console.log(`  Streaming: ${metadata.capabilities.supportsStreaming ? '\u2713' : '\u2717'}`);\n      console.log(`  Direct File Edit: ${metadata.capabilities.supportsDirectFileEdit ? '\u2713' : '\u2717'}`);\n      console.log(`  Test Generation: ${metadata.capabilities.supportsTestGeneration ? '\u2713' : '\u2717'}`);\n      console.log(`  Plan Generation: ${metadata.capabilities.supportsPlanGeneration ? '\u2713' : '\u2717'}`);\n      console.log(`  Max Sessions: ${metadata.capabilities.maxConcurrentSessions}`);\n      console.log(`\\nRequired Dependencies:`);\n      for (const dep of metadata.dependencies) {\n        console.log(`  - ${dep.name} (${dep.type}): ${dep.description}`);\n        if (dep.installCommand) {\n          console.log(`    Install: ${dep.installCommand}`);\n        }\n      }\n      process.exit(0);\n    })();\n  }\n\n  // Set ALLOW_EDIT from command line if provided\n  if (options.allowEdit) {\n    process.env.ALLOW_EDIT = '1';\n    logInfo(chalk.blue(`Enabling implement tool with --allow-edit flag`));\n  }\n\n  // Set implementation tool backend options\n  if (options.implementToolBackend) {\n    process.env.IMPLEMENT_TOOL_BACKEND = options.implementToolBackend;\n    logInfo(chalk.blue(`Using implementation tool backend: ${options.implementToolBackend}`));\n  }\n  \n  if (options.implementToolTimeout) {\n    process.env.IMPLEMENT_TOOL_TIMEOUT = options.implementToolTimeout;\n    logInfo(chalk.blue(`Implementation tool timeout: ${options.implementToolTimeout}ms`));\n  }\n  \n  if (options.implementToolConfig) {\n    process.env.IMPLEMENT_TOOL_CONFIG_PATH = options.implementToolConfig;\n    logInfo(chalk.blue(`Using implementation tool config: ${options.implementToolConfig}`));\n  }\n\n  // Set telemetry options from command line if provided\n  if (options.traceFile !== undefined) {\n    process.env.OTEL_ENABLE_FILE = 'true';\n    process.env.OTEL_FILE_PATH = options.traceFile || './traces.jsonl';\n    logInfo(chalk.blue(`Enabling file tracing to: ${process.env.OTEL_FILE_PATH}`));\n  }\n  \n  if (options.traceRemote !== undefined) {\n    process.env.OTEL_ENABLE_REMOTE = 'true';\n    process.env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT = options.traceRemote || 'http://localhost:4318/v1/traces';\n    logInfo(chalk.blue(`Enabling remote tracing to: ${process.env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT}`));\n  }\n  \n  if (options.traceConsole) {\n    process.env.OTEL_ENABLE_CONSOLE = 'true';\n    logInfo(chalk.blue(`Enabling console tracing`));\n  }\n\n\n  // Handle custom prompt if provided\n  let customPrompt = null;\n  if (options.prompt) {\n    // Check if it's one of the predefined prompts\n    const predefinedPrompts = ['architect', 'code-review', 'support', 'engineer'];\n    if (predefinedPrompts.includes(options.prompt)) {\n      process.env.PROMPT_TYPE = options.prompt;\n      logInfo(chalk.blue(`Using predefined prompt: ${options.prompt}`));\n    } else {\n      // Check if it's a file path\n      try {\n        const promptPath = resolve(options.prompt);\n        if (existsSync(promptPath)) {\n          customPrompt = readFileSync(promptPath, 'utf8');\n          process.env.CUSTOM_PROMPT = customPrompt;\n          logInfo(chalk.blue(`Loaded custom prompt from file: ${promptPath}`));\n        } else {\n          // Not a predefined prompt or existing file, treat as a direct string prompt\n          customPrompt = options.prompt;\n          process.env.CUSTOM_PROMPT = customPrompt;\n          logInfo(chalk.blue(`Using custom prompt string`));\n        }\n      } catch (error) {\n        // If there's an error resolving the path, treat as a direct string prompt\n        customPrompt = options.prompt;\n        process.env.CUSTOM_PROMPT = customPrompt;\n        logInfo(chalk.blue(`Using custom prompt string`));\n      }\n    }\n  }\n\n  // Parse and validate allowed folders from environment variable\n  const allowedFolders = process.env.ALLOWED_FOLDERS\n    ? process.env.ALLOWED_FOLDERS.split(',').map(folder => folder.trim()).filter(Boolean)\n    : [];\n\n  // Resolve path argument to override ALLOWED_FOLDERS\n  if (pathArg) {\n    const resolvedPath = resolve(pathArg);\n    if (existsSync(resolvedPath)) {\n      const realPath = realpathSync(resolvedPath);\n      process.env.ALLOWED_FOLDERS = realPath;\n      logInfo(chalk.blue(`Using codebase path: ${realPath}`));\n      // Clear allowedFolders if pathArg overrides it\n      allowedFolders.length = 0;\n      allowedFolders.push(realPath);\n    } else {\n      logError(chalk.red(`Path does not exist: ${resolvedPath}`));\n      process.exit(1);\n    }\n  } else {\n    // Log allowed folders only if interactive or debug\n    logInfo('Configured search folders:');\n    for (const folder of allowedFolders) {\n      const exists = existsSync(folder);\n      logInfo(`- ${folder} ${exists ? '\u2713' : '\u2717 (not found)'}`);\n      if (!exists) {\n        logWarn(chalk.yellow(`Warning: Folder \"${folder}\" does not exist or is not accessible`));\n      }\n    }\n    if (allowedFolders.length === 0 && !isNonInteractive) { // Only warn if interactive\n      logWarn(chalk.yellow('No folders configured. Set ALLOWED_FOLDERS in .env file or provide a path argument.'));\n    }\n  }\n\n\n  // Set port for web server if specified\n  if (options.port) {\n    process.env.PORT = options.port;\n  }\n\n  // Check for API keys\n  const anthropicApiKey = process.env.ANTHROPIC_API_KEY;\n  const openaiApiKey = process.env.OPENAI_API_KEY;\n  const googleApiKey = process.env.GOOGLE_API_KEY;\n  const hasApiKeys = !!(anthropicApiKey || openaiApiKey || googleApiKey);\n\n  // --- Non-Interactive Mode ---\n  if (isNonInteractive) {\n    if (!hasApiKeys) {\n      logError(chalk.red('No API key provided. Please set ANTHROPIC_API_KEY, OPENAI_API_KEY, or GOOGLE_API_KEY environment variable.'));\n      process.exit(1);\n    }\n\n    let chat;\n    try {\n      // Pass session ID if provided, ProbeChat generates one otherwise\n      chat = new ProbeChat({\n        sessionId: options.sessionId,\n        isNonInteractive: true,\n        customPrompt: customPrompt,\n        promptType: options.prompt && ['architect', 'code-review', 'support', 'engineer'].includes(options.prompt) ? options.prompt : null,\n        allowEdit: options.allowEdit\n      });\n      // Model/Provider info is logged via logInfo above if debug enabled\n      logInfo(chalk.blue(`Using Session ID: ${chat.getSessionId()}`)); // Log the actual session ID being used\n    } catch (error) {\n      logError(chalk.red(`Initializing chat failed: ${error.message}`));\n      process.exit(1);\n    }\n\n    // Function to read from stdin\n    const readFromStdin = () => {\n      return new Promise((resolve) => {\n        let data = '';\n        process.stdin.on('data', (chunk) => {\n          data += chunk;\n        });\n        process.stdin.on('end', () => {\n          resolve(data.trim());\n        });\n      });\n    };\n\n    // Async function to handle the single chat request\n    const runNonInteractiveChat = async () => {\n      try {\n        // Get message from command line argument or stdin\n        let message = options.message;\n\n        // If no message argument but stdin is piped, read from stdin\n        if (!message && isPipedInput) {\n          logInfo('Reading message from stdin...'); // Log only if debug\n          message = await readFromStdin();\n        }\n\n        if (!message) {\n          logError('No message provided. Use --message option or pipe input to stdin.');\n          process.exit(1);\n        }\n\n        logInfo('Sending message...'); // Log only if debug\n        const result = await chat.chat(message, chat.getSessionId()); // Use the chat's current session ID\n\n        if (result && typeof result === 'object' && result.response !== undefined) {\n          if (options.json) {\n            const outputData = {\n              response: result.response,\n              sessionId: chat.getSessionId(),\n              tokenUsage: result.tokenUsage || null // Include usage if available\n            };\n            // Output JSON to stdout\n            rawLog(JSON.stringify(outputData, null, 2));\n          } else {\n            // Output raw response text to stdout\n            rawLog(result.response);\n          }\n          process.exit(0); // Success\n        } else if (typeof result === 'string') { // Handle simple string responses (e.g., cancellation message)\n          if (options.json) {\n            rawLog(JSON.stringify({ response: result, sessionId: chat.getSessionId(), tokenUsage: null }, null, 2));\n          } else {\n            rawLog(result);\n          }\n          process.exit(0); // Exit cleanly\n        }\n        else {\n          logError('Received an unexpected or empty response structure from chat.');\n          if (options.json) {\n            rawError(JSON.stringify({ error: 'Unexpected response structure', response: result, sessionId: chat.getSessionId() }, null, 2));\n          }\n          process.exit(1); // Error exit code\n        }\n      } catch (error) {\n        logError(`Chat request failed: ${error.message}`);\n        if (options.json) {\n          // Output JSON error to stderr\n          rawError(JSON.stringify({ error: error.message, sessionId: chat.getSessionId() }, null, 2));\n        }\n        process.exit(1); // Error exit code\n      }\n    };\n\n    runNonInteractiveChat();\n    return; // Exit main function, prevent interactive/web mode\n  }\n  // --- End Non-Interactive Mode ---\n\n\n  // --- Web Mode ---\n  if (options.web) {\n    if (!hasApiKeys) {\n      // Use logWarn for web mode warning\n      logWarn(chalk.yellow('Warning: No API key provided. The web interface will show instructions on how to set up API keys.'));\n    }\n    // Import and start web server\n    import('./webServer.js')\n      .then(module => {\n        const { startWebServer } = module;\n        logInfo(`Starting web server on port ${process.env.PORT || 8080}...`);\n        startWebServer(version, hasApiKeys, { allowEdit: options.allowEdit });\n      })\n      .catch(error => {\n        logError(chalk.red(`Error starting web server: ${error.message}`));\n        process.exit(1);\n      });\n    return; // Exit main function\n  }\n  // --- End Web Mode ---\n\n\n  // --- Interactive CLI Mode ---\n  // (This block only runs if not non-interactive and not web mode)\n\n  if (!hasApiKeys) {\n    // Use logError and standard console.log for setup instructions\n    logError(chalk.red('No API key provided. Please set ANTHROPIC_API_KEY, OPENAI_API_KEY, or GOOGLE_API_KEY environment variable.'));\n    console.log(chalk.cyan('You can find these instructions in the .env.example file:'));\n    console.log(chalk.cyan('1. Create a .env file by copying .env.example'));\n    console.log(chalk.cyan('2. Add your API key to the .env file'));\n    console.log(chalk.cyan('3. Restart the application'));\n    process.exit(1);\n  }\n\n  // Initialize ProbeChat for CLI mode\n  let chat;\n  try {\n    // Pass session ID if provided (though less common for interactive start)\n    chat = new ProbeChat({\n      sessionId: options.sessionId,\n      isNonInteractive: false,\n      customPrompt: customPrompt,\n      promptType: options.prompt && ['architect', 'code-review', 'support', 'engineer'].includes(options.prompt) ? options.prompt : null,\n      allowEdit: options.allowEdit\n    });\n\n    // Log model/provider info using logInfo\n    if (chat.apiType === 'anthropic') {\n      logInfo(chalk.green(`Using Anthropic API with model: ${chat.model}`));\n    } else if (chat.apiType === 'openai') {\n      logInfo(chalk.green(`Using OpenAI API with model: ${chat.model}`));\n    } else if (chat.apiType === 'google') {\n      logInfo(chalk.green(`Using Google API with model: ${chat.model}`));\n    }\n\n    logInfo(chalk.blue(`Session ID: ${chat.getSessionId()}`));\n    logInfo(chalk.cyan('Type \"exit\" or \"quit\" to end the chat'));\n    logInfo(chalk.cyan('Type \"usage\" to see token usage statistics'));\n    logInfo(chalk.cyan('Type \"clear\" to clear the chat history'));\n    logInfo(chalk.cyan('-------------------------------------------'));\n  } catch (error) {\n    logError(chalk.red(`Error initializing chat: ${error.message}`));\n    process.exit(1);\n  }\n\n  // Format AI response for interactive mode\n  function formatResponseInteractive(response) {\n    // Check if response is a structured object with response and tokenUsage properties\n    let textResponse = '';\n    if (response && typeof response === 'object' && 'response' in response) {\n      textResponse = response.response;\n    } else if (typeof response === 'string') {\n      // Fallback for legacy format or simple string response\n      textResponse = response;\n    } else {\n      return chalk.red('[Error: Invalid response format]');\n    }\n\n    // Apply formatting (e.g., highlighting tool calls)\n    return textResponse.replace(\n      /<tool_call>(.*?)<\\/tool_call>/gs,\n      (match, toolCall) => chalk.magenta(`[Tool Call] ${toolCall}`)\n    );\n  }\n\n  // Main interactive chat loop\n  async function startChat() {\n    while (true) {\n      const { message } = await inquirer.prompt([\n        {\n          type: 'input',\n          name: 'message',\n          message: chalk.blue('You:'),\n          prefix: '',\n        },\n      ]);\n\n      if (message.toLowerCase() === 'exit' || message.toLowerCase() === 'quit') {\n        logInfo(chalk.yellow('Goodbye!'));\n        break;\n      } else if (message.toLowerCase() === 'usage') {\n        const usage = chat.getTokenUsage();\n        const display = new TokenUsageDisplay();\n        const formatted = display.format(usage);\n\n        // Use logInfo for usage details\n        logInfo(chalk.blue('Current:', formatted.current.total));\n        logInfo(chalk.blue('Context:', formatted.contextWindow));\n        logInfo(chalk.blue('Cache:',\n          `Read: ${formatted.current.cache.read},`,\n          `Write: ${formatted.current.cache.write},`,\n          `Total: ${formatted.current.cache.total}`));\n        logInfo(chalk.blue('Total:', formatted.total.total));\n\n        // Show context window in terminal title (only relevant for interactive)\n        process.stdout.write('\\x1B]0;Context: ' + formatted.contextWindow + '\\x07');\n        continue;\n      } else if (message.toLowerCase() === 'clear') {\n        const newSessionId = chat.clearHistory();\n        logInfo(chalk.yellow('Chat history cleared'));\n        logInfo(chalk.blue(`New session ID: ${newSessionId}`));\n        continue;\n      }\n\n      const spinner = ora('Thinking...').start(); // Spinner is ok for interactive mode\n      try {\n        const result = await chat.chat(message); // Uses internal session ID\n        spinner.stop();\n\n        logInfo(chalk.green('Assistant:'));\n        console.log(formatResponseInteractive(result)); // Use standard console.log for the actual response content\n        console.log(); // Add a newline for readability\n\n        // Update terminal title with context window size if available\n        if (result && typeof result === 'object' && result.tokenUsage && result.tokenUsage.contextWindow) {\n          process.stdout.write('\\x1B]0;Context: ' + result.tokenUsage.contextWindow + '\\x07');\n        }\n      } catch (error) {\n        spinner.stop();\n        logError(chalk.red(`Error: ${error.message}`)); // Use logError\n      }\n    }\n  }\n\n  startChat().catch((error) => {\n    logError(chalk.red(`Fatal error in interactive chat: ${error.message}`));\n    process.exit(1);\n  });\n  // --- End Interactive CLI Mode ---\n}\n\n// If this file is run directly, call main()\nif (import.meta.url.startsWith('file:') && process.argv[1] === fileURLToPath(import.meta.url)) {\n  main();\n}\n"],
  "mappings": "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",
  "names": ["resolve", "resolve", "trace", "context", "sessionId", "randomUUID", "resolve", "sessionId", "match", "sessionId", "context", "sessionId", "resolve", "exec", "spawn", "promisify", "path", "execPromise", "resolve", "path", "promisify", "sessionId", "searchTool", "queryTool", "extractTool", "DEFAULT_SYSTEM_MESSAGE", "randomUUID", "fs", "fsPromises", "path", "sessionId", "configOptions", "searchToolInstance", "queryToolInstance", "extractToolInstance", "debug", "resolve", "allowedFolders", "randomUUID", "existsSync", "trace", "listFilesByLevel", "debug", "exists", "searchToolInstance", "queryToolInstance", "extractToolInstance", "sessionId", "resolve", "message", "systemPrompt", "enhancedParams", "errorMessage", "sessionId", "join", "existsSync", "mkdirSync", "writeFileSync", "sessionId", "readFileSync", "existsSync", "dirname", "join", "fileURLToPath", "randomUUID", "sessionId", "searchToolInstance", "queryToolInstance", "extractToolInstance", "req", "res", "exists", "__dirname", "path", "apiCredentials", "chalk", "existsSync", "readFileSync", "resolve", "dirname", "join", "fileURLToPath", "DEFAULT_SYSTEM_MESSAGE", "__dirname", "dirname", "fileURLToPath", "join", "readFileSync", "chalk", "listBackendNames", "getBackendMetadata", "resolve", "existsSync", "allowedFolders", "exists", "chat", "startWebServer"]
}
